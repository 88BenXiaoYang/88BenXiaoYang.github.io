<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="UI视图UITableViewUITableView中数据源同步解决方案  并发访问、数据拷贝，因为拷贝，对内存会有大量开销 串行访问，删除时会可能有延迟  事件传递&amp;amp;视图响应UIView和CALayer之间的关系：UIView的成员属性中有layer，layer是CALayer类型的，UIView的显示部分，是由CALayer的contents来决定的，contents对应的是backi">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS知识点">
<meta property="og:url" content="http://yoursite.com/2020/04/21/iOS知识点/index.html">
<meta property="og:site_name" content="Ben&#39;Blog">
<meta property="og:description" content="UI视图UITableViewUITableView中数据源同步解决方案  并发访问、数据拷贝，因为拷贝，对内存会有大量开销 串行访问，删除时会可能有延迟  事件传递&amp;amp;视图响应UIView和CALayer之间的关系：UIView的成员属性中有layer，layer是CALayer类型的，UIView的显示部分，是由CALayer的contents来决定的，contents对应的是backi">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/事件传递的流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/hit系统实现.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/视图响应流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/CPU_GPU的关系.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/图像显示原理.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/UIView绘制原理的过程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/系统的绘制流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/异步绘制时序流程图.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/关联对象的本质.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/分类成员变量的本质.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/通知一对多的流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/实现通知的机制.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/KVO的实现机制.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/valueForKey调用流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/访问器.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/实例变量.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/setValueForKey的调用流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/copy关键字.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/objc_object主要成员.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/objc_class结构体构成.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/isa指针类型.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/isa指向.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/cache_t的结构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/class_rw_t结构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/class_ro_t结构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/method_t结构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/types结构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/runtime基础数据结构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/类对象和元类对象关系.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/消息传递.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/缓存查找.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/父类逐级查找.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/实例方法的消息转发.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/内存布局.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/non_isa_bit_01.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/non_isa_bit_02.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/SideTables结构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/SideTable结构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/RefcountMap.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/RefcountMap_Size_t.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/弱引用表.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/retain实现.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/release实现.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/retainCount实现.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/dealloc实现的流程图.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/object_dispose(">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/objc_destructInstance(">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/clearDeallocating(">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/添加weak变量.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/autorelease流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/不同block的内存分布.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/block_copy的效果.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/栈上block的销毁.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/栈上block的copy.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/栈上__block的copy操作.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/NSThread启动流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/实现常驻线程功能的实现.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/RunLoop各数据结构之间的关系.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/RunLoop的Mode.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/RunLoop事件循环机制流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/RunLoop的核心.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/请求报文.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/响应报文.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/get_post的区别.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/中间人攻击.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/HTTPS协议栈.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/HTTPS建立连接流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/非对称加密.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/对称加密.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/滑动窗口协议过程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/DNS递归查询.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/DNS迭代查询.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/DNS劫持.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/iOS知识点/httpDNS实现理论.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/DNS长连接方案.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/Cookie流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/Session工作流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/六大设计原则.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/责任链类构成.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/桥接类构成.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/对象适配器类构成.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/对象适配器的逻辑实现.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/单例实现代码.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/图片缓存框架.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/框架中图片的读取过程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/存储的Size.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/图片框架中线程处理时序流程图.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/时长统计的框架.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/微博整体架构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/微博整体架构视图层.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/微博整体架构业务逻辑层.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/微博整体架构数据层.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/微博整体架构数据流.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/微博整体架构数据间关系.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/微博整体架构反向更新.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/微博整体架构涉及的思想.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/MVVM结构图.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/RN数据流思想.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/客户端整体架构.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/依赖注入.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/字符串反转.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/链表反转.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/有序数组合并.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/有序数组合并有剩余数组.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/hash算法.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/AFN框架图.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/主要类关系图.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/SDWeb架构简图.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/SDWeb加载图片流程.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/RACSignal结构图.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/订阅信号的工作逻辑.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/订阅内部原理.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/ASDK主要处理的问题.png">
<meta property="og:image" content="http://yoursite.com/2020/04/21/iOS知识点/ASDK基本原理.png">
<meta property="og:updated_time" content="2020-11-23T03:54:31.153Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS知识点">
<meta name="twitter:description" content="UI视图UITableViewUITableView中数据源同步解决方案  并发访问、数据拷贝，因为拷贝，对内存会有大量开销 串行访问，删除时会可能有延迟  事件传递&amp;amp;视图响应UIView和CALayer之间的关系：UIView的成员属性中有layer，layer是CALayer类型的，UIView的显示部分，是由CALayer的contents来决定的，contents对应的是backi">
<meta name="twitter:image" content="http://yoursite.com/2020/04/21/iOS知识点/事件传递的流程.png">

<link rel="canonical" href="http://yoursite.com/2020/04/21/iOS知识点/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>iOS知识点 | Ben'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ben'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工欲善其事，必先利其器</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/iOS知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-21 16:22:19" itemprop="dateCreated datePublished" datetime="2020-04-21T16:22:19+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="UI视图"><a href="#UI视图" class="headerlink" title="UI视图"></a>UI视图</h2><h3 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h3><p>UITableView中数据源同步解决方案</p>
<ul>
<li>并发访问、数据拷贝，因为拷贝，对内存会有大量开销</li>
<li>串行访问，删除时会可能有延迟</li>
</ul>
<h3 id="事件传递-amp-视图响应"><a href="#事件传递-amp-视图响应" class="headerlink" title="事件传递&amp;视图响应"></a>事件传递&amp;视图响应</h3><p>UIView和CALayer之间的关系：UIView的成员属性中有layer，layer是CALayer类型的，UIView的显示部分，是由CALayer的contents来决定的，contents对应的是backing store，backing store是bitmap类型的一个位图，最后显示到屏幕上的UI控件都是位图</p>
<p>总结：</p>
<ul>
<li>UIView为CALayer提供内容，以及负责处理触摸等事件，参与视图的事件响应链</li>
<li>CALayer负责显示内容contents</li>
</ul>
<p>UIView和CALayer功能不同，却又相互联系，体现了设计原则上的单一职责原则，从职责上进行分工</p>
<hr>
<p><strong>事件传递</strong>与<strong>视图响应链</strong></p>
<p>与事件传递相关的两个主要方法：</p>
<ul>
<li>hitTest:withEvent:，返回响应事件的视图</li>
<li><p>pointInside:withEvent:，判断点击的位置，是否在当前视图的范围内</p>
</li>
<li><p>事件传递流程：</p>
<ul>
<li>事件传递流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/事件传递的流程.png" alt="事件传递的流程"></p>
<p>倒序遍历，即最后添加到当前View上的视图，最优先得到遍历</p>
<ul>
<li>hit系统实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/hit系统实现.png" alt="hit系统实现"></p>
</li>
<li><p>视图响应流程：(响应事件)</p>
<ul>
<li>视图响应流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/视图响应流程.png" alt="视图响应流程"></p>
</li>
</ul>
<p>与视图事件响应相关的方法：</p>
<ul>
<li>touchesBegan:withEvent:</li>
<li>touchesMoved:withEvent:</li>
<li>touchesEnded:withEvent:</li>
</ul>
<h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><ul>
<li>硬件<code>CPU</code>和<code>GPU</code>的关系</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/CPU_GPU的关系.png" alt="CPU_GPU的关系"></p>
<p>硬件<code>CPU</code>和<code>GPU</code>是通过总线连接起来的。<code>CPU</code>输出的结果通常是位图，在适当的时机，通过总线上传给<code>GPU</code>，<code>GPU</code>获得位图数据后进行纹理等渲染操作，将经渲染操作处理后的结果数据放在帧缓冲区内(Frame Buffer)，由视频控制器根据V-Sync信号，在指定时间之前去提取对应帧缓冲区内的屏幕显示内容，最终显示在手机屏幕上。</p>
<ul>
<li><p><code>UI</code>视图最终显示到屏幕上面的大致过程</p>
<ul>
<li>图像显示原理</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/图像显示原理.png" alt="图像显示原理"></p>
</li>
</ul>
<p>概述：</p>
<p>当创建一个<code>UIView</code>控件后，显示部分是由<code>CALayer</code>来负责的，<code>CALayer</code>中的<code>contents</code>属性负责存放要显示到屏幕上的内容的位图。系统在适当时机会回调给我们<code>drawRect</code>方法，在该方法内，我们可以做自定义的绘制，绘制好的位图，最终会经由<code>Core Animation</code>这个框架提交给<code>GPU</code>部分的<code>OpenGL(ES)</code>渲染管线，进行最终的位图渲染、纹理合成，最终显示到屏幕上面。</p>
<h3 id="卡顿-amp-掉帧"><a href="#卡顿-amp-掉帧" class="headerlink" title="卡顿&amp;掉帧"></a>卡顿&amp;掉帧</h3><p>为保证界面流畅性，需要在1/60s内(即16.67ms)，由<code>CPU</code>和<code>GPU</code>共同协同完成产生一帧所需要的数据。</p>
<p>卡顿原因：</p>
<p>在规定的<code>16.67ms</code>之内，在下一个<code>V-Sync</code>信号到来之前，并没有<code>CPU</code>和<code>GPU</code>共同完成下一帧画面的合成，于是就会导致卡顿/掉帧。</p>
<p>滑动优化方案：</p>
<p>优化依据：视图显示过程中，在准备下一帧画面之前，CPU所做的工作非常多(layout、display、prepare、commit)。实际上是基于减轻CPU工作的时长、包括压力，来达到优化的效果。</p>
<ul>
<li><p>针对CPU的优化方案</p>
<ul>
<li>对象创建、调整、销毁，可以放到子线程，以节省CPU的部分时间</li>
<li>预排版(布局计算、文本计算)，可以放到子线程处理，这样主线程就有更多的时间能较快响应用户的交互</li>
<li>预渲染(文本等异步绘制、图片编解码等)</li>
</ul>
</li>
<li><p>针对GPU等优化方案</p>
<ul>
<li>基于纹理渲染，尽量避免离屏渲染。产生离屏渲染后，GPU的工作量会变大</li>
<li>可以依托CPU的异步绘制机制，来减轻GPU的压力</li>
<li>基于视图混合，减轻视图层级的复杂性</li>
</ul>
</li>
</ul>
<h3 id="绘制原理-amp-异步绘制"><a href="#绘制原理-amp-异步绘制" class="headerlink" title="绘制原理&amp;异步绘制"></a>绘制原理&amp;异步绘制</h3><p>异步绘制是用来解决UI视图滑动性能方面的技术解决方案</p>
<ul>
<li><p>UIView视图绘制原理步骤</p>
<ul>
<li>UIView绘制原理的流程图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/UIView绘制原理的过程.png" alt="UIView绘制原理的过程"></p>
</li>
</ul>
<p>调用setNeedsDisplay不会立即进入到绘制流程，只有在当前RunLoop将要结束的时候，才会进入到当前视图的绘制流程</p>
<ul>
<li>系统的绘制流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/系统的绘制流程.png" alt="系统的绘制流程"></p>
<ul>
<li><p>UI异步绘制的过程</p>
<ul>
<li>实现系统提供的接口displayLayer:</li>
<li>代理负责生成对应的bitmap</li>
<li>设置该bitmap作为layer.contents属性的值</li>
</ul>
</li>
<li><p>异步绘制时序流程图</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/异步绘制时序流程图.png" alt="异步绘制时序流程图"></p>
<h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p>什么是离屏渲染、对离屏渲染的理解</p>
<p>离屏渲染的概念起源于GPU层面</p>
<p>相对离屏渲染而言的是在屏渲染(即当前屏幕渲染)</p>
<p>在屏渲染指的是GPU层面的一个概念</p>
<ul>
<li><p>何时触发离屏渲染</p>
<ul>
<li>圆角(同时要和maskToBounds一起使用时)，两个条件都满足时才能触发离屏渲染</li>
<li>图层蒙版</li>
<li>阴影</li>
<li>光栅化</li>
</ul>
</li>
<li><p>为何要避免离屏渲染</p>
<ul>
<li>因，离屏渲染发生在GPU层面，触发离屏渲染会增加GPU的工作量</li>
<li>创建新的渲染缓冲区</li>
<li>上下文切换</li>
</ul>
</li>
</ul>
<hr>
<h2 id="OC语言特性"><a href="#OC语言特性" class="headerlink" title="OC语言特性"></a>OC语言特性</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>分类的使用</p>
<ul>
<li>声明私有方法</li>
<li>分解体积庞大的类文件</li>
<li>把Framework的私有方法公开化</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>在运行时进行决议，只有在运行时，才将在分类中的方法添加到宿主类中(编译时/运行时)</li>
<li>可以为系统类添加分类</li>
</ul>
</li>
<li><p>分类中可添加的内容</p>
<ul>
<li>实例方法</li>
<li>类方法</li>
<li>协议</li>
<li>属性(实际上只声明了对应的set/get方法，不能直接添加实例变量/成员变量)</li>
</ul>
</li>
</ul>
<p>多个分类中的同名方法哪个会生效，最后编译的分类中的同名方法会生效</p>
<p><strong>分类方法会“覆盖”宿主类的方法</strong>，因在分类的源代码实现过程中，分类中的方法在方法列表中的位置处于原宿主方法的前面，当分类中的方法与宿主中的方法同名时，所要执行的方法命中方法列表中分类的方法(优先实现)，就不会再执行宿主中的同名方法，体现效果为分类中的方法“覆盖”了宿主中的同名方法</p>
<ul>
<li>分类的总结<ul>
<li>分类添加的方法可以“覆盖”原类方法</li>
<li>同名分类方法谁能生效取决于编译顺序(最后被编译的分类，会被优先生效)</li>
<li>名字相同的分类会引起编译报错</li>
</ul>
</li>
</ul>
<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><ul>
<li><p>关联对象的本质</p>
<ul>
<li>关联对象由AssociationsManager管理并在AssociationsHashMap存储</li>
<li>所有对象的关联内容都在同一个全局容器中</li>
<li>具体过程，可见下图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/关联对象的本质.png" alt="关联对象的本质"></p>
</li>
</ul>
<p>通过关联对象，可以给分类添加“成员变量”。添加的“成员变量”，没有添加到宿主类上，添加到一个全局容器中。可见下图</p>
<p><img src="/2020/04/21/iOS知识点/分类成员变量的本质.png" alt="分类成员变量的本质"></p>
<ul>
<li>使用的关键方法<ul>
<li>objc_getAssociatedObject</li>
<li>objc_setAssociatedObject</li>
<li>objc_removeAssociatedObjects</li>
</ul>
</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><p>用扩展来做</p>
<ul>
<li>声明私有属性</li>
<li>声明私有方法</li>
<li>声明私有成员变量</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>编译时决议</li>
<li>只以声明的形式存在，多数情况下寄生于宿主类的.m中(分类有声明.h和实现.m)</li>
<li>不能为系统类添加扩展(可以为系统类添加分类)</li>
</ul>
</li>
</ul>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><ul>
<li>准确的说是一种软件设计模式(代理模式)</li>
<li>iOS当中以@protocol形式体现</li>
<li>传递方式是一对一</li>
<li>涉及协议(方法、属性)、委托方、代理方</li>
</ul>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><ul>
<li><p>特点</p>
<ul>
<li>是使用<strong>观察者模式</strong>(特点)来实现的用于<strong>跨层传递消息</strong>(作用)的机制</li>
<li>传递方式为一对多</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/通知一对多的流程.png" alt="通知一对多的流程"></p>
</li>
<li><p>如何实现通知的机制</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/实现通知的机制.png" alt="实现通知的机制"></p>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><ul>
<li><p>什么是KVO</p>
<ul>
<li>KVO是Key-value observing的缩写</li>
<li>KVO是OC对<strong>观察者设计模式</strong>的又一实现</li>
<li>Apple使用了isa混写(<strong>isa-swizzling</strong>)来实现KVO(如何实现混写，涉及KVO的实现机制)</li>
</ul>
</li>
<li><p>KVO的实现机制</p>
</li>
</ul>
<p>isa混写技术的实现(系统在运行时动态创建了一个子类，改写了isa的指向，同时重写了setter方法，来实现kvo的机制的)(调用addObserverForKeyPath之后系统底层的实现)</p>
<p><img src="/2020/04/21/iOS知识点/KVO的实现机制.png" alt="KVO的实现机制"></p>
<p>重写setter方法的过程中，调用了如下两个方法</p>
<ul>
<li>willChangeValueForKey:</li>
<li><p>didChangeValueForKey:</p>
</li>
<li><p>面试点</p>
<ul>
<li>通过kvc设置value能使kvo生效，因为通过kvc设置value的过程中，触发了目标对象对应的setter方法</li>
<li>通过成员变量的直接赋值，是不会触发系统的kvo</li>
<li>手动kvo方式，即对相应属性手动重写willChangeValueForKey和didChangeValueForKey(will、did成对出现)</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>使用setter方法改变值kvo才会生效</li>
<li>使用setValue:forKey:改变值kvo才会生效</li>
<li>成员变量直接修改需<strong>手动添加</strong>kvo才会生效</li>
</ul>
</li>
</ul>
<h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><ul>
<li><p>键值编码技术，与键值编码技术相关的两个方法</p>
<ul>
<li>-valueForKey:</li>
<li>-setValue:forKey:</li>
</ul>
<p>KVC这种键值编码技术，是会破坏面向对象编程思想</p>
<ul>
<li>valueForKey的调用流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/valueForKey调用流程.png" alt="valueForKey调用流程"></p>
<p>关键点是访问器、实例变量</p>
<ul>
<li>访问器的说明</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/访问器.png" alt="访问器"></p>
<ul>
<li>实例变量的说明</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/实例变量.png" alt="实例变量"></p>
<ul>
<li>setValue:forKey:的调用流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/setValueForKey的调用流程.png" alt="setValueForKey的调用流程"></p>
</li>
</ul>
<h3 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h3><ul>
<li><p>属性关键字的类型</p>
<ul>
<li>读写权限<ul>
<li>readonly</li>
<li>readwrite(默认)</li>
</ul>
</li>
<li>原子性<ul>
<li>atomic(默认)，指明赋值或获取是线程安全的</li>
<li>nonatomic(常声明的类型)</li>
</ul>
</li>
<li>引用计数<ul>
<li>retain(MRC)/strong(ARC)</li>
<li>assign(修饰基本数据类型、对象类型)/unsafe_unretained(MRC)</li>
<li>weak</li>
<li>copy</li>
</ul>
</li>
</ul>
</li>
<li><p>assign/weak</p>
<ul>
<li>assign<ul>
<li>修饰基本数据类型，如int、BOOL等</li>
<li>修饰对象类型时，不改变其引用计数</li>
<li>会产生悬垂指针</li>
</ul>
</li>
<li><p>weak</p>
<ul>
<li>不改变被修饰对象的引用计数</li>
<li>所指对象在被释放之后会自动置为nil</li>
</ul>
</li>
<li><p>copy关键字</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/copy关键字.png" alt="copy关键字"></p>
</li>
</ul>
<hr>
<h2 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h2><h3 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h3><ul>
<li>编译时语言与动态运行时语言的区别</li>
<li>消息传递与函数调用的区别</li>
<li>消息传递</li>
<li>消息转发</li>
<li>Method-Swizzling(方法混淆)(运行时替换方法的实现)</li>
<li>不能向编译后的类中增加实例变量，因此时已经完成了实例变量的内存布局，所以编译后是无法修改的</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>objc_object</p>
<ul>
<li>OC中常用的id类型，对应到Runtime中就是objc_object这个结构体</li>
<li><p>objc_object结构体中的主要成员如下图</p>
<p><img src="/2020/04/21/iOS知识点/objc_object主要成员.png" alt="objc_object主要成员"></p>
</li>
</ul>
<ul>
<li><p>objc_class</p>
<ul>
<li>OC中使用的Class类型，对应到Runtime中就是objc_class这个结构体</li>
<li><p>objc_class结构体的构成如下图</p>
<p><img src="/2020/04/21/iOS知识点/objc_class结构体构成.png" alt="objc_class结构体构成"></p>
</li>
</ul>
</li>
<li><p>isa指针</p>
<ul>
<li>是共用体isa_t类型</li>
<li><p>以64位架构为例，isa指针类型如下图</p>
<p><img src="/2020/04/21/iOS知识点/isa指针类型.png" alt="isa指针类型"></p>
</li>
<li><p>isa指向</p>
<p><img src="/2020/04/21/iOS知识点/isa指向.png" alt="isa指向"></p>
</li>
</ul>
</li>
<li><p>cache_t</p>
<ul>
<li>用于快速查找方法执行函数</li>
<li>是可增量扩展的哈希表结构</li>
<li>是<strong>局部性原理</strong>的最佳应用(常被调用的方法，放到方法缓冲区中，提高调用方法时被调用方法的命中率)</li>
<li><p>cache_t结构说明如下图</p>
<p><img src="/2020/04/21/iOS知识点/cache_t的结构.png" alt="cache_t的结构"></p>
<p>key是方法选择器名称</p>
</li>
</ul>
</li>
<li><p>class_data_bits_t</p>
<ul>
<li>class_data_bits_t主要是对class_rw_t的封装</li>
<li>class_rw_t代表了类相关的读写信息、对class_ro_t的封装</li>
<li>class_ro_t代表了类相关的只读信息</li>
<li><p>class_rw_t结构如下</p>
<p><img src="/2020/04/21/iOS知识点/class_rw_t结构.png" alt="class_rw_t结构"></p>
</li>
<li><p>class_ro_t结构如下</p>
<p><img src="/2020/04/21/iOS知识点/class_ro_t结构.png" alt="class_ro_t结构"></p>
</li>
<li><p>method_t</p>
<ul>
<li>method_t是对函数四要素的封装和抽象</li>
<li><p>method_t结构如下</p>
<p><img src="/2020/04/21/iOS知识点/method_t结构.png" alt="method_t结构"></p>
</li>
<li><p>method_t中的types结构，使用了Type Encodings技术</p>
</li>
<li><p>types结构如下</p>
<p><img src="/2020/04/21/iOS知识点/types结构.png" alt="types结构"></p>
<p>图中的v@:就是method_t中types所存储的内容。图中体现了调用函数时，函数中所隐藏的固有参数self(消息接收者)，即函数的调用者，对应到types中的@来体现</p>
<p>调用方法(消息传递)，到达Runtime层面都会转换成objc_msgSend()这样的函数调用，objc_msgSend()的第一个参数和第二个参数都是固定不变的，第一个参数需是id类型(是消息的接收者)，第二个参数是SEL(选择器)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Runtime整体数据结构</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/runtime基础数据结构.png" alt="runtime基础数据结构"></p>
<p>基于上图可作为回答<strong>消息传递机制</strong>、<strong>转发流程</strong>、<strong>编译时语言和动态运行时语言的区别</strong>的依据</p>
</li>
</ul>
<h3 id="类对象、元类对象-amp-消息传递"><a href="#类对象、元类对象-amp-消息传递" class="headerlink" title="类对象、元类对象&amp;消息传递"></a>类对象、元类对象&amp;消息传递</h3><ul>
<li><p>什么是类对象、元类对象</p>
<ul>
<li>类对象</li>
<li>元类对象</li>
</ul>
</li>
<li><p>实例对象可以通过isa指针找到对应的类对象</p>
</li>
<li><strong>类对象</strong>存储<strong>实例方法</strong>列表等信息</li>
<li><strong>元类对象</strong>存储<strong>类方法</strong>列表等信息</li>
<li>调用的类方法，是从元类的类方法列表中查找获取的</li>
<li>类对象和元类对象关系图如下</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/类对象和元类对象关系.png" alt="类对象和元类对象关系"></p>
<p>从给定的实例对象，依据上图进行分析、论述类对象与元类对象间的关系</p>
<p><strong>重听5-3</strong></p>
<ul>
<li>id类型对应是objc_object数据结构类型，objc_object中有isa成员变量</li>
<li><strong>isa是指针指向</strong></li>
<li><p>类对象和元类对象都是objc_class数据结构的，objc_class继承于objc_object，所以类对象和元类对象都有isa指针</p>
</li>
<li><p>消息传递转化成了函数调用，是发生在<strong>编译器</strong>层面的</p>
</li>
<li><p>消息传递</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/消息传递.png" alt="消息传递"></p>
<ul>
<li><p>消息传递流程中的关键环节</p>
<ul>
<li><p>缓存查找</p>
<ul>
<li><p>缓存查找，实际上就是根据给定的方法选择器(SEL)，来查找方法的对应实现(IMP)</p>
<p><img src="/2020/04/21/iOS知识点/缓存查找.png" alt="缓存查找"></p>
</li>
<li><p>hash查找</p>
</li>
</ul>
</li>
<li><p>当前类中查找</p>
<ul>
<li>对于已排好序的方法列表，采用二分查找</li>
<li>对于未排序的方法列表，采用一般遍历查找</li>
</ul>
</li>
<li><p>父类逐级查找</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/父类逐级查找.png" alt="父类逐级查找"></p>
</li>
</ul>
<h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><ul>
<li>实例方法的消息转发流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/实例方法的消息转发.png" alt="实例方法的消息转发"></p>
<ul>
<li>方法签名<ul>
<li>根据method_t中的types来理解，方法签名的格式如‘v@:’</li>
</ul>
</li>
</ul>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method-Swizzling"></a>Method-Swizzling</h3><ul>
<li>用于页面统计等场景</li>
</ul>
<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><ul>
<li>为类动态添加方法<ul>
<li>使用接口class_addMethod()</li>
</ul>
</li>
</ul>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><ul>
<li><p>dynamic</p>
<ul>
<li>指明属性的setter和getter方法是在运行时添加，不是在编译时实现</li>
</ul>
</li>
<li><p>用dynamic做引子，作如下回答</p>
<ul>
<li>动态运行时语言将函数决议推迟到运行时</li>
<li>编译时语言在编译期进行函数决议</li>
</ul>
</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><ul>
<li>内存布局</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/内存布局.png" alt="内存布局"></p>
<ul>
<li>stack，栈区，方法调用，在该内存区进行展开</li>
<li>heap，堆区，通过alloc等分配的对象</li>
<li>bss，未初始化的全局变量等</li>
<li>data，已初始化的全局变量等</li>
<li>text，程序的代码段，加载到内存中，就存放在该区域中</li>
</ul>
<h3 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h3><ul>
<li>iOS系统针对不同的场景，会有不同的内存管理方案<ul>
<li>针对小对象，如NSNumber这样的，采用的是TaggedPointer内存管理方案</li>
<li>对于64位架构下的应用程序，采用的是NONPOINTER_ISA方案<ul>
<li>非指针型的isa，bit位除存储实际的isa指针信息外，剩余未使用的bit位用于存放内存管理相关的信息</li>
</ul>
</li>
<li>散列表，复杂的数据结构，包括<ul>
<li>引用计数表</li>
<li>弱引用表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER_ISA"></a>NONPOINTER_ISA</h4><ul>
<li><p>非指针型的isa</p>
</li>
<li><p>在arm64架构下，对NONPOINTER_ISA进行分析</p>
<ul>
<li>这种情况下isa的指针是64个bit位</li>
<li>bit结构如下</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/non_isa_bit_01.png" alt="non_isa_bit_01"></p>
<p><img src="/2020/04/21/iOS知识点/non_isa_bit_02.png" alt="non_isa_bit_02"></p>
<ul>
<li>第一位indexed，如为0的情况下，表示指针型的isa，即整体的bit数值表示的是实际的地址指针信息；如为1的情况下，表示非指针型的isa，即bit位除存储实际的isa指针信息外，剩余未使用的bit位用于存放内存管理相关的信息</li>
<li>shiftcls，是用于存储类地址值信息的</li>
</ul>
</li>
</ul>
<h4 id="散列表方式"><a href="#散列表方式" class="headerlink" title="散列表方式"></a>散列表方式</h4><ul>
<li>通过SideTables()这样的结构来实现<ul>
<li>SideTables()实际上是一个hash表</li>
</ul>
</li>
<li>SideTables()的结构如下</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/SideTables结构.png" alt="SideTables结构"></p>
<p><img src="/2020/04/21/iOS知识点/SideTable结构.png" alt="SideTable结构"></p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>内存管理方案<strong>散列表</strong>涉及的数据结构</p>
<ul>
<li><p>散列表的成员结构</p>
<ul>
<li>Spinlock_t(自旋锁)<ul>
<li>是“忙等”的锁</li>
<li>适用于轻量访问，如SideTable中对某个对象进行引用计数加一减一的操作(该操作非常快)</li>
</ul>
</li>
<li><p>RefcountMap(引用计数表)</p>
<ul>
<li>实际上是一个hash表</li>
<li>通过指针找到对应对象的引用计数</li>
<li>size_t(表示对应对象的引用计数值)(考虑引用计数存储是用64位的bit来表示的环境下的情况)</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RefcountMap.png" alt="RefcountMap"></p>
<p><img src="/2020/04/21/iOS知识点/RefcountMap_Size_t.png" alt="RefcountMap_Size_t"></p>
</li>
<li><p>weak_table_t(弱引用表)</p>
<ul>
<li>实际上是一张hash表</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/弱引用表.png" alt="弱引用表"></p>
</li>
</ul>
</li>
</ul>
<p>Tips:</p>
<p>hash查找可以提高效率的原因，因插入和获取都是通过同一个hash函数进行的，所以在根据给定值去hash列表中查找某个值时，会避免一般查找时所采取的循环遍历，进而提高了查找效率</p>
<h3 id="MRC-amp-ARC"><a href="#MRC-amp-ARC" class="headerlink" title="MRC&amp;ARC"></a>MRC&amp;ARC</h3><h4 id="MRC环境下"><a href="#MRC环境下" class="headerlink" title="MRC环境下"></a>MRC环境下</h4><ul>
<li>关于引用计数，涉及如下方法<ul>
<li>alloc、retain、release、retainCount、autorelease、dealloc</li>
</ul>
</li>
</ul>
<h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><ul>
<li>ARC是LLVM和Runtime协作的结果</li>
<li>ARC中禁止手动调用retain/release/retainCount/dealloc</li>
<li>ARC中新增weak、strong属性关键字</li>
</ul>
<h3 id="引用计数管理"><a href="#引用计数管理" class="headerlink" title="引用计数管理"></a>引用计数管理</h3><ul>
<li><p>通过分析alloc、retain、release、retainCount、dealloc等系统方法的内部实现来理解引用计数管理的实现流程</p>
</li>
<li><p>alloc的实现</p>
<ul>
<li>经过一系列调用，最终调用了C函数calloc</li>
<li>此时并没有设置引用计数为1。但调用retainCount查看引用计数值时，引用计数值为1，具体原因看retainCount的实现</li>
</ul>
</li>
<li><p>retain实现</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/retain实现.png" alt="retain实现"></p>
<p>加一操作不是真实的加上数字1，而是加上了一个偏移量，这个偏移量是4，反映出来的结果就是加一操作</p>
<ul>
<li>release实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/release实现.png" alt="release实现"></p>
<ul>
<li>retainCount实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/retainCount实现.png" alt="retainCount实现"></p>
<p>刚新alloc出来的一个对象，在引用计数表中，实际上是没有这个对象相关联的一个key-value的一个映射的，因此此时table.refcnts.find(this)-&gt;second读出来的值是0</p>
<ul>
<li>dealloc实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/dealloc实现的流程图.png" alt="dealloc实现的流程图"></p>
<p><strong>是否可以释放</strong>的判断环节，依据右边的五个标准进行判断，当五个标准都不满足时走YES流程。五个标准中的has_cxx_dtor会判断是否进行了c++操作、是否有ARC操作</p>
<ul>
<li>object_dispose()实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/object_dispose(" alt="object_dispose()实现">实现.png)</p>
<ul>
<li>objc_destructInstance()实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/objc_destructInstance(" alt="objc_destructInstance()实现">实现.png)</p>
<ul>
<li>clearDeallocating()实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/clearDeallocating(" alt="clearDeallocating()实现">实现.png)</p>
<p>weak修饰的属性在所指向的对象被释放后，相应属性被置为nil的原因，因系统底层在执行dealloc的时候，若对象有被weak修饰的属性所指向时，会执行weak_clear_no_lock()操作</p>
<h3 id="弱引用管理"><a href="#弱引用管理" class="headerlink" title="弱引用管理"></a>弱引用管理</h3><p><strong>重听6-6、6-7、6-8</strong></p>
<ul>
<li><p>weak变量，是怎样添加到弱引用表当中的，通过weak_register_no_lock()实现的</p>
</li>
<li><p>添加weak变量，发生的函数调用栈如下图</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/添加weak变量.png" alt="添加weak变量"></p>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><ul>
<li><p>自动释放池的实现原理</p>
<ul>
<li>是以栈为结点通过双向链表的形式组合而成</li>
<li>是和线程一一对应的</li>
</ul>
</li>
<li><p>autorelease流程</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/autorelease流程.png" alt="autorelease流程"></p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><ul>
<li><p>类型</p>
<ul>
<li>自循环引用</li>
<li>相互循环引用</li>
<li>多循环引用</li>
</ul>
</li>
<li><p>产生循环引用的情况</p>
<ul>
<li>代理（相互循环引用）</li>
<li>Block</li>
<li>NSTimer</li>
<li>大环引用</li>
</ul>
</li>
<li><p>如何破除循环引用</p>
<ul>
<li>避免产生循环引用</li>
<li>在合适的时机手动断环</li>
</ul>
</li>
<li><p>破除循环引用的解决方案</p>
<ul>
<li>__weak</li>
<li>__block<ul>
<li>MRC下，__block修饰对象不会增加其引用计数，避免了循环引用</li>
<li>ARC下，__block修饰对象会被强引用，无法避免循环引用，需要手动解环</li>
</ul>
</li>
<li>__unsafe_unretained，所修饰的对象，引用计数器不改变，等效于__weak<ul>
<li>修饰对象不会增加其引用计数，避免了循环引用</li>
<li>如果被修饰对象在某一时机被释放，会产生<strong>悬垂指针</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><h3 id="本质-什么是block"><a href="#本质-什么是block" class="headerlink" title="本质(什么是block)"></a>本质(什么是block)</h3><ul>
<li>Block是将<strong>函数</strong>及其<strong>执行上下文</strong>封装起来的<strong>对象</strong></li>
<li>理解Block是一个对象，是因其成员结构中有isa指针(Block是对象的标志)</li>
<li>Block的调用<ul>
<li>Block调用即是函数的调用</li>
</ul>
</li>
</ul>
<h3 id="截获变量"><a href="#截获变量" class="headerlink" title="截获变量"></a>截获变量</h3><p><strong>重点看</strong></p>
<p>针对不同类型的变量，block对变量的截获特点是不同的</p>
<ul>
<li><p>被截获变量的类型</p>
<ul>
<li>局部变量<ul>
<li>基本数据类型<ul>
<li>对于基本数据类型的局部变量截获其值</li>
</ul>
</li>
<li>对象类型<ul>
<li>对于对象类型的局部变量<strong>连同所有权修饰符</strong>一起截获</li>
</ul>
</li>
</ul>
</li>
<li><p>静态局部变量</p>
<ul>
<li>以指针形式截获局部静态变量</li>
</ul>
</li>
<li><p>全局变量</p>
</li>
<li>静态全局变量<ul>
<li>不截获全局变量、静态全局变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h3><ul>
<li>MRC下，__block修饰对象不会增加其引用计数，避免了循环引用</li>
<li><p>ARC下，__block修饰对象会被强引用，无法避免循环引用，需要手动解环</p>
</li>
<li><p>使用场景</p>
<ul>
<li>一般情况下，对被截获变量进行<strong>赋值</strong>操作需添加__block修饰符</li>
<li>使用 != 赋值，如对可变数组的使用</li>
</ul>
</li>
<li><p>对变量进行赋值时</p>
<ul>
<li>需要__block修饰符<ul>
<li>局部变量<ul>
<li>基本数据类型</li>
<li>对象类型</li>
</ul>
</li>
</ul>
</li>
<li>不需要__block修饰符<ul>
<li>静态局部变量</li>
<li>全局变量</li>
<li>静态全局变量</li>
</ul>
</li>
</ul>
</li>
<li><p>__block修饰的变量变成了对象</p>
</li>
<li><p><strong>栈上的__block</strong>的<strong>forwarding指针是指向</strong>block自身的</p>
</li>
<li><p>__forwarding指针与Block的内存管理有关</p>
</li>
</ul>
<h3 id="Block的内存管理"><a href="#Block的内存管理" class="headerlink" title="Block的内存管理"></a>Block的内存管理</h3><ul>
<li><p>block的类型，三种</p>
<ul>
<li>_NSConcreteGlobalBlock(全局)</li>
<li>_NSConcreteStackBlock(栈)</li>
<li>_NSConcreteMallocBlock(堆)</li>
</ul>
</li>
<li><p>不同类型的block在内存中的布局，如下图</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/不同block的内存分布.png" alt="不同block的内存分布"></p>
<ul>
<li>对block进行copy的效果</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/block_copy的效果.png" alt="block_copy的效果"></p>
<ul>
<li>栈上block的销毁</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/栈上block的销毁.png" alt="栈上block的销毁"></p>
<ul>
<li>栈上block的copy</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/栈上block的copy.png" alt="栈上block的copy"></p>
<ul>
<li>栈上__block的copy操作</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/栈上__block的copy操作.png" alt="栈上__block的copy操作"></p>
<p>注：前提是经过了copy操作</p>
<ul>
<li>__forwarding存在的意义<ul>
<li>不论在任何内存位置，都可以顺利访问同一个__block变量</li>
</ul>
</li>
</ul>
<h3 id="循环引用-1"><a href="#循环引用-1" class="headerlink" title="循环引用"></a>循环引用</h3><p><strong>重看7-5</strong> </p>
<hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>iOS系统中提供的多线程技术方案<ul>
<li>GCD</li>
<li>NSOperation(AFN)</li>
<li>NSThread(常驻线程)</li>
</ul>
</li>
</ul>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><ul>
<li>主队列当中所提交的任务，不论通过同步方式，还是异步方式，最终都要在主线程中进行处理和执行</li>
<li>通过同步方式提交任务，不论是提交到并行队列，还是串行队列，最终都是在当前线程上进行执行</li>
<li>GCD底层所分派的线程，默认情况下，是没有开启对应的RunLoop的，此时在线程中想要执行的方法，需要提交到线程对应的RunLoop中，并且RunLoop启动了，这时想要执行的方法才会执行生效(涉及线程和RunLoop的关系)</li>
</ul>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async()"></a>dispatch_barrier_async()</h3><ul>
<li>利用GCD实现多读单写</li>
</ul>
<h3 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async()"></a>dispatch_group_async()</h3><p><strong>重听8-3</strong></p>
<ul>
<li>使用GCD实现：A、B、C三个任务并发，完成后执行任务D</li>
</ul>
<h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><ul>
<li><p>使用NSOperation实现多线程编程，需要和NSOperationQueue配合使用来实现多线程方案</p>
</li>
<li><p>实现多线程方案的优势和特点</p>
<ul>
<li>可以添加任务依赖，通过addDependency以及removeDependency方法为任务添加依赖或移除依赖，这种特点是GCD和NSThead所不具备的</li>
<li>任务执行状态的控制<ul>
<li>isReady</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isCancelled</li>
<li>状态控制<ul>
<li>如果只重写main方法，底层控制变更任务执行完成状态，以及任务退出</li>
<li>如果重写了start方法，自行控制任务状态</li>
</ul>
</li>
</ul>
</li>
<li>可以控制最大并发量，通过设置max这个属性来控制最大并发量</li>
</ul>
</li>
<li><p>系统<strong>通过KVO</strong>移除一个isFinished=YES的NSOperation的</p>
</li>
</ul>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><ul>
<li><p>面试中关于NSThread的面试问题，通常是结合RunLoop来考察的</p>
</li>
<li><p>启动流程</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/NSThread启动流程.png" alt="NSThread启动流程"></p>
<p><img src="/2020/04/21/iOS知识点/实现常驻线程功能的实现.png" alt="实现常驻线程功能的实现"></p>
<ul>
<li>NSThead的执行原理<ul>
<li>内部创建了一个pthread线程，当main函数或指定的target的selector方法执行结束之后，系统会进行线程的退出管理操作，如要维护一个常驻线程，需要在NSThead所对应的selector方法中去维护一个RunLoop事件循环</li>
</ul>
</li>
</ul>
<h3 id="多线程与锁"><a href="#多线程与锁" class="headerlink" title="多线程与锁"></a>多线程与锁</h3><ul>
<li>iOS当中都有哪些锁<ul>
<li>@synchronized<ul>
<li>一般在创建单例对象的时候使用</li>
</ul>
</li>
<li>atomic<ul>
<li>修饰属性的关键字</li>
<li>对被修饰对象进行原子操作(不负责使用，即赋值时保证线程安全，使用时不保证线程安全，如，可变数组的使用)</li>
</ul>
</li>
<li>OSSpinLock<ul>
<li>自旋锁</li>
<li><strong>循环等待询问</strong>，不释放当前资源</li>
<li>用于轻量级数据访问，简单的int值 +1/-1 操作</li>
</ul>
</li>
<li>NSRecursiveLock<ul>
<li>递归锁</li>
<li>可以重入(递归锁的特点)</li>
</ul>
</li>
<li>NSLock<ul>
<li>开发中常使用的锁</li>
<li>保证线程互斥进入临界区</li>
</ul>
</li>
<li>dispatch_semaphore_t<ul>
<li>信号量</li>
<li>相关操作方法<ul>
<li>dispatch_semaphore_create()</li>
<li>dispatch_semaphore_wait()(阻塞行为是主动行为)</li>
<li>dispatch_semaphore_signal()(唤醒是被动行为)</li>
</ul>
</li>
</ul>
</li>
<li>不同锁对应不同的使用场景</li>
</ul>
</li>
</ul>
<hr>
<h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>RunLoop是通过内部维护的<strong>事件循环</strong>来对<strong>事件/消息进行管理</strong>的一个对象</p>
<ul>
<li>状态的切换(用户态<-->内核态)是解释什么是RunLoop的关键点</--></li>
</ul>
</li>
<li><p>事件循环</p>
<ul>
<li>没有消息需要处理时，休眠以避免资源占用<ul>
<li>线程的状态切换：当没有消息要处理时，线程由<strong>用户态</strong>通过系统调用进入<strong>内核态</strong></li>
</ul>
</li>
<li><p>有消息需要处理时，立刻被唤醒</p>
<ul>
<li>线程的状态切换：由<strong>内核态</strong>转变为<strong>用户态</strong></li>
</ul>
</li>
<li><p>用户态、内核态</p>
<ul>
<li>应用程序通常运行在用户态，用户态面向用户的操作交互；相对于用户态而言是内核态，内核态是针对系统级别的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>main函数为什么一直保持运行的状态而不会终止退出</p>
<ul>
<li>因为在main函数体内会调用UIApplicationMain()这个函数，在这个函数内部会启动一个主线程的运行循环(RunLoop)</li>
<li>RunLoop是对事件循环的一种维护机制</li>
<li>RunLoop的特点<ul>
<li>接收消息</li>
<li>处理</li>
<li>等待(不等于死循环)(线程休眠)</li>
<li>期间会发生用户态到内核态的相互切换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>NSRunLoop是CFRunLoop的封装，提供了面向对象的API</p>
<ul>
<li><p>RunLoop涉及的三个主要数据结构</p>
<ul>
<li>CFRunLoop<ul>
<li>pthread(可知，线程与RunLoop是一一对应的关系)</li>
<li>currentMode</li>
<li>modes</li>
<li>commonModes</li>
<li>commonModeItems</li>
</ul>
</li>
<li>CFRunLoopMode<ul>
<li>name</li>
<li>sources0</li>
<li>sources1</li>
<li>observers</li>
<li>timers</li>
</ul>
</li>
<li>Source/Timer/Observer<ul>
<li>CFRunLoopSource<ul>
<li>source0<ul>
<li>需要手动唤醒线程</li>
</ul>
</li>
<li>source1<ul>
<li>具备唤醒线程的能力</li>
</ul>
</li>
</ul>
</li>
<li>CFRunLoopTimer<ul>
<li>基于事件的定时器，和NSTimer是toll-free bridged(免费桥转换)的</li>
</ul>
</li>
<li>CFRunLoopObserver<ul>
<li>观测时间点<ul>
<li>kCFRunLoopEntry</li>
<li>kCFRunLoopBeforeTimers</li>
<li>kCFRunLoopBeforeSources</li>
<li>kCFRunLoopBeforeWaiting(RunLoop将从用户态切到内核态)</li>
<li>kCFRunLoopAfterWaiting</li>
<li>kCFRunLoopExit</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>各数据结构之间的关系</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RunLoop各数据结构之间的关系.png" alt="RunLoop各数据结构之间的关系"></p>
</li>
<li><p>RunLoop的Mode</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RunLoop的Mode.png" alt="RunLoop的Mode"></p>
<ul>
<li>CommonMode的特殊性<ul>
<li>NS中对应的是NSRunLoopCommonModes</li>
<li>CommonMode不是实际存在的一种Mode</li>
<li>是同步Source/Timer/Observer到多个Mode中的一种技术方案</li>
</ul>
</li>
</ul>
<h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p><strong>重听9-3</strong></p>
<ul>
<li>RunLoop事件循环机制流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RunLoop事件循环机制流程.png" alt="RunLoop事件循环机制流程"></p>
<ul>
<li>RunLoop的核心</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RunLoop的核心.png" alt="RunLoop的核心"></p>
<h3 id="RunLoop与NSTimer"><a href="#RunLoop与NSTimer" class="headerlink" title="RunLoop与NSTimer"></a>RunLoop与NSTimer</h3><ul>
<li>如何把一个timer同步到多个mode上面<ul>
<li>通过CFRunLoopAddTimer函数，给timer打上commonMode标签，将Timer添加到多个mode中</li>
</ul>
</li>
</ul>
<h3 id="RunLoop与多线程"><a href="#RunLoop与多线程" class="headerlink" title="RunLoop与多线程"></a>RunLoop与多线程</h3><ul>
<li>线程是和RunLoop一一对应的</li>
<li>自己创建的线程默认是没有RunLoop的，需要自己手动创建RunLoop<ul>
<li>使用场景(怎样实现一个常驻线程)，过程如下<ul>
<li>为当前线程开启一个RunLoop(调用currentRunLoop，该函数会去当前线程查找RunLoop，如果没有RunLoop，会为当前线程创建一个RunLoop)</li>
<li>向该RunLoop中添加一个Port/Source等维持RunLoop的事件循环</li>
<li>启动该RunLoop(调用run方法)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li><p>超文本传输协议</p>
</li>
<li><p>从以下方面理解HTTP</p>
<ul>
<li><p>请求/响应报文</p>
<ul>
<li>请求报文</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/请求报文.png" alt="请求报文"></p>
<ul>
<li>响应报文</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/响应报文.png" alt="响应报文"></p>
<ul>
<li><p>请求方式</p>
<ul>
<li>get、post、head、put、delete、options</li>
</ul>
</li>
<li><p>get和post的区别</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/get_post的区别.png" alt="get_post的区别"></p>
<ul>
<li>安全性：不应该引起Server端的任何状态变化(get/head/options)</li>
<li>幂等性：同一个请求方法执行多次和执行一次的效果完全相同(get/put/delete)</li>
<li>可缓存性：请求是否可以被缓存(get/head)</li>
</ul>
<ul>
<li>状态码<ul>
<li>1xx、2xx、3xx、4xx、5xx</li>
</ul>
</li>
</ul>
</li>
<li><p>连接建立流程</p>
<ul>
<li>HTTP的连接建立，涉及TCP的三次握手(三次握手中，通过第三次的ACK报文来确立是否建立连接，用于回答为何不采用两次握手)，四次挥手</li>
</ul>
</li>
<li>HTTP的特点<ul>
<li>无连接<ul>
<li>可以通过HTTP的<strong>持久连接</strong>方案来补偿无连接的问题</li>
</ul>
</li>
<li>无状态<ul>
<li>可以通过<strong>Cookie/Session</strong>来补偿无状态的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>持久连接</p>
<ul>
<li>涉及的头部字段<ul>
<li>Connection: keep-alive(指明是否持久连接)</li>
<li>time: 20(指定持续有效的时间段)</li>
<li>max: 10(指定可发送HTTP请求和响应的最大量)</li>
</ul>
</li>
<li>如何判断一个请求是否结束的方案<ul>
<li>Content-length: 1024(依据服务端返回的该字段值，对客户端所接收的数据进行判断，如客户端所接收的数据大小等于服务端返回的该字段值的大小，则本次请求结束)</li>
<li>chunked，最后会有一个空的chunked(post请求情况下，当服务端返回的报文中，chunked为空，则本次请求结束)</li>
</ul>
</li>
</ul>
</li>
<li><p>Charles抓包原理：中间人攻击</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/中间人攻击.png" alt="中间人攻击"></p>
<h3 id="HTTPS协议与网络安全"><a href="#HTTPS协议与网络安全" class="headerlink" title="HTTPS协议与网络安全"></a>HTTPS协议与网络安全</h3><ul>
<li><p>HTTP与HTTPS的区别</p>
<ul>
<li>HTTPS = HTTP + SSL/TLS</li>
<li>协议栈</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/HTTPS协议栈.png" alt="HTTPS协议栈"></p>
</li>
<li><p>HTTPS建立连接流程</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/HTTPS建立连接流程.png" alt="HTTPS建立连接流程"></p>
<ul>
<li><p>HTTPS采用的加密手段</p>
<ul>
<li>连接建立过程使用非对称加密，非对称加密很耗时</li>
<li>后续通信过程使用对称加密</li>
<li>非对称加密(安全性高)</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/非对称加密.png" alt="非对称加密"></p>
<ul>
<li>对称加密</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/对称加密.png" alt="对称加密"></p>
</li>
</ul>
<h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h3><p><strong>重听10-4、10-5</strong></p>
<ul>
<li>UDP特点<ul>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>面向报文<ul>
<li>既不合并，也不拆分</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP功能</p>
<ul>
<li>复用</li>
<li>分用</li>
<li>差错检测</li>
</ul>
</li>
<li><p>TCP特点</p>
<ul>
<li>面向连接<ul>
<li>三次握手</li>
<li>四次挥手</li>
</ul>
</li>
<li>可靠传输<ul>
<li>无差错</li>
<li>不丢失</li>
<li>不重复</li>
<li>按序到达</li>
<li>使用停止等待协议：无差错情况、超时重传、确认丢失、确认迟到</li>
</ul>
</li>
<li>面向字节流<ul>
<li>TCP连接是一个逻辑通道</li>
</ul>
</li>
<li><p>流量控制</p>
<ul>
<li><p>基于滑动窗口协议来实现的(按序到达)</p>
<p><img src="/2020/04/21/iOS知识点/滑动窗口协议过程.png" alt="滑动窗口协议过程"></p>
</li>
</ul>
</li>
<li><p>拥塞控制</p>
<ul>
<li>慢开始、拥塞避免</li>
<li>快恢复、快重传</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul>
<li><p>对DNS的了解</p>
<ul>
<li>域名到IP地址的映射，DNS解析请求采用UDP数据报，且明文</li>
</ul>
</li>
<li><p>DNS查询方式</p>
<ul>
<li>递归查询</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/DNS递归查询.png" alt="DNS递归查询"></p>
<ul>
<li>迭代查询</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/DNS迭代查询.png" alt="DNS迭代查询"></p>
</li>
<li><p>DNS解析存在的问题</p>
<ul>
<li>DNS劫持问题</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/DNS劫持.png" alt="DNS劫持"></p>
<ul>
<li>DNS解析转发问题</li>
</ul>
</li>
<li><p>DNS劫持与HTTP的关系是怎样的</p>
<ul>
<li>DNS劫持与HTTP没有关系，因DNS解析发生在HTTP建立连接之前</li>
<li>DNS解析请求使用UDP数据报，端口号53</li>
</ul>
</li>
<li><p>怎样解决DNS劫持</p>
<ul>
<li>httpDNS方案</li>
</ul>
<p><img src="iOS知识点/httpDNS实现理论.png" alt="httpDNS实现理论"></p>
<ul>
<li>长连接方案</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/DNS长连接方案.png" alt="DNS长连接方案"></p>
</li>
</ul>
<h3 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h3><ul>
<li><p>是对HTTP协议无状态特点的补偿</p>
</li>
<li><p>Cookie主要用来记录用户状态，区分用户；状态保存在客户端</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/Cookie流程.png" alt="Cookie流程"></p>
<p>客户端发送的cookie在http请求报文的Cookie首部字段中</p>
<p>服务器端设置http响应报文的Set-Cookie首部字段</p>
<ul>
<li><p>怎样修改Cookie</p>
<ul>
<li>新cookie覆盖旧cookie</li>
<li>覆盖规则：name、path、domain等需要与原cookie一致</li>
</ul>
</li>
<li><p>怎样删除Cookie</p>
<ul>
<li>新cookie覆盖旧cookie</li>
<li>覆盖规则：name、path、domain等需要与原cookie一致</li>
<li>设置cookie的expires=过去的一个时间点，或者maxAge=0(设置cookie失效)</li>
</ul>
</li>
<li><p>Session也是用来记录用户状态，区分用户；状态存放在服务器端</p>
</li>
<li><p>Session和Cookie的关系是怎样的</p>
<ul>
<li>Session需要依赖于Cookie机制</li>
<li>Session工作流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/Session工作流程.png" alt="Session工作流程"></p>
</li>
</ul>
<hr>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h3><p><img src="/2020/04/21/iOS知识点/六大设计原则.png" alt="六大设计原则"></p>
<ul>
<li>单一职责原则<ul>
<li>一个类只负责一件事，如CALayer和UIView</li>
</ul>
</li>
<li>开闭原则<ul>
<li>对修改关闭，对扩展开放</li>
</ul>
</li>
<li>接口隔离原则<ul>
<li>使用多个专门的协议，而不是一个庞大臃肿的协议，如UITableView</li>
<li>协议中的方法也尽量少</li>
</ul>
</li>
<li>依赖倒置原则<ul>
<li>抽象不应该依赖于具体实现，具体实现可以依赖于抽象</li>
</ul>
</li>
<li>里氏替换原则<ul>
<li>父类可以被子类无缝替换，且原有功能不受任何影响，如KVO</li>
</ul>
</li>
<li>迪米特法则<ul>
<li>一个对象应当对其他对象有尽可能少的了解</li>
<li>高内聚、低耦合</li>
</ul>
</li>
</ul>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><ul>
<li>类构成</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/责任链类构成.png" alt="责任链类构成"></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><ul>
<li>类构成</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/桥接类构成.png" alt="桥接类构成"></p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul>
<li><p>对象适配器</p>
<ul>
<li>类构成</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/对象适配器类构成.png" alt="对象适配器类构成"></p>
<p><img src="/2020/04/21/iOS知识点/对象适配器的逻辑实现.png" alt="对象适配器的逻辑实现"></p>
</li>
<li><p>类适配器</p>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例实现代码</p>
<p><img src="/2020/04/21/iOS知识点/单例实现代码.png" alt="单例实现代码"></p>
<ul>
<li>注意super的调用</li>
<li>要重写allocWithZone:和copyWithZone:</li>
</ul>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul>
<li>对行为进行参数化的设计模式，如微博。以降低代码重合度</li>
</ul>
<h2 id="重听11-6"><a href="#重听11-6" class="headerlink" title="重听11-6"></a><strong>重听11-6</strong></h2><h2 id="架构-框架"><a href="#架构-框架" class="headerlink" title="架构/框架"></a>架构/框架</h2><ul>
<li>引入架构&amp;框架，主要实现模块化，将各个功能按模块划分，作一个相应的分层，目的是为了解耦，最终实现降低代码重合度的效果</li>
</ul>
<h3 id="图片缓存框架"><a href="#图片缓存框架" class="headerlink" title="图片缓存框架"></a>图片缓存框架</h3><ul>
<li>怎样设计一个图片缓存框架</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/图片缓存框架.png" alt="图片缓存框架"></p>
<ul>
<li><p>图片通过什么方式进行读写</p>
<ul>
<li>以图片URL的单向Hash值作为Key</li>
<li>读取的过程如下</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/框架中图片的读取过程.png" alt="框架中图片的读取过程"></p>
<p>引入内存模块，是从多级缓存角度考虑的</p>
</li>
<li><p>内存的设计上需要考虑的问题</p>
<ul>
<li><p>存储的Size(从内存资源稀缺性的角度出发)</p>
<ul>
<li><p>存储的数据结构(从大小、使用频度上考虑)，队列方式存储(FIFO)</p>
<p><img src="/2020/04/21/iOS知识点/存储的Size.png" alt="存储的Size"></p>
</li>
</ul>
</li>
<li><p>淘汰的策略</p>
<ul>
<li>淘汰，因为内存Size大小有限</li>
<li>淘汰的策略依托于存储Size的设计方案的</li>
<li>方案<ul>
<li>以队列先进先出的方式淘汰</li>
<li>LRU算法(最近最久未使用算法)(如30分钟之内是否使用过)。可以通过<strong>定时检查(损耗性能)</strong>方式(思路，落地性不强)，也可通过<strong>提高检查触发频率(即每次触发时，对所有图片的未使用时长进行检查)(触发方式：每次进行读写时、前后台切换时)</strong>的方式。使用LRU算法时，注意开销问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘设计需要考虑的问题</p>
<ul>
<li>需要考虑磁盘空间大，但读取效率低的特点</li>
<li>存储方式的选择</li>
<li>大小限制(如100MB)</li>
<li>淘汰策略(如某一图片存储时间距今已超过7天)</li>
</ul>
</li>
<li><p>网络部分的设计需要考虑的问题</p>
<ul>
<li>图片请求的最大并发量</li>
<li>请求的超时策略(重试，如最多重试两次)</li>
<li>请求优先级</li>
</ul>
</li>
<li><p>图片解码</p>
<ul>
<li>对不同格式的图片，解码采用的方式<ul>
<li>应用策略模式对不同图片格式进行解码</li>
</ul>
</li>
<li>在哪个阶段做图片解码处理<ul>
<li>磁盘读取之后(从磁盘读取未解码，解码后再放入内存，以此减轻视图渲染时因图片解码所带来的压力)</li>
<li>网络请求返回后</li>
</ul>
</li>
</ul>
</li>
<li><p>线程处理</p>
<ul>
<li>图片缓存框架整体流程中，线程的处理过程如下时序图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/图片框架中线程处理时序流程图.png" alt="图片框架中线程处理时序流程图"></p>
</li>
</ul>
<h3 id="阅读时长统计"><a href="#阅读时长统计" class="headerlink" title="阅读时长统计"></a>阅读时长统计</h3><ul>
<li>时长统计的框架</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/时长统计的框架.png" alt="时长统计的框架"></p>
<p>页面式：push开始、pop结束<br>自定义式：体现在设计框架时，对扩展性的考虑<br>磁盘存储：防止异常情况下(程序杀死、设备断电)记录数据的丢失</p>
<ul>
<li><p>记录器</p>
<ul>
<li>为何有不同的记录器<ul>
<li>基于不同分类场景提供的关于记录的封装、适配</li>
</ul>
</li>
</ul>
</li>
<li><p>如何降低记录数据的丢失率</p>
<ul>
<li>定时写磁盘(如每隔一段时间就做磁盘的写入)</li>
<li>限定内存缓存的条数(如10条)，超过该条数，即写磁盘</li>
</ul>
</li>
<li><p>延时上传的场景</p>
<ul>
<li>从节约客户端流量和提高性能的角度考虑，不是每产生一条记录就上传</li>
<li>采用延时上传的策略来进行批量上传(如，产生一定量(每50条)或过一定时间(每隔10分钟)进行上传)</li>
<li>触发延时上传的场景<ul>
<li>前后台切换</li>
<li>从无网到有网的变化</li>
<li>通用轻量接口捎带</li>
</ul>
</li>
</ul>
</li>
<li><p>上传时机的把控</p>
<ul>
<li>立刻上传</li>
<li>延时上传</li>
<li>定时上传</li>
</ul>
</li>
</ul>
<h3 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h3><p>以微博APP正文页为例</p>
<ul>
<li>整体架构</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/微博整体架构.png" alt="微博整体架构"></p>
<p><img src="/2020/04/21/iOS知识点/微博整体架构视图层.png" alt="微博整体架构视图层"></p>
<p><img src="/2020/04/21/iOS知识点/微博整体架构业务逻辑层.png" alt="微博整体架构业务逻辑层"></p>
<p><img src="/2020/04/21/iOS知识点/微博整体架构数据层.png" alt="微博整体架构数据层"></p>
<ul>
<li>数据流</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/微博整体架构数据流.png" alt="微博整体架构数据流"></p>
<p><img src="/2020/04/21/iOS知识点/微博整体架构数据间关系.png" alt="微博整体架构数据间关系"></p>
<ul>
<li>反向更新</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/微博整体架构反向更新.png" alt="微博整体架构反向更新"></p>
<ul>
<li><p>总结</p>
<ul>
<li>涉及的思想</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/微博整体架构涉及的思想.png" alt="微博整体架构涉及的思想"></p>
<ul>
<li>MVVM结构图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/MVVM结构图.png" alt="MVVM结构图"></p>
<ul>
<li>RN数据流思想</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RN数据流思想.png" alt="RN数据流思想"></p>
<p>任何一个子节点，是没有权利做自己的变化更新的，它必须要把这种变化更新的消息传递给根节点，然后由根节点自顶向下的方式去询问需要更新的节点(从一个主动行为变成一个被动行为)</p>
</li>
</ul>
<h3 id="客户端整体架构"><a href="#客户端整体架构" class="headerlink" title="客户端整体架构"></a>客户端整体架构</h3><ul>
<li>客户端整体架构结构图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/客户端整体架构.png" alt="客户端整体架构"></p>
<p>独立的通用层构成有：时长统计框架、崩溃统计框架、网络第三方框架<br>通用业务层：如控件的封装<br>中间层：用于协调各业务的交互，及处理各业务的解耦</p>
<ul>
<li><p>业务之间的解耦通信方式</p>
<ul>
<li>OpenURL(Router方式)</li>
<li>依赖注入(TOONRouter???)</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/依赖注入.png" alt="依赖注入"></p>
</li>
</ul>
<p>整体架构设计的原则：上层可以依赖下层，下层不可以依赖上层</p>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="字符串反转算法"><a href="#字符串反转算法" class="headerlink" title="字符串反转算法"></a>字符串反转算法</h3><ul>
<li>字符串反转</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/字符串反转.png" alt="字符串反转"></p>
<h3 id="链表反转算法"><a href="#链表反转算法" class="headerlink" title="链表反转算法"></a>链表反转算法</h3><ul>
<li><p>链表反转</p>
<ul>
<li>头插法，关键点是哨兵指针先移动，再执行节点的赋值移除操作</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/链表反转.png" alt="链表反转"></p>
</li>
</ul>
<h3 id="有序数组合并算法"><a href="#有序数组合并算法" class="headerlink" title="有序数组合并算法"></a>有序数组合并算法</h3><p><img src="/2020/04/21/iOS知识点/有序数组合并.png" alt="有序数组合并"></p>
<p><img src="/2020/04/21/iOS知识点/有序数组合并有剩余数组.png" alt="有序数组合并有剩余数组"></p>
<h3 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h3><p>13-4</p>
<ul>
<li>示例：用hash算法实现，找出给定字符串中第一个只出现一次的字符</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/hash算法.png" alt="hash算法"></p>
<h3 id="查找两个子视图的共同父视图算法"><a href="#查找两个子视图的共同父视图算法" class="headerlink" title="查找两个子视图的共同父视图算法"></a>查找两个子视图的共同父视图算法</h3><p>13-5</p>
<h3 id="求无序数组当中的中位数的算法"><a href="#求无序数组当中的中位数的算法" class="headerlink" title="求无序数组当中的中位数的算法"></a>求无序数组当中的中位数的算法</h3><hr>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="AFN"><a href="#AFN" class="headerlink" title="AFN"></a>AFN</h3><p>14-1</p>
<ul>
<li>框架图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/AFN框架图.png" alt="AFN框架图"></p>
<ul>
<li>主要类关系图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/主要类关系图.png" alt="主要类关系图"></p>
<ul>
<li>AFURLSessionManager主要功能<ul>
<li>创建和管理NSURLSession、NSURLSessionTask</li>
<li>实现NSURLSessionDelegate等协议的代理方法</li>
<li>引入AFSecurityPolicy保证请求安全</li>
<li>引入AFNetworkReachabilityManager监控网络状态</li>
</ul>
</li>
</ul>
<h3 id="SDWeb"><a href="#SDWeb" class="headerlink" title="SDWeb"></a>SDWeb</h3><ul>
<li>框架图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/SDWeb架构简图.png" alt="SDWeb架构简图"></p>
<ul>
<li>加载图片的流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/SDWeb加载图片流程.png" alt="SDWeb加载图片流程"></p>
<h3 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h3><ul>
<li><p>是函数响应式的编程框架</p>
</li>
<li><p>重要概念</p>
<ul>
<li>信号</li>
<li>订阅(订阅一个信号)</li>
</ul>
</li>
<li><p>信号</p>
<ul>
<li>ReactiveCocoa中的核心类RACSignal</li>
<li>RACSignal结构图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RACSignal结构图.png" alt="RACSignal结构图"></p>
<ul>
<li>信号是代表一连串的状态。在状态改变时，对应的订阅者RACSubscriber就会收到通知执行相应的指令</li>
</ul>
</li>
<li><p>订阅</p>
<ul>
<li>订阅信号的工作逻辑</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/订阅信号的工作逻辑.png" alt="订阅信号的工作逻辑"></p>
<ul>
<li>订阅内部原理</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/订阅内部原理.png" alt="订阅内部原理"></p>
</li>
</ul>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><ul>
<li>是一个提升iOS界面渲染性能的一个框架</li>
<li><p>主要用来减轻主线程的压力，能在子线程执行的操作就在子线程中执行</p>
</li>
<li><p>主要处理的问题</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/ASDK主要处理的问题.png" alt="ASDK主要处理的问题"></p>
<ul>
<li>基本原理</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/ASDK基本原理.png" alt="ASDK基本原理"></p>
<ul>
<li>封装了一个ASNode</li>
<li>针对ASNode的修改和提交，会对其进行封装并提交到一个全局容器当中</li>
<li>ASDK也在RunLoop中注册了一个Observer</li>
<li>当RunLoop进入休眠前，ASDK执行该loop内提交的所有任务</li>
</ul>
<hr>
<h3 id="iOS中使用的多线程"><a href="#iOS中使用的多线程" class="headerlink" title="iOS中使用的多线程"></a>iOS中使用的多线程</h3><h5 id="GCD-1"><a href="#GCD-1" class="headerlink" title="GCD"></a>GCD</h5><ul>
<li>同步/异步、串行/并发<ul>
<li>死锁原因：队列引起的循环等待。例子：viewDidLoad和Block。在主队列(串行队列)中分派viewDidLoad到主线程去执行，viewDidLoad在执行的过程中会调用Block去执行任务，viewDidLoad继续执行的前提条件是Block执行完毕后继续执行viewDidLoad，Block上的任务要想执行，依赖主队列(串行队列)的性质(先进先出FIFO)，此时Block想要执行，依赖viewDidLoad的完成，这种情况下就产生了viewDidLoad和Block的相互等待，造成了队列的循环等待，产生死锁。</li>
<li>主队列当中提交的任务(无论是同步或是异步)，最终都要在主线程中进行处理和执行</li>
<li>同步提交意味着在当前线程执行</li>
<li>任务添加到队列中，分析任务的执行顺序时，要考虑队列的性质，如FIFO</li>
<li>只要是以同步方式去提交任务，无论是提交到并发队列还是串行队列，最终都是在当前线程去执行</li>
<li>全局队列(global_queue)，是并发队列</li>
</ul>
</li>
<li>dispatch_barrier_async，用于解决多读单写，系统层方面的一个解决方案</li>
<li>dispatch_group，</li>
</ul>
<h5 id="NSOperation-1"><a href="#NSOperation-1" class="headerlink" title="NSOperation"></a>NSOperation</h5><p>NSOperation常用于第三方库的对线程编程，如AFNetwork</p>
<h5 id="NSThread-1"><a href="#NSThread-1" class="headerlink" title="NSThread"></a>NSThread</h5><p>实现常驻线程的时候，会用到NSThread</p>
<hr>
<p>线程同步，资源共享，会涉及到多线程与锁</p>
<h5 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h5><p>KVO：isa 混写技术的实现<br>MVVM + RAC<br>RN</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/14/组件化/" rel="prev" title="组件化">
      <i class="fa fa-chevron-left"></i> 组件化
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/10/新电脑常用软件工具的安装配置/" rel="next" title="新电脑常用软件工具的安装配置">
      新电脑常用软件工具的安装配置 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#UI视图"><span class="nav-number">1.</span> <span class="nav-text">UI视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UITableView"><span class="nav-number">1.1.</span> <span class="nav-text">UITableView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件传递-amp-视图响应"><span class="nav-number">1.2.</span> <span class="nav-text">事件传递&amp;视图响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图像显示原理"><span class="nav-number">1.3.</span> <span class="nav-text">图像显示原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卡顿-amp-掉帧"><span class="nav-number">1.4.</span> <span class="nav-text">卡顿&amp;掉帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绘制原理-amp-异步绘制"><span class="nav-number">1.5.</span> <span class="nav-text">绘制原理&amp;异步绘制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离屏渲染"><span class="nav-number">1.6.</span> <span class="nav-text">离屏渲染</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OC语言特性"><span class="nav-number">2.</span> <span class="nav-text">OC语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">2.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联对象"><span class="nav-number">2.2.</span> <span class="nav-text">关联对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展"><span class="nav-number">2.3.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理"><span class="nav-number">2.4.</span> <span class="nav-text">代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通知"><span class="nav-number">2.5.</span> <span class="nav-text">通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVO"><span class="nav-number">2.6.</span> <span class="nav-text">KVO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVC"><span class="nav-number">2.7.</span> <span class="nav-text">KVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性关键字"><span class="nav-number">2.8.</span> <span class="nav-text">属性关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunTime"><span class="nav-number">3.</span> <span class="nav-text">RunTime</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试点"><span class="nav-number">3.1.</span> <span class="nav-text">面试点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">3.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类对象、元类对象-amp-消息传递"><span class="nav-number">3.3.</span> <span class="nav-text">类对象、元类对象&amp;消息传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法缓存"><span class="nav-number">3.4.</span> <span class="nav-text">方法缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息转发"><span class="nav-number">3.5.</span> <span class="nav-text">消息转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-Swizzling"><span class="nav-number">3.6.</span> <span class="nav-text">Method-Swizzling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态添加方法"><span class="nav-number">3.7.</span> <span class="nav-text">动态添加方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态方法解析"><span class="nav-number">3.8.</span> <span class="nav-text">动态方法解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">4.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存布局"><span class="nav-number">4.1.</span> <span class="nav-text">内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理方案"><span class="nav-number">4.2.</span> <span class="nav-text">内存管理方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NONPOINTER-ISA"><span class="nav-number">4.2.1.</span> <span class="nav-text">NONPOINTER_ISA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#散列表方式"><span class="nav-number">4.2.2.</span> <span class="nav-text">散列表方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-1"><span class="nav-number">4.3.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MRC-amp-ARC"><span class="nav-number">4.4.</span> <span class="nav-text">MRC&amp;ARC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MRC环境下"><span class="nav-number">4.4.1.</span> <span class="nav-text">MRC环境下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARC"><span class="nav-number">4.4.2.</span> <span class="nav-text">ARC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数管理"><span class="nav-number">4.5.</span> <span class="nav-text">引用计数管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#弱引用管理"><span class="nav-number">4.6.</span> <span class="nav-text">弱引用管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动释放池"><span class="nav-number">4.7.</span> <span class="nav-text">自动释放池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环引用"><span class="nav-number">4.8.</span> <span class="nav-text">循环引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Block"><span class="nav-number">5.</span> <span class="nav-text">Block</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本质-什么是block"><span class="nav-number">5.1.</span> <span class="nav-text">本质(什么是block)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#截获变量"><span class="nav-number">5.2.</span> <span class="nav-text">截获变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#block修饰符"><span class="nav-number">5.3.</span> <span class="nav-text">__block修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block的内存管理"><span class="nav-number">5.4.</span> <span class="nav-text">Block的内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环引用-1"><span class="nav-number">5.5.</span> <span class="nav-text">循环引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">6.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD"><span class="nav-number">6.1.</span> <span class="nav-text">GCD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-barrier-async"><span class="nav-number">6.2.</span> <span class="nav-text">dispatch_barrier_async()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-group-async"><span class="nav-number">6.3.</span> <span class="nav-text">dispatch_group_async()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSOperation"><span class="nav-number">6.4.</span> <span class="nav-text">NSOperation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSThread"><span class="nav-number">6.5.</span> <span class="nav-text">NSThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程与锁"><span class="nav-number">6.6.</span> <span class="nav-text">多线程与锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop"><span class="nav-number">7.</span> <span class="nav-text">RunLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">7.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-2"><span class="nav-number">7.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件循环机制"><span class="nav-number">7.3.</span> <span class="nav-text">事件循环机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop与NSTimer"><span class="nav-number">7.4.</span> <span class="nav-text">RunLoop与NSTimer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop与多线程"><span class="nav-number">7.5.</span> <span class="nav-text">RunLoop与多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络"><span class="nav-number">8.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP协议"><span class="nav-number">8.1.</span> <span class="nav-text">HTTP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS协议与网络安全"><span class="nav-number">8.2.</span> <span class="nav-text">HTTPS协议与网络安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP与UDP"><span class="nav-number">8.3.</span> <span class="nav-text">TCP与UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS"><span class="nav-number">8.4.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session与Cookie"><span class="nav-number">8.5.</span> <span class="nav-text">Session与Cookie</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式"><span class="nav-number">9.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#六大设计原则"><span class="nav-number">9.1.</span> <span class="nav-text">六大设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#责任链模式"><span class="nav-number">9.2.</span> <span class="nav-text">责任链模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桥接模式"><span class="nav-number">9.3.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适配器模式"><span class="nav-number">9.4.</span> <span class="nav-text">适配器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式"><span class="nav-number">9.5.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令模式"><span class="nav-number">9.6.</span> <span class="nav-text">命令模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重听11-6"><span class="nav-number">10.</span> <span class="nav-text">重听11-6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构-框架"><span class="nav-number">11.</span> <span class="nav-text">架构/框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图片缓存框架"><span class="nav-number">11.1.</span> <span class="nav-text">图片缓存框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阅读时长统计"><span class="nav-number">11.2.</span> <span class="nav-text">阅读时长统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂页面架构"><span class="nav-number">11.3.</span> <span class="nav-text">复杂页面架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端整体架构"><span class="nav-number">11.4.</span> <span class="nav-text">客户端整体架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-number">12.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串反转算法"><span class="nav-number">12.1.</span> <span class="nav-text">字符串反转算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表反转算法"><span class="nav-number">12.2.</span> <span class="nav-text">链表反转算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序数组合并算法"><span class="nav-number">12.3.</span> <span class="nav-text">有序数组合并算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash算法"><span class="nav-number">12.4.</span> <span class="nav-text">Hash算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找两个子视图的共同父视图算法"><span class="nav-number">12.5.</span> <span class="nav-text">查找两个子视图的共同父视图算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求无序数组当中的中位数的算法"><span class="nav-number">12.6.</span> <span class="nav-text">求无序数组当中的中位数的算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三方库"><span class="nav-number">13.</span> <span class="nav-text">第三方库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFN"><span class="nav-number">13.1.</span> <span class="nav-text">AFN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDWeb"><span class="nav-number">13.2.</span> <span class="nav-text">SDWeb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReactiveCocoa"><span class="nav-number">13.3.</span> <span class="nav-text">ReactiveCocoa</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncDisplayKit"><span class="nav-number">13.4.</span> <span class="nav-text">AsyncDisplayKit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS中使用的多线程"><span class="nav-number">13.5.</span> <span class="nav-text">iOS中使用的多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GCD-1"><span class="nav-number">13.5.0.1.</span> <span class="nav-text">GCD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NSOperation-1"><span class="nav-number">13.5.0.2.</span> <span class="nav-text">NSOperation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NSThread-1"><span class="nav-number">13.5.0.3.</span> <span class="nav-text">NSThread</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#笔记"><span class="nav-number">13.5.0.4.</span> <span class="nav-text">笔记</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
