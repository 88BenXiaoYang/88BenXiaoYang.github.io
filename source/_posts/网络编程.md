---
title: 网络编程
date: 2019-06-18 10:46:25
tags:
---

### 什么是网络编程

##### 概述

网络编程就是如何在**程序中实现**两台计算机的通信。网络通信是两台计算机上的两个进程之间的通信。**网络编程是为了实现网络通信**。网络编程对所有开发语言都是一样的，用不同的开发语言进行网络编程，就是在对应的开发语言开发的**程序本身这个进程内**，连接别的服务器进程的通信端口进行通信。网络通讯中的对象是进程，在网络通讯过程中，通过主机名(或IP地址)和端口号的组合来唯一确定进程。

网络编程最主要的工作就是在发送端把信息通过**规定的协议**进行组装包，在接收端按照规定好的协议把包进行解析，从而提取出对应的信息，达到通信的目的。网络编程过程中，主要的操作是数据包的组装、过滤、捕获、分析。

现在的网络编程基本上是基于**请求/响应方式**的，即一个设备发送请求数据给另外一个设备，然后接收另一个设备的反馈。目前较为流行的网络编程模型是客户端/服务器(C/S)结构。在网络编程中，发起连接请求的程序为客户端`(Client)`，等待其他程序连接的程序为服务器`(Server)`。

##### 网络编程中的两个主要问题

* 如何准确的定位网络上的主机(使用IP协议定位主机)
* 找到主机后如何**可靠高效**的进行数据传输(使用TCP协议进行可靠传输)

##### 实现机制

网络编程，是通过使用**套接字**来达到进程间通信目的的编程，是通过操作相应`API`调度计算机资源硬件，并且利用管道(网线)进行数据交互的过程。

### 编程介绍

##### 网络编程三要素

* `IP`地址：是网络中计算机的唯一标识
  * 使用“点分十进制”法来表示
  * 组成：网络号段+主机号段
     * A类：第一号段为网络号段+后三段的主机号段
         * 网络地址的最高位必须是"0"
         * 有126个网络，每个网络可容纳的主机数16777214
     * B类：前二号段为网络号段+后二段的主机号段
         * 网络地址的最高位必须是"10"
         * 有16384个网络，每个网络可容纳的主机数65534
     * C类：前三号段为网络号段+后一段的主机号段
         * 网络地址的最高位必须是"110"
         * 有209万余个网络，每个网络可容纳的主机数254
  * 两个DOS命令
     * ipconfig/ifconfig：查看本机ip地址
     * ping：ping只是一个对联网环境的检测，并不能解决问题
         * 查看本机网络环境：ping 127.0.0.1(本机回环地址)，连不上网的时候可以ping一下本机回环地址，看是否是自己电脑的问题
         * ping：后面跟ip地址。测试本机与指定的ip地址间的通信是否正常，即查看网络是否有问题
  * 在计算机中，IP地址是分配给网卡的，每个网卡有一个唯一的IP地址，如果一个计算机有多个网卡，则该台计算机则拥有多个不同的IP地址，在同一个网络内部，IP地址不能相同
* 端口：用于找到对应的应用。每个应用对应一个端口(逻辑端口)，端口是用来区分应用程序的，即每个运行的应用程序进程有相应的端口号
  * 正在运行的程序的标识
  * 有效端口：0～65535，其中0～1024系统使用或保留端口
  * 物理端口，即是网卡口。通常所说的都是逻辑端口
  * 使用过程中，建议使用系统分配的默认端口，如果更改端口，可能导致其它进程无法启动
  * 端口号是和Socket编程相关的一个概念
* 协议：约定通信的方式(通信的规则)
  * 协议(约定)大于配置，在网络传输中依然适用，网络的传输是健壮、稳定的，得益于基础的协议构成

三要素的作用流程：

```
找到计算机 -> 根据端口找到应用程序 -> 按照协议沟通
```

##### 网络协议

网络协议是一个分层的协议族，即是由一组协议构成，从下往上各自负责各自的功能。协议，是在网络中多个计算节点进行交互、沟通的规定。通过对数据格式的规范化，从而使计算机之间能够彼此明确对方的意图。

网络协议是网络中不同计算机信息通信的语言，为了实现交互，这个语言就需要有一定的格式。

##### 网络模型

* 模型：描述网络的结构原理和工作原理
* 协议：指定层上进行数据交换的规则

* OSI参考模型

层级 | 名称
--- | ---
7 | 应用层
6 | 表示层
5 | 会话层
4 | 传输层
3 | 网络层
2 | 数据链路层
1 | 物理层

* TCP/IP模型

层级 | 名称 | 对应OSI参数模型中的层级 | 使用的协议和服务
--- | --- | --- | ---
4 | 应用层 | 应用层、表示层、会话层 | HTTP、FTTP、Telnet、NTP、DHCP、PING
3 | 传输层 | 传输层 | TCP、UDP
2 | 网络层 | 网络层 | IP、ARP、ICMP、IGMP、DNS
1 | 网络接口层 | 数据链路层、物理层 | Ethernet

###### 基于`TCP/IP模型`理解网络编程

* 网络链路层(网络接口层)

  * 以太网协议
     * 确定了一系列约定，让一股又一股的电流能够传递信息：0或1
     * 规定一组信号组成一个数据包 - 帧
     * 帧由标头和数据两部分组成
         * 标头，包括目的地址、源地址、类型(目的地址和源地址，用MAC地址来标识)，长度固定为18字节
         * 数据，数据包的具体内容，最短为46字节，最长为1500字节，如超出最长值，就必须分割成多个帧进行发送
         
  * MAC地址 
     * MAC地址，即网卡地址，就是数据包的发送地址(源地址)和接收地址(目的地址)
     * 以太网规定，接入网络的所有设备，都必须有网卡接口。数据包必须是从一块网卡，传送到另一块网卡
     * 每一张网卡都有唯一的MAC地址
     * MAC地址长度是48个二进制位，通常用12个十六进制数表示，如：AA:BB:CC:DD:EE:FF。前6个是厂商编号，后6个是该厂商的网卡流水号
     * **有了MAC地址，就可以定位网卡和数据包的路径了(目的地址和源地址)**

  * 类型
     * 两个字节大小
     * 当这两个字节的值小于1518时，就代表其后数据字段的长度
     * 当这两个字节的值大于1518时，则表示该以太网帧中的数据属于哪个上层协议。如，0x800，代表IP数据包；0x806，代表ARP数据包

  * 广播
     * 广播以知道对方的MAC地址路径
     * 通过ARP协议

  * 常用协议
     * ARP协议
         * 地址解析协议(Address Resolution Protocol)
         * 是通过IP地址获取MAC地址的协议 
         * ARP缓存有生命期
         * ARP只能用于IPv4，不能用于IPv6。在IPv6中可以用ICMPv6替代ARP

* 网络层
  * 产生的背景
     * 计算机通过“广播”的方式传递信息，“广播”只局限于发送者所在的子网内(如没有子网设计，在网络上的所有计算机都能收到“广播”的信息，这将是一场灾难)
     * 基于子网的设计，信息发送有两种方式
         * 当发送者和接收者都在同一个子网内，采用“广播”的方式发送信息
         * 当发送者和接收者不在同一个子网内，采用“路由”的方式发送信息
     * 基于上述因素，诞生了“网络层”
  * 作用
     * 引进一套新的地址，用于能够区分不同的计算机是否属于同一个子网络
     * 这套地址叫做“网络地址”，简称“网址”
  * 结果
     * 引入网址后，计算机有了两种地址
         * MAC地址，绑定在网卡上的
         * 网络地址，管理员分配的
     * 两种地址之间没有任何联系，它们只是随机组合在一起
     * 通过网络地址，可以得出计算机所在的子网络
  * 常用协议
     * IP协议
         * IP是Internet Protocol（网络之间互连的协议）的缩写
         * 是能使连接到网上的所有计算机网络实现相互通信的一套规则
         * 用来规定网络地址的协议
             * IPv4，32个二进制组成，32位
             * IPv6，128位
         * 首部主要包括总长度、源地址、目的地址等信息
         * 数据部分是IP数据包的具体内容
         * 以太网数据包的数据部分就是整个IP数据
         * IP数据包的“标头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。因此，理论上，一个IP数据包的“数据”部分，最长为65515字节
         * 如果IP数据包超过了1500字节，需要将IP数据包分割成几个以太网数据包，分开发送了
         * IP协议常与ARP协议搭配使用
         * 子网掩码
             * 子网编址：IP地址 = 网络号 + 子网号 + 主机号
             * 其中值为1的比特留给网络号和子网号，为0的比特留给主机号，给定IP地址和子网掩码以后，主机就可以确定IP数据报的目标地址，根据子网掩码可知道子网号与主机号之间的分界线
             * 也是32位的一个IP地址，它的用途是识别本网络内的计算机。两台不同主机的IP地址同时与子网掩码进行AND运算，如果得出结果相同，则说明这两台计算机处于同一个子网内，可以进行直接通信
       
* 传输层
  * 端口
     * 是每一个使用网卡的程序的编号
     * 用以表示数据包到底供哪个程序(进程)使用
  * 传输层的功能，就是建立“端口到端口”的通信。相比之下，网络层是建立“主机到主机”的通信
  * 常用协议
     * TCP协议
         * TCP数据包的数据格式
             * 包含了首部和数据部分，在TCP协议的控制逻辑中，首部起着最为关键的作用。它是TCP协议中诸如建立连接、断开连接、重传和错误校验等各种特性的基础
             * 首部最重要的是源端口和目的端口
             * 数据部分就是具体的内容
             * Sequence number(顺序号码)(对应数据包中的seq)、Acknowledge number(确认号码)(对应数据包中的ack)
                 * 序号
                     * 占4个字节，它的范围在0-2^32-1，序号随着通信的进行不断的递增，当达到最大值的时候重新回到0在开始递增
                     * TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号
                     * 整个要传送的字节流的起始号必须在连接建立时设置
                     * 首部中的序列号字段指的是本报文段所发送的数据的第一个字节的序号
                 * 确认号
                     * 占4个字节，是对下一个想要接受的字节的期望，这里隐式确认了对上一个数据包的成功接收
             * TCP标志位(位码)，有6种
                 * SYN(synchronous建立联机)，发起一个新连接
                 * ACK(acknowledgement确认)，确认序号有效
                 * PSH(push传送)
                 * FIN(finish结束)，释放一个连接
                 * RST(reset重置)，重置连接
                 * URG(urgent紧急)
         * IP数据包的数据部分就是整个TCP报文段数据
         * 是可靠的传输协议，可靠性的保证(两点)
             * 具有CRC校验，这样如果数据包中的某些数据出现错误可以通过校验来发现
             * 每个数据包都有一个序号，这样就能保证数据包的顺序性，如果出现错位的数据包可以请求重发
     * TCP与UDP的区别
         * TCP：建立连接通道、传输数据大小无限制、速度慢、可靠
         * UDP：把数据打包、传输数据大小有限制(限制在64KB之内)、不建立连接、速度快、不可靠
     * 报文段
         * 通过报文段可以查询各个网络路由网段、IP地址、交换协议等IP数据包信息
         * 报文段充当整个TCP/IP协议数据包的导航路由功能
         * 报文在传输过程中会不断的封装成分组、包、帧来传输
         * **封装的方式就是添加一些控制信息组成的首部，即报文头**
  * 建立连接/断开连接
     * TCP的连接是逻辑的连接。物理连接基于底层的协议已经建立完成，而且TCP建立连接需要假设底层连接已经成功。简单理解TCP的连接，就是客户端和服务端分别记录了各自接收到的数据包的序号，并且将自身设置为某种状态
     * TCB传输控制块Transmission Control Block，存储每一个连接中的重要信息，如TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号
     * 建立起一个TCP连接需要经过“三次握手”
         * 服务端B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。若有，则作出响应
         * **第一次握手：**客户端A的TCP客户进程也是首先创建传输控制块TCB，然后向服务端B发出连接请求报文段，（首部的同步位SYN=1，初始序号seq=x），（SYN=1的报文段不能携带数据）但要消耗掉一个序号(消耗掉的原因，见“序号”的定义及特点)，此时TCP客户进程进入SYN-SEND（同步已发送）状态。
         * **第二次握手：**服务端B收到连接请求报文段后，如同意建立连接，则向客户端A发送确认，在确认报文段中（SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y），测试TCP服务器进程进入SYN-RCVD（同步收到）状态
         * **第三次握手：**TCP客户进程收到服务端B的确认后，要向服务端B给出确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED（已建立连接）
         * 当服务端B收到客户端A的确认后，也进入ESTABLISHED状态
         * 总结：起初客户端A和服务端B都处于CLOSED状态——服务端B创建TCB，处于LISTEN状态，等待客户端A请求——客户端A创建TCB，发送连接请求（SYN=1，seq=x），进入SYN-SENT状态——服务端B收到连接请求，向客户端A发送确认（SYN=ACK=1，确认号ack=x+1，初始序号seq=y），进入SYN-RCVD状态——客户端A收到服务端B的确认后，给服务端B发出确认（ACK=1，ack=y+1，seq=x+1），客户端A进入ESTABLISHED状态——服务端B收到客户端A的确认后，进入ESTABLISHED状态**(连接的建立需要经过3次确认的过程)**
         * 连接的建立需要经过多次交互，因此建立连接是高成本的操作。在实际生产环境中，为了应对建立连接时的高成本问题，会减少连接建立的频度，通常做法是建立连接池，传输数据时直接从连接池中获取连接，而不是建立新连接
     * TCP连接的断开过程需要经过“四次挥手”(如客户端发起断开)
         * 客户端A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待服务端B的确认
         * 服务端B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），服务端B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端A到服务端B的连接释放
         * 客户端A收到服务端B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待服务端B发出的连接释放报文段
         * 服务端B没有要向客户端A发出的数据，服务端B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端B进入LAST-ACK（最后确认）状态，等待客户端A的确认
         * 客户端A收到服务端B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端A才进入CLOSED状态
         * 总结：起初客户端A和服务端B处于ESTABLISHED状态——客户端A发出连接释放报文段并处于FIN-WAIT-1状态——服务端B发出确认报文段且进入CLOSE-WAIT状态——客户端A收到确认后，进入FIN-WAIT-2状态，等待服务端B的连接释放报文段——服务端B没有要向客户端A发出的数据，服务端B发出连接释放报文段且进入LAST-ACK状态——客户端A发出确认报文段且进入TIME-WAIT状态——服务端B收到确认报文段后进入CLOSED状态——客户端A经过等待计时器时间2MSL后，进入CLOSED状态**(断开连接的过程中，发起方的状态有ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSED；接收方的状态有ESTABLISHED、CLOSE-WAIT、LAST-ACK、CLOSED)**

* 应用层
  * 应用层是在用户空间实现的，负责处理业务逻辑，如文件传输、网络管理。应用层规定了应用程序的数据格式，即应用数据
  * 常用协议
     * HTTP协议
         * HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议，是一种**无状态的协议**(HTTP是无状态协议，它不对之前发生过的请求和响应保留相应的状态)，使用URI(统一资源标识符)定位互联网上的资源
         * HTTP协议(超文本传送协议)，是Web联网的基础，也是手机联网常用的协议之一
         * HTTP协议是建立在TCP协议之上的一种应用
         * HTTP连接显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接
         * 在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接
         * 在HTTP 1.1中，则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求
              * HTTP1.1中的方法
                 * GET方法：获取资源
                 * POST方法：传输实体主体
                 * PUT方法：传输文件
                 * HEAD方法：获得报文首部
                 * DELETE方法：删除文件
                 * OPTIONS方法：询问支持的方法
                 * TRACE方法:追踪路径
                 * CONNECT方法：要求用隧道协议连接代理
         * HTTP协议采用了请求/响应模型
         * Cookie
             * 通过引入Cookie技术，解决HTTP无状态的问题
             * Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。它会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息
         * HTTP报文结构、状态码，见[图解HTTP](https://88benxiaoyang.github.io/2019/01/25/图解HTTP/)

  * 两个计算机之间的交流无非是两个端口之间的数据通信，具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。如HTTP、FTP

##### 套接字

套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它**是网络通信过程中端点的抽象表示**，包含进行**网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口**

Tips

```
网络编程也称为Socket编程，Socket通常译为“套接字”，但原意应该为“接口”，是操作系统提供给开发人员进行网络开发的API接口。这套接口通过对参数的不同调整可以支持多种协议，包括TCP、UDP和IP等。

Socket的作用，在网络传输中用于唯一标识两个端点的连接
Socket的组成，IP Address + Port number = Socket(一个Socket由一个IP地址和一个端口号唯一确定)

在实际生产环境中为了提高数据传输和处理的效率，通常采用异步模式

在传统的UNIX环境下可以操作TCP/IP协议的接口不止Socket一个，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。通常，Socket编程主要是指基于TCP/IP协议的网络编程。
```

* 背景

应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务

* 平时说得最多的Socket是什么

平时说得最多的Socket，实际上是对TCP/IP协议的封装，**Socket本身并不是协议，而是一套调用接口(API)**。通过Socket，我们使用TCP/TP协议方便了。实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，希望也能适应其他的网络协议。所以说，**Socket**的出现只是使得使用TCP/TP协议栈变得更方便，**是对TCP/IP协议的抽象，从而形成了一些最基本的函数接口，如create、listen、connect、accept、send、read和write等。**

TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。

实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而**Socket本身不算是协议，它只是提供了一个针对TCP或UDP编程的接口。**Socket是用于**端口通信**开发的工具，它要更底层以一些。

* 对于一个功能齐全的Socket，包含以下四个基本步骤
  1. 创建Socket
  2. 打开连接到Socket的输入/出流
  3. **按照一定的协议对Socket进行读/写操作**
  4. 关闭Socket
  
  * 其中第三步是实际操作过程中用来调用Socket和实现程序功能的关键步骤(需要根据不同的程序进行对应的操作，主要是针对编程语言而言)

* 建立Socket连接
  * 建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket
  * 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认
     * 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求
     * 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求
     * 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求
  * Socket通常用来实现C/S结构。使用Socket进行Client/Server程序设计的一般连接过程是这样的：Server端Listen(监听)某个端口是否有连接请求，Client端向Server端发出Connect(连接)请求，Server端向Client端发回Accept（接受）消息，一个连接就建立起来了。Server端和Client端都可以通过Send，Write等方法与对方通信
  * Socket连接与TCP连接/HTTP连接
      * 创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。通常情况下Socket连接就是TCP连接
      * 实际网络应用中，通过Socket建立客户端与服务端之间的长连接需要穿越多个中间节点，如路由器、网关、防火墙等，因大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态
      * HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据
      * 总结：实际使用中，很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端

##### 数据包

数据包，指在应用层，数据或报文按照一定事先规定好的规则整合的数据集合。实际操作中，包括组包(打包)、数据包传送、解包。数据包经常通过套接字来传送。

* 组包(打包)：指按照协议把零散的数据或报文按照一定的规则组合起来
* 数据包传送：指数据包的电气物理传输
* 解包：指接收端对接收到的数据进行解析，获得有用的信息和数据

### 小结

网络编程就是使用IP地址或域名和端口连接到另一台计算机上对应的程序，按照规定的协议(数据格式)来交换数据，实现计算机间的通信功能。实际编程中建立连接、发送和接收数据在语言级已经实现，做得更多的工作是设计协议，以及编写生成和解析数据的代码，然后把数据转换成逻辑结构的显示或控制逻辑即可。