---
title: Swift
date: 2019-05-27 11:08:36
tags: iOS
categories: iOS
---

### 简介

`Swift` 是支持多编程范式和编译式的语言

`Swift` 的特点：

* 结合`C`和`OC`的优点
* 和`OC`使用相同的运行环境
* 用于开发`OS X`和`iOS`应用程序
* 将`OC`中的`.h`和`.m`文件合并成了一个文件`.swift`文件
* 有类型检查的能力，即可以根据值推出变量的类型 - “类型意识强”

学习`swift`时，可利用利器`Playground`，因其能实时显示结果

Tips:

```
编程范式：编程的模式、方法，编程风格。每种语言根据其特性，有对应的
编程模式、方法，有对应的技术禁止和技术允许。

一种语言，因其语言所具有的特性，可有多种编程范型（编程模式）。如
 c++ 可有过程化编程、面向对象编程、泛型编程。范型元素，即模式元素。
```

### 基本语法

* 使用`import`语句引入任何`OC`框架（或`C`库）
* 程序由多种标记组成，标记包括单词、标识符、常量、字符串、符号
* 注释
  1. 单行注释：`//注释内容`
  2. 多行注释：`/*注释内容*/`

* 分号
  1. 不要求在每行语句的结尾使用分号(;)
  2. 在同一行书写多条语句时，必须用分号隔开，最后一条语句可不用分号结尾

* 标识符
  * 是给变量、常量、方法、函数、枚举、结构体、类、协议等指定的名字
  * 命名规则
     1. 区分大小写
     2. 首字符可以以下划线(_)或者字母开始，但不能是数字
     3. 标识符中其他字符可以是下划线(_)、字母或数字
     4. 如果一定要使用关键字作为标识符，可以在关键字前后添加重音符号(')。注，通常不用关键字作为标识符

* 关键字
  * 是类似于标识符的保留字符序列
  * 关键字是对编译器具有特殊意义的预定义保留标识符
  * 常见的关键字
     1. 与声明有关
     2. 与语句有关，如条件/判断/循环等语句
     3. 表达式和类型
     4. 在特定上下文中使用的关键字

* 空格
  * 对空格的使用有一定的要求，但不像`Python`对缩进的要求那么严格
  * 运算符不能直接跟在变量或常量的后面
  * 运算表达式中空格有断句的作用，在这种情况下使用分号`(;)`来表示一句完整的运算表达式

* 打印输出
  * 使用`print`函数打印输出

### 数据类型

* 有符号浮点数类型
  * `Double`
     1. `64`位浮点数，需要存储很大或很高精度的浮点数时使用此类型
     2. 精确度高，至少有`15`位数字

  * `Float`
     1. `32`位浮点数，对精度要求不高时使用此类型
     2. 最少只有`6`位数字
   
  * 当使用浮点数时，`swift`默认为`Double`类型

* 布尔值，`true/false`

* 字符串，字符的序列集合

* 可选类型`(Optional)`，使用可选类型来处理值可能缺失的情况。可选类型表示有值或没有值

* 类型别名
  * 对当前的类型定义了另一个名字，通过使用`typealias`关键字来定义
  * 语法格式：`typealias newname = type`

* 类型安全
  * `swift`是一种类型安全`(type safe)`的语言
  * 在编译时进行类型检查`(type checks)`，在这期间把不匹配的类型标记为错误

* 类型推断
  * 在没有显示指定类型时，`swift`会使用类型推断`(type inference)`来选择合适的类型
  * `OC`中声明变量时需要指明类型
  * 当推断浮点数的类型时，`swift`总是会选择`Double`而不是`Float`
  * 如果表达式中同时出现了整数和浮点数，会被推断为`Double`类型

* 类型转换
  * 变量类型不同时，若要进行相互赋值时，需要进行显示转换，将数据类型统一为其中的一种类型

* 整数
  * 可正可负的整数，称为有符号整数
  * 只能为正的整数，称为无符号整数

### 知识点

##### 变量

* 变量是占位符，用于引用计算机内存地址
* 类型决定了变量占用内存的大小
* 变量声明
  * 告诉编译器在内存中的哪个位置上为变量创建多大的存储空间
  * 在使用前，用关键字`var`声明它
* 变量命名，规则见“基本语法/标识符/命名规则”
* 变量输出
  * 变量和常量可以使用`print`函数来输出
  * 在字符串中可以使用括号与反斜线来插入变量

##### 常量

* 使用关键字`let`来声明
* 类型标注
  * 说明常量或变量中要存储的值的类型
  * 添加类型标注，需要在常量或变量名后面加上一个冒号和空格，然后加上类型名称，如：`let/var variablename: Type`
* 变量命名，规则见“基本语法/标识符/命名规则”
* 常量需要的开销比变量小
* 常量的值，在编译的时候可以不立即指定，但是只能给它赋值一次

##### 字面量

* 整型字面量
  * 二进制前缀`0b`
  * 八进制前缀`0o`
  * 十六进制前缀`0x`
 
* 浮点型字面量
  * 用指数表示的小数
     1. 十进制表示，指数部分由大写或小写字母`e`为前缀后跟十进制数字串组成，这串数字表示`e`之前的数量乘以`10`的几次方，如：`1.25e2表示1.25*10^2也就是125.0`
     2. 十六进制表示，指数部分由大写或小写字母`p`为前缀后跟十进制数字串组成，这串数字表示`p`之前的数量乘以`2`的几次方，如：`0xFp2表示15*2^2也就是60`

* 布尔型字面量
  * `true 表示真`
  * `false 表示假`
  * `nil 表示没有值`

##### 可选类型`(Optionals)`

* 用于处理值缺失的情况
* `swift`定义后缀`?`作为命名为可选类型`(Optional)`的缩写
* `var optionalInteger: Int? 等价于 var optionalInteger: Optional<Int>`，注：类型和`?`之间没有空格
* 可选类型是一个含有两种情况的枚举，`None`和`Some(T)`
* 任何类型都可以明确声明为可选类型
* 可以使用后缀操作符`!`来访问可选类型的实例变量值
  * 使用操作符`!`去获取值为`nil`的可选变量会有运行时错误
  * 可以用可选链接和可选绑定选择性执行可选表达式上的操作，这种情况下，如果值为`nil`，任何操作都不会执行，也不会有运行报错

* 可选类型类似于`OC`中指针的`nil`值，但是`nil`只对类`(class)`有用，而可选类型对所有类型都可用，并且更安全

* 可选值的强制解析
  * 在确定可选类型确实包含值之后，可在可选的名字后面加一个感叹号`(!)`来获取值
  * 使用`!`来获取一个不存在的可选值会导致运行时错误，因此，使用`!`来强制解析值之前，一定要确定可选包含一个非`nil`的值

* 自动解析，在声明可选变量时使用`!`替换`?`，这样可选变量在使用时就不需要再加`!`来获取值，它会自动解析
* 可选绑定，用来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或变量

##### 运算符

* 算术运算符
  * 除号`(/)`
  * 求余`(%)`
  * `swift3`中已经取消了`++`、`--`，对应的操作符为，`++`对应`+=`，`--`对应`-=`

* 比较运算符
* 逻辑运算符
* 位运算符
  * 用来对二进制位进行操作
  * 取反`(~)`，对操作数的每一位取反
  * 按位与与`(&)`，每个位设为`1`的条件是两个输入数的同一位相同且为`1`时，就设为`1`，反之则为`0`
  * 按位与或`(|)`，每个位设为`1`的条件是只要两个输入数的一位中有一个为`1`时，就设为`1`
  * 按位异或`(^)`，每个位设为`1`的条件是两个输入数的同一位不同，如果相同就设为`0`
  * 按位左移`(<<)`，移动指定位数，空位用`0`填充
  * 按位右移`(>>)`，移动指定位数，空位用`0`填充

* 赋值运算符
* 区间运算符
  * 闭区间运算符`((a...b))`，在迭代一个区间的所有值时是非常有用的，如在`for-in`循环中
  * 半开区间运算符`((a...)`

* 其他运算符
  * 一元运算符。如`!`，在`swift`中用在`Optional`类型取值
  * 二元运算符
  * 三元运算符。如，`a ? b : c`

* 运算符优先级
  * 指针最优，单目运算优于双目运算
  * 先乘除(模)，后加减
  * 先算术，后移位，最后位运算。如，`1 << 3 + 2 & 7 等价于 (1 << (3 + 2)) & 7`
  * 逻辑运算最后计算

##### 循环控制语句

* `continue`语句，告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代
* `break`语句，中断当前循环
* `fallthrough`语句，如果在一个`case`执行完后，想要继续执行下面的`case`，需要`fallthrough`(贯穿)关键字

##### 字符串

* 可以使用空的字符串字面量赋值给变量或初始化一个`String`类的实例来初始化一个空的字符串
* 使用字符串属性`isEmpty`来判断字符串是否为空
* 字符串中插入值，可以在其中包含常量、变量、字面量或表达式，插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中，字符串插值是一种构建新字符串的方式
* 字符串可以通过`+`号来连接
* 字符串长度使用`String.count`属性来计算
* 字符串比较，使用`==`来比较两个字符串是否相等
* `Unicode`是一个国际标准，用于文本的编码，`Swift`的`String`类型是基于`Unicode`建立的
* 常用函数
  * `isEmpty` 判空
  * `hasPrefix` 检查是否拥有指定前缀
  * `hasSuffix` 检查是否拥有指定后缀
  * `Int(String)` 转换字符串数字为整型
  * `String.count` 计算字符串长度
  * `+` 连接两个字符串，并返回一个新的字符串
  * `==` 判断两个字符串是否相等
  * `<` 比较两个字符串，对两个字符串的字母逐一比较
  * `utf8、utf16、unicodeScalars、+=、!=`

##### 字符

* `swift`的字符是一个单一的字符字符串字面量，类型为`Character`
* 不能在`Character`类型中存储更多的字符，如：`let/var char: Character = "ABC"`，这样会报错，这种情况下`"ABC"`被当作`String`类型
* 不能创建空的`Character`类型变量或常量，这种情况下，`""`被当作`String`类型
* 可以对字符串进行字符遍历，使用`for-in`遍历字符串中的`character`属性
* 可以对字符串进行字符连接，使用`String`的`append()`方法来实现

##### 数组

* 数组是有序列表，同一类型的多个值
* 相同的值可以多次出现在一个数组的不同位置中
* `Swift`数组会强制检测元素的类型，如类型不同则会报错
* 常量数组的大小和内容都不可以修改
* 数组的索引从`0`开始
* 初始化方式构建的数组中，每个元素的值都是指定的初始值
  * 初始化方式构建数组的语法如下：
  ```
  var someArray = [SomeType](repeating: InitialValue, 
  count: NumberOfElements)//InitialValue是初始值，
  NumberOfElements是数组大小
  ```

* 可以使用`append()`方法或赋值运算符`+=`在数组末尾添加元素
* 遍历数组
  * 使用`for-in`循环来遍历数组中的数据项
  * 如需要每个数据项的值和索引值，可以使用`String`的`enumerate()`方法来进行数组遍历

* 可以使用加法操作符`+`来合并两种已存在的相同类型的数组
* 使用`count`属性，计算数组元素个数
* 使用`isEmpty`属性，来判断数组是否为空

##### 字典

* `swift`字典会强制检测元素的类型
* `swift`字典的`key`没有类型限制可以是整型或字符串，但必须是唯一的
* 常量字典的大小和内容都不可以修改
* 使用`updateValue(forKey:)`增加或更新字典的内容。如果`key`不存在，则添加值，如果`key`存在则修改`key`对应的值，使用`updateValue(forKey:)`时，会返回旧值
* 使用`removeValue(forKey:)`移除`key-value`对，如果`key`存在，该方法返回移除的值，如果不存在返回`nil`。可以通过指定键的值为`nil`来移除`key-value`对
* 使用`enumerate()`方法遍历字典时，获取的`value`是对应的`key-value`对
* 可以对字典的键和值，分别取对应的元素构成的数组
* 使用`count`属性来获知字典有多少个键值对
* 使用`isEmpty`属性来对字典进行判空

##### 函数

* 函数是用来完成特定任务的独立代码块
* 函数的声明和定义
  * 声明，告诉编译器函数的名字、返回类型及参数
  * 定义，提供了函数的实体

* `swift`函数包含了参数类型及返回值类型
* 使用关键字`func`来定义函数
* 函数的实参传递的顺序必须与形参列表相同
* `->`后定义函数的返回值类型
* 元组作为函数返回值
  * 元组与数组类似，不同的是，元组中的元素可以是任意类型，使用的是圆括号
  * 可以用元组`(tuple)`类型让多个值作为一个复合值从函数中返回

* 可以在局部参数名前指定外部参数名，中间以空格分隔，外部参数名用于在函数调用时传递给函数的参数。注，如提供了外部参数名，那么函数在被调用时，必须使用外部参数名

* 可变参数，可变参数通过在变量类型名后面加入`(...)`的方式来定义，如`func vari<N>(members: N...){}`

* 一般默认在函数中定义的参数都是常量参数，即参数只能查询使用，不能改变它的值。若想要改变参数的值，可以在参数定义前加`inout`关键字，这样就可以改变这个参数的值了

* 一般默认的参数传递都是传值调用的，而不是传引用。所以传入的参数在函数内改变，并不影响原来的那个参数，传入的只是这个参数的副本。当传入的参数作为输入输出参数时，需要在参数名前加`&`符，表示这个值可以被函数修改。如，函数调用的时候：`swapTwoInts(&x, &y)`

* 每个函数都有特定的函数类型，由函数的参数类型和返回类型组成

##### 闭包

* 闭包，是自包含的功能代码块，可以在代码中使用或者用来作为参数传值
* 函数和闭包都是引用类型

##### 枚举

* 枚举是一组有共同特性的数据的集合

##### 结构体

* 结构体是一种构造体
* 可以为结构体定义属性(常量、变量)和添加方法，从而扩展结构体的功能
* 结构体总是通过被复制的方式在代码中传递，因此它的值是不可修改的
* 通过关键字`struct`来定义结构体
* 通过结构体名来访问结构体成员
* 结构体实例化使用`let`关键字
* 结构体实例总是通过值传递来定义你的自定义数据类型
* 存在以下条件时，考虑构建结构体
  * 结构体的主要目的是用来封装少量相关简单数据值
  * 有理由预计一个结构体实例在赋值或传递时，封装的数据将会被拷贝而不是被引用
  * 任何在结构体中存储的值类型属性，也将会被拷贝，而不是被引用
  * 结构体不需要去继承另一个已存在类型的属性或行为

* 结构体实例是通过值传递而不是通过引用传递
* 结构体内使用成员属性时，使用`self`关键字

##### 类

* 类是一种构造体
* 可以为类定义属性(常量、变量)和方法
* `swift`的类不需要为自定义类去创建独立的接口(`.h`文件)和实现文件(`.m`文件)
* `swift`中创建类，在一个单一文件中定义一个类，系统会自动生成面向其他代码的外部接口

* 类和结构体的对比：
  * 共同点
     1. 定义属性用于存储值
     2. 定义方法用于提供功能
     3. 定义附属脚本用于访问值
     4. 定义构造器用于生成初始化值
     5. 通过扩展以增加默认实现的功能
     6. 符合协议以对某类提供标准功能
    
   * 类特有的
     1. 继承，允许一个类继承另一个类的特征
     2. 类型转换，允许在运行时检查和解释一个类实例的类型
     3. 解构器，允许一个类实例释放任何其所被分配的资源
     4. 引用计数，允许对一个类的多次引用

* 类的属性通过`“.”`来访问，格式：`实例化类名.属性名`
* 恒等运算符
  * 因类是引用类型，有可能有多个常量或变量同时引用某一个类实例，为了能够判定两个常量或变量是否引用同一个类实例，`swift`提供了两个恒等运算符：`===`(判断是否引用相同的类实例)、`!==`(判断是否引用不相同的类实例)

##### 属性

* 属性将值跟特定的类、结构体或枚举关联

* 存储属性、计算属性
  * 存储属性
     1. 存储常量或变量作为实例的一部分，用于类和结构体
     2. 一个存储属性就是存储在特定类或结构体的实例里的一个常量(用`let`定义)或变量(用`var`定义)
     3. 可以在定义存储属性的时候指定默认值
     4. 可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值
     5. 常量属性在构造过程完成之前必须要有初始值
  * 计算属性
     1. 计算一个值，用于类、结构体和枚举
     2. 计算属性不直接存储值，而是提供一个`getter`来获取值，一个可选的`setter`来间接设置其他属性或变量的值。如果计算属性的`setter`没有定义表示新值的参数名，则可以使用默认名称`newValue`
     3. 只读计算属性，只有`getter`没有`setter`的计算属性，只读计算属性总是返回一个值，可以通过点(`.`)运算符访问，但不能设置新的值

* 可以定义属性观察器来监控属性的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己写的存储属性上，也可以添加到从父类继承的属性上

* 延迟存储属性
  * 当第一次被调用的时候才会计算其初始值的属性
  * 在属性声明前使用`lazy`来标示一个延迟存储属性
  * 延迟存储属性，必须声明为变量(使用`var`关键字)
  * 使用场景：延迟对象的创建、当属性的值依赖于其他未知类

* 属性观察器
  * `willSet、didSet`
  * 属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器
  * 可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重载属性的方式为继承的属性(包括存储属性和计算属性)添加属性观察器
  * `willSet`和`didSet`观察器在属性初始化过程中不会被调用

* 类型属性，使用关键字`static`来定义值类型的类型属性，用关键字`class`来为类定义类型属性

##### 方法

* `swift`方法是与某些特定类型相关联的函数
* 在`OC`中，类是唯一能定义方法的类型。在`swift`中，不仅能选择是否要定义一个类/结构体/枚举，还能灵活的在创建的类型(类/结构体/枚举)上定义方法

* 实例方法
  * 是属于某个特定类、结构体或枚举类型实例的方法
  * 可以访问和修改实例属性，提供与实例目的相关的功能
  * 不能脱离于现存的实例而被调用

* `swift`函数参数可以同时有一个局部名称(在函数体内部使用)和一个外部名称(在调用函数时使用)
* 常用规则
  * 需要参数时，函数名末尾常用一个介词(with、for、by)指向方法的第一个参数

* `self`属性
  * 类型的每一个实例都有一个隐含属性叫做`self`，`self`完全等同于该实例本身
  * 可以在一个实例的实例方法中使用这个隐含的`self`属性来引用当前实例

* `swift`语言中结构体和枚举是值类型。一般情况下，值类型的属性不能在它的实例方法中被修改，但可以通过选择变异(关键字为`mutating`)这个方法进行值类型的修改

* 可变方法能够赋给隐含属性`self`一个全新的实例
* 类型方法
  * 声明结构体和枚举的类型方法，在方法的`func`关键字之前加上关键字`static`
  * 类可能会用关键字`class`来允许子类重写父类的实现方法

##### 下标脚本

* 可以定义在类、结构体和枚举这些目标中
* 是访问对象、集合或序列的快捷方式，不需要再调用实例的特定的赋值和访问方法
* 定义下标脚本使用subscript关键字，显示声明入参和返回类型
* 下标脚本允许任意数量的入参索引，并且每个入参类型也没有限制
* 下标脚本的返回值也可以是任何类型
* 下标脚本可以使用变量参数和可变参数
* 下标脚本的重载
  * 一个类或结构体可以根据自身需要提供多个下标脚本实现，在定义下标脚本时通过传入参数的类型进行区分，使用下标脚本时会自动匹配合适的下标脚本实现运行

##### 继承

* 类可以调用和访问超类的方法、属性和下标脚本，并且可以重写它们
* 重写属性
  * 子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。所以在重写一个属性时，必须将它的名字和类型都写出来
  * 注意
     1. 如果在重写属性中提供了`setter`，那么也一定要提供`getter`
     2. 如果不想在重写版本中的`getter`里修改继承来的属性值，可以直接通过`super.someProperty`来返回继承来的值，其中`someProperty`是要重写的属性的名字
     3. 可以使用`final`关键字防止被重写

* 在`class`前添加`final`关键字，这样的类是不可被继承的

##### 构造过程

* 构造过程是为了使用某个类、结构体或枚举类型的实例而进行的准备过程
* 这个过程包含了为实例中的每个属性设置初始值和为实例执行必要的准备和初始化任务
* `swift`构造函数使用`init()`方法
* 类和结构体在实例创建时，必须为所有存储型属性设置合适的初始值
* 可以在构造器中为存储属性设置初始值，同样，也可以在属性声明时为其设置默认值
* 不同参数构造器的调用，主要通过构造器中的参数名和类型来确定需要调用的构造器
* 如果在定义构造器时没有提供参数的外部名字，`swift`会为每个构造器的参数自动生成一个跟内部名字相同的外部名
* 如不希望为构造器的某个参数提供外部名字，可以使用下划线`"_"`来显示描述它的外部名
* 可选类型
  * 如定制的类型包含一个逻辑上允许取值为空的存储型属性，需要将它定义为可选类型`optional type`(可选属性类型)
  * 当存储属性声明为可选时，将自动初始化为空`nil`

* 构造过程中修改常量属性
  * 只要在构造过程结束前常量的值能确定，可以在构造过程中的任意时间点修改常量属性的值
  * 对某个类实例来说，它的常量属性只能在定义它的类的构造过程中修改，不能在子类中修改

* 结构体的逐一成员构造器
  * 如果结构体对所有存储型属性提供了默认值，且自身没有提供定制的构造器，它们能自动获得一个逐一成员构造器
  * 在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值

* 值类型的构造器代理
  * 构造器可以通过调用其他构造器来完成实例的部分构造过程，这一过程称为构造器代理，它能减少多个构造器间的代码重复
  * 构造器代理的规则
     1. 值类型，不支持继承
     2. 类类型，可以继承自其他类

* 构造器的继承和重载
  * 子类不会默认继承父类的构造器
  * 父类的构造器仅在确定和安全的情况下被继承
  * 重写一个父类指定构造器时，需要写`override`修饰符

* 可失败构造器
  * 如果一个类、结构体或枚举类型的对象，在构造自身的过程中有可能失败，则为其定义一个可失败构造器
  * 变量初始化失败可能的原因有：
     1. 传入无效的参数值
     2. 缺少某种所需的外部资源
     3. 没有满足特定条件
  * 可用一个非可失败构造器覆盖一个可失败构造器，但反过来却行不通
  * 一个非可失败的构造器永远也不能代理调用一个可失败构造器
  * 语法：在`init`关键字后面添加问号`(init?)`

##### 析构过程

* 在一个类的实例被释放之前，析构函数被立即调用
* 用关键字deinit来标示析构函数
* 析构函数只适用于类型
* 在类的定义中，每个类最多只能有一个析构函数
* 释放资源
  * `swift`会自动释放不再需要的实例以释放资源
  * `swift`通过自动引用计数`(ARC)`处理实例的内存管理

##### 可选链

* 可选链是一种可以请求和调用属性、方法和子脚本的过程，用于请求或调用的目标可能为`nil`
* 返回值
  * 如果目标有值，调用就会成功，返回该值
  * 如果目标为`nil`，调用将返回`nil`

* 多次请求或调用可以被链接成一个链，如果任意一个节点为`nil`将导致整条链失效
* 通过在属性、方法或下标脚本的可选值后面放一个问号(?)，即可定义一个可选链
* 可以使用可选链来尝试从下标脚本获取值并检查下标脚本的调用是否成功，不能通过可选链来设置下标脚本

##### 自动引用计数`(ARC)`

* `swift`使用自动引用计数`(ARC)`这一机制来跟踪和管理应用程序的内存
* 为了确保使用中的实例不会被销毁，`ARC`会跟踪和计算每一个实例正在被多少属性、常量或变量所引用
* 实例赋值给属性、常量或变量，它们都会创建此实例的强引用，只要强引用还在，实例是不允许被销毁的
* 解决实例之间的循环强引用
  * 弱引用
     1. 对于生命周期中会变为`nil`的实例使用弱引用
     2. 使用`weak`关键字进行标示，通常与`var`搭配使用
  * 无主引用
     1. 对于初始化赋值后再也不会被赋值为`nil`的实例，使用无主引用
     2. 使用`unowned`关键字进行标示，通常与`let`搭配使用
  * 弱引用和无主引用允许循环引用中的一个实例用另外一个实例而不保持强引用

* 闭包引起的循环强引用
  * 会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。如闭包体中访问了实例的某个属性，或者调用了某个方法，这两种情况都导致了闭包“捕获”`self`，从而产生了循环强引用
  * 解决闭包引起的循环强引用
     * 在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用
     * 方法：
         1. 当闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用
         2. 当捕获引用有时可能会是`nil`时，将闭包内的捕获定义为弱引用
         3. 如果捕获的引用绝对不会置为`nil`，应该用无主引用
         4. 闭包中无主引用的语法：
         
         ```
         { [unowned self] in
           // todo
         }
         ```

##### 类型转换

* 作用
  * 可以判断实例的类型
  * 可用于检测实例类型是否属于父类或者子类的实例
  * 可用来检查一个类是否实现了某个协议
* 使用 `is` 和 `as` 操作符实现
  * `is` 用于检测值的类型
  * `as` 用于转换类型
* 向下转型
  * 用类型转换操作符：`as?` 或 `as!`
  * 不确定向下转型是否成功时，用类型转换的条件形式`(as?)`。条件形式的类型转换总是返回一个可选值，若不成功，可选值将是`nil`
  * 确定向下转型成功时，使用强制形式(as!)。如转型不成功，会触发一个运行时错误

* 不确定类型
  * `AnyObject`，代表任何`class`类型的实例
  * `Any`，表示任何类型，包括方法类型

* 在一个`switch`语句的`case`中使用强制形式的类型转换操作符(`as`，而不是`as?`)来检查和转换到一个明确的类型

##### 扩展

* 向一个已有的类、结构体或枚举类型添加新功能
* 可以对一个类型添加新的功能，但是不能重写已有的功能
* 应用场景
  * 添加计算型属性和计算型静态属性
  * 定义实例方法和类型方法
  * 提供新的构造器
  * 定义下标
  * 定义和使用新的嵌套类型
  * 使一个已有类型符合某个协议

* 语法，使用关键字 `extension`
* 一个扩展可以扩展一个已有类型，使其能够适配一个或多个协议
* 扩展可以向类中添加新的便利构造器`init()`，但是不能向类中添加新的指定构造器或析构函数
* 结构体和枚举类型中修改`self`或其属性的方法必须将该实例方法标注为`mutating`

##### 协议

* 协议规定了用来实现某一特定功能所必需的方法和属性
* 类、结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能
* 如果类在遵循协议的同时拥有父类，应该将父类名放在协议名之前，以逗号分隔
* 对属性的规定
  * 协议用于指定特定的实例属性或类属性，而不用指定是存储属性或计算属性，必须指明是只读的还是可读可写的
  * 协议中通常用`var`来声明变量属性，在类型声明后加上`{set get}`来表示属性是可读可写的，只读属性则用`{get}`来表示
* 协议可以要求它的遵循者实现指定的构造器
* 尽管协议本身并不实现任何功能，但是协议可以被当作类型来使用
  * 使用场景
     1. 作为函数、方法或构造器中的参数类型或返回值类型
     2. 作为常量、变量或属性的类型
     3. 作为数组、字典或其他容器中的元素类型
* 扩展可以为已存在的类型添加属性、方法、下标脚本、协议等成员
* 检验协议的一致性
  * 可以使用`is`和`as`操作符来检查是否遵循某一协议或强制转化为某一类型
  * `is`操作符用来检查实例是否遵循了某个协议
  * `as?`返回一个可选值，当实例遵循协议时，返回该协议类型，否则返回`nil`
  * `as`用以强制向下转型，如果强转失败，会引起运行时错误

##### 泛型

* `swift`标准库是通过泛型代码构建出来的
* `swift`的数组和字典类型都是泛型集
* 泛型使用了占位类型名(通常用字母`T`来表示)来代替实际类型名
* 函数名后面跟着占位类型名`(T)`，并用尖括号括起来`<T>`。尖括号告诉`swift`那个`T`是函数定义内的一个占位类型名，因此`swift`不会去查找名为`T`的实际类型
* 类型约束能够确保类型符合泛型函数或类的定义约束
* 可以在参数列表中通过`where`语句定义参数的约束

##### 访问控制

* 访问控制可以限定其他源文件或模块中代码对你代码的访问级别
* 访问控制基于模块与源文件
* 访问级别
  * `public` - 模块级别，别人能访问、自己能访问，最高级访问级别
  * `internal` - 模块级别，别人不能访问、自己能访问
  * `fileprivate` - 文件级别，文件内私有，只能在当前源文件中使用
  * `private` - 类级别，只能在类中访问，只在作用域内有效，离开作用域就无法访问，最低级访问级别
* 除非有特殊说明，否则实体都使用默认的访问级别`internal`
* 函数的访问级别需要根据该函数的参数类型和返回类型的访问级别得出
* 如一个类型内有不同访问级别的成员，根据元组访问级别的原则，得出该类型的访问级别
  * 元组访问级别的原则，元组的访问级别与元组中访问级别最低的类型一致
* 枚举中成员的访问级别继承自该枚举，不能为枚举中的成员单独声明不同的访问级别
* 子类的访问级别不得高于父类的访问级别
* 常量、变量、属性不能拥有比它们的类型更高的访问级别
* 下标也不能拥有比索引类型或返回类型更高的访问级别
* 常量、变量、属性、下标索引的`getter`和`setter`的访问级别继承自它们所属成员的访问级别，`setter`的访问级别可以低于对应的`getter`的访问级别，这样就可以控制变量、属性或下标索引的读写权限

### 常见知识点总结

* `swift`中的头文件是全局共享的
* 声明为`Optional`的变量/常量不能直接参与运算，必须解包后才能参与运算
* 可对一个可选类型使用后缀操作符`!`来强制拆包访问这个值
  * 注：使用`!`来获取一个不存在的可选值会导致`crash`，因此在使用`!`强制展开之前必须确保可选项中包含一个非`nil`的值
* 可以使用可选项绑定来判断可选项是否包含值，如果包含就把值赋给一个临时常量/变量
  * 可选项绑定，将可选项赋值给一个常量，然后判断常量的值是否为`nil`来进行处理 
  * 语法：`if let/var newValue = 待解包的可选项值 {}`

* 隐式展开可选项
  * 背景
     * 有时在一些程序结构中可选项一旦被设定值之后，就会一直拥有值。这种情况下不必每次访问的时候都进行展开，因为它可以安全的确认每次访问的时候都有一个值
  * 声明方式
     * 通过在类型后面添加一个叹号`(!)`而非问号`(?)`来声明一个隐式展开可选项

* 合并空值运算符
  * `??`
  * 语法：`a ?? b`，理解：如果可选项`a`有值则展开，如果没有值，是`nil`，则返回默认值`b`。表达式`a`必须是一个可选类型，表达式`b`必须与`a`的存储类型相同
  * 合并空值运算符是如下代码的缩写：`a != nil ? a! : b`

* 类型转换
  * `as`
     1. 向上转型，从派生类转换为基类
     2. 数值类型转换，消除二义性。如：`let num1 = 42 as CGFloat`
     3. `switch`语句中进行模式匹配
  * `as!`，向下转型，是强制类型转换，如果转换失败会报`runtime`运行错误
  * `as?`，向下转型，但`as?`如果转换不成功时会返回一个`nil`对象，成功时返回可选类型值`(Optional)`，需要拆包使用
  * 在确保会转换成功时使用`as!`，否则使用`as?`

* 代码逻辑组织说明
  * `MARK`
     * 有分隔线 `//MARK: - 说明文字`
     * 无分隔线 `//MARK: 说明文字`
     * 注：`MARK`要大写，`MARK`后有冒号`(:)`
  * `TODO`
     * 标记提醒
     * 用法，`//TODO:需要提醒的文字`
  * `FIXME`
     * `bug`待修改提示
     * 用法，`//FIXME:需要修改bug的相关说明`

* 类型比较
  * `is` 判断对象的类型是否一致
  * `===` 判断对象所引用的内存地址是否相同
* 字符串
  * `==` 判断内容是否相等