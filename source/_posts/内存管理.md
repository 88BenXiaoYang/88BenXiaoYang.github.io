---
title: 内存管理
date: 2019-06-05 18:44:17
tags:
---

##### 对象生命周期

对象的生命周期包括诞生(通过`alloc`或`new`方法实现)、生存(接收消息并执行操作)、交友(通过复合以及向方法传递参数)以及最终死去(被释放掉)。当生命周期结束时，对象的原材料(内存)将被回收以供新的对象使用。

##### 引用计数

引用计数是用于供系统感知对象生命周期是否结束，以便于系统对对象所占用的内存进行管理(主要用于对对象占用的内存何时回收进行管理)的技术。

* `iOS`内存管理的方式是“引用计数”，一般内存管理的方式是“谁申请谁释放”

* 引用计数工作原理
  * 每个对象都有一个与之相关联的整数，被称作对象的**引用计数器**或**保留计数器**。
  * 对象创建出来时，其保留计数(引用计数)至少为`1`。
  * 当某段代码需要访问一个对象时，该代码就将该对象的保留计数器值加`1`，表示“我要访问该对象”，调用`retain`方法。当这段代码结束对象访问时，将对象的保留计数器减`1`，表示代码不再访问该对象，调用`release`或`autorelease`方法。当对象的保留计数器的值为`0`时，表示不再有代码访问该对象了，因此对象将被销毁，其占用的内存被系统回收以便重用。此时，所有指向该对象的引用也都变得无效了。

##### 内存管理规则

* 当使用new、alloc或copy方法创建一个对象时，该对象的保留计数器的值为1。当不再使用该对象时，应该向该对象发送一条release或autorelease消息。这样，该对象将在其使用寿命结束时被销毁
* 当通过其他方法获得一个对象时，假设该对象的保留计数器的值为1，而且已经被设置为自动释放，那么不需要执行任何操作来确保该对象得到清理。如果打算在一段时间内拥有该对象，则需要保留它并确保在操作完成时释放它
* 如果保留了某个对象，就需要(最终)释放或自动释放该对象。必须保持retain方法和release方法的使用次数相等

##### 引用计数式内存管理的思考方式

* 自己生成的对象，自己所持有
  * 使用`alloc/new/copy/mutableCopy`名称开头的方法名意味着自己生成的对象只有自己持有
* 非自己生成的对象，自己也能持有
  * 通过`retain`方法，非自己生成的对象跟用`alloc/new/copy/mutableCopy`方法生成并持有的对象一样，成为了自己所持有的
* 不再需要自己持有的对象时释放
  * 自己持有的对象，一旦不再需要，持有者有义务释放该对象。释放使用`release`方法。
  * 自己生成而非自己所持有的对象，若用`retain`方法变为自己持有，也同样可以用`release`方法释放。
  * 用`alloc/new/copy/mutableCopy`方法生成并持有的对象，或者用`retain`方法持有的对象，一旦不再需要，务必要用`release`方法进行释放。
* 非自己持有的对象无法释放
  * 对于用`alloc/new/copy/mutableCopy`方法生成并持有的对象，或是用retain方法持有的对象，由于持有者是自己，所以在不需要该对象时需要将其释放。而由此以外所得到的对象绝对不能释放，倘若在应用程序中释放了非自己所持有的对象就会造成崩溃。

* `Objective-C`方法与对象操作的对应

Objective-C方法 | 对象操作
--- | ---
alloc/new/copy/mutableCopy等方法 | 生成并持有对象
retain方法 | 持有对象
release方法 | 释放对象
dealloc方法 | 废弃对象

Tips

```
对象的生成和持有是不同的功能

引用计数式内存管理的思考方式是理解操作 retain 和 release 的依据
```

##### 引用计数的类型

* `MRC`手动引用计数
* `ARC`自动引用计数
  * `ARC`几乎把所有内存管理事宜都交由编译器来决定，开发者只需专注于业务逻辑。引用计数式内存管理的本质没变
  * 内存管理的思考方式在`ARC`环境下是可行的，只是在**源代码的记述方法上有所不同**。不同体现在，`ARC`中追加所有权声明，引入了所有权修饰符
  * `ARC`有效时，`id`类型和对象类型同`C`语言其他类型不同，其类型上必须附加所有权修饰符(指明对象为谁所持有)
     * 所有权修饰符(从对象的所有者和对象的生命周期理解所有权修饰符的作用)
         1. `__strong`修饰符
             * `__strong`修饰符是`id`类型和对象类型默认的所有权修饰符。`id`类型和对象类型在没有明确指定所有权修饰符时，默认为`__strong`修饰符
             * `__strong`修饰符表示对对象的“强引用”。持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放
             * 附有`__strong`修饰符的变量之间可以相互赋值
             * `__strong`修饰符的变量，不仅只在变量作用域中，在赋值上也能够正确地管理其对象的所有者
             * 对象的所有者不存在时，对象会被废弃
             * 通过`__strong`修饰符，不必再次键入`retain`或者`release`，完美地满足了“引用计数式内存管理的思考方式”
         2. `__weak`修饰符
             * 用以解决循环引用。循环引用容易发生内存泄漏，内存泄漏就是应当废弃的对象在超出其生命周期后继续存在
             * `__weak`提供弱引用，弱引用不能持有对象实例
             * 在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于`nil`
             * 通过检查附有`__weak`修饰符的变量是否为`nil`，可以判断被赋值的对象是否已废弃
         3. `__unsafe_unretained`修饰符
             * 是不安全的所有权修饰符
             * 附有`__unsafe_unretained`修饰符的变量不属于编译器的内存管理对象
             * `__unsafe_unretained`的使用，是为了兼容，`iOS4`之前版本中不存在`__weak`的解决方案
         4. `__autoreleasing`修饰符
             * `ARC`有效时，要通过将对象赋值给附加了`__autoreleasing`修饰符的变量来替代调用`autorelease`方法。对象赋值给附有`__autoreleasing`修饰符的变量等价于在`ARC`无效时调用对象的`autorelease`方法，即对象被注册到`autoreleasepool`。可理解为，在`ARC`有效时，用`@autoreleasepool`块替代`NSAutoreleasePool`类，用附有`__autoreleasing`修饰符的变量替代`autorelease`方法
      * `__strong`、`__weak`、`__autoreleasing`这些修饰符，可以保证将附有这些修饰符的自动变量初始化为`nil`
      * 所有权修饰符的引入，隐藏了`retain`、`release`的添加，交由编译器去实现

##### `ARC`的规则

在`ARC`有效的情况下编译源代码，必须遵守一定的规则

* 不能使用`retain/release/retainCount/autorelease`
  * 设置`ARC`有效时，禁止再次键入`retain`或`release`代码
* 不能使用`NSAllocateObject/NSDeallocateObject`
* 须遵守内存管理的方法命名规则
  * 在`ARC`有效或无效的情况下，以`alloc/new/copy/mutableCopy`名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象
  * 在`ARC`有效的情况下，以`init`开始的方法的规则要比`alloc/new/copy/mutableCopy`更严格。`init`方法必须是实例方法，并且必须要返回对象，返回的对象应为`id`类型或该方法声明类的对象类型，抑或是该类的超类型或子类型，该返回对象并不注册到`autoreleasepool`上，基本上只是对`alloc`方法返回值的对象进行初始化处理并返回该对象
* 不要显示调用`dealloc`
  * 即不显示调用如`[super dealloc]`
* 使用`@autoreleasepool`块替代`NSAutoreleasePool`
  * `ARC`有效时，使用`@autoreleasepool`块替代`NSAutoreleasePool`
* 不能使用区域`(NSZone)`
  * 区域在现在的运行时系统中已单纯地被忽略
* 对象型变量不能作为`C`语言结构体`(struct/union)`的成员
  * `C`语言的规约上没有方法来管理结构体成员的生命周期。因`ARC`把内存管理的工作分配给编译器，所以编译器必须能够知道并管理对象的生命周期。
  * 要把对象型变量加入到结构体成员中时，可强制转换为`void *`或是附加`__unsafe_unretained`修饰符。因附有`__unsafe_unretained`修饰符的变量不属于编译器的内存管理对象
* 显示转换`id`和`void *`
  * 在`ARC`无效时，`id`和`void *`相互强制转换时，不会出问题
  * 但在`ARC`有效时，`id`和`void *`直接相互强制转换会有问题。此时`id`型或对象型变量赋值给`void *`或者逆向赋值时都需要进行特定的转换。有如下几种转换
     * `__bridge`转换 ，安全性与赋值给`__unsafe_unretained`修饰符相近，用法如
 
     ```
     id obj = [[NSObject alloc] init];
     void *p = (__bridge void *)obj;
     id o = (__bridge id)p;
     ```
     
      * `__bridge_retained`转换，可使要转换赋值的变量也持有所赋值的对象，`__bridge_retained`转换变为了`retain`

     ```
     id obj = [[NSObject alloc] init];
     void *p = (__bridge_retained void *)obj; //p持有对象obj
     ```
     
      * `__bridge_transfer`转换，被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。同`__bridge_retained`转换与`retain`类似，`__bridge_transfer`转换与`release`相似
      * 使用`__bridge_retained`、`__bridge_transfer`转换，不使用id型或对象型变量也可以生成、持有以及释放对象，但不推荐这样做
      * 这些转换多数使用在`Objective-C`对象与`Core Foundation`对象之间的相互变换中
      * `Foundation`框架的`API`生成并持有的对象可以用`Core Foundation`框架的`API`释放，反之亦然
      * 函数`CFBridgeRetain()`和`CFBridgeRelease()`，可用于`Objective-C`对象与`Core Foundation`对象之间的相互变换

##### ARC有效的情况下，属性的使用

* 属性声明的属性与所有权修饰符的对应关系

属性声明的属性 | 所有权修饰符
--- | ---
assign | __unsafe\_unretained修饰符
copy | __strong修饰符(但是赋值的是被复制的对象)
retain | __strong修饰符
strong | __strong修饰符
unsafe_unretained | __unsafe\_unretained修饰符
weak | __weak修饰符

以上各种属性赋值给指定的属性中就相当于赋值给附加各属性对应的所有权修饰符的变量中。只有`copy`属性不是简单的赋值，它赋值的是通过`NSCoping`接口的`copyWithZone:`方法复制赋值源所生成的对象