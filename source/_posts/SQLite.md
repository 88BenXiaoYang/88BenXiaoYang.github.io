---
title: SQLite
date: 2019-02-06 12:10:46
tags: 数据库
categories: 数据库
---

SQLite原生语言是C语言。SQLite数据库的所有操作都是在事务上下文内完成的。

* 事务生命周期

```
事务在哪些对象上运行，这与API直接相关，数据库写操作时，是在用一个
连接，一次一个事务。因此，所有语句的对象都是运行在派生它们自身的连
接的单个事务上下文中。
```

* 事务：读事务、写事务

```
所有的操作，写操作或者读操作，都必须经历：未加锁、待定锁、共享锁。
```

* 锁

SQLite的锁是基于标准的文件锁定实现的。SQLite在数据库文件中有三种不同的文件锁：`保留字节、待定字节、一个共享区域`。

SQLite的故障恢复机制使用保留字节来判断什么时候需要恢复数据库（涉及关键字：一致性、热日志、“回放”日志<将数据库还原到初始的被中断的事务之前的状态>）（热日志：系统异常崩溃时的日志）。热日志就是隐式的独占锁。

通过在保留状态完成所有数据库的工作，可以最小化独占状态的时间。如果在保留状态完成所有的工作，那么独占状态的持有时间只是将修改页面刷新到磁盘那么长（因不用编译更多的查询，处理更多的结果，然后写到磁盘）。在保留状态中处理，可以显著提高整体的并发性。

保留状态下，pager实际上管理三种页：`已修改页、未修改页和日志页`。日志页，就是已修改页的原始版本。

* SQLite API

SQLite API由两个基本部分组成：`核心API和扩展API`。
核心API围绕两个基本的用于执行SQL命令的**数据结构：**`连接和语句`。
命令通过三个步骤执行：`编译、执行和完成`。
SQLite的封装函数exec()和get_table()将上面三步封装成一个函数调用，自动处理相关联的语句对象。

Tips:

```
关键字：连接、句柄、事务、锁
```

##### 操作数据库

在执行SQL命令前，首先要连接数据库。连接称为打开较形象，因为SQLite数据库包含在单个操作系统文件（一个文件对应一个数据库），与此对应，断开称为关闭。打开数据库的函数的声明中的flags，作用是进一步控制数据库句柄的事务行为。

**注：在写另一个连接之前始终要调用finalize()或reset()。**

**堆上的变量需要手动释放，栈上的变量系统自动管理。**

* SQLite原生数据类型（存储类）5种：

```
integer、float、text、blob、null对应的整数值为:
integer（1）、float（2）、text（3）、blob（4）、null（5）
```

* 列类型声明

SQLite在创建表字段时，支持声明列类型和不声明列类型的情况：

```
声明列类型：即在创建字段时指明字段所在的域值类型（严格类型）；

不声明列类型：即在创建字段时不指明字段所在的域值类型，具体类型根据
插入的值进行推断确定当前的字段域值类型（动态类型）。
```

即，SQLite的显示类型声明，列可以有类型且类型可依据值来推断。

* 参数编号

SQL中的参数，位置参数从1开始，顺序使用整数值，为每个参数分配一个可唯一标识的编号。在SQL语句中给参数编号时，允许的范围是整数值1~999 。若要取得最优的性能和内存利用率，应选择较小的数字。

* 绑定函数

```
绑定函数分为两类：
一类用于标量值（int、double、int64、NULL）；
一类用于数组（blob、text、text16）。
绑定函数的区别：在于数组绑定函数需要一个长度参数和指向清理函数的指针。
```

* 三种一定要在代码中关注的情况是：`错误、繁忙情况、模式更改`。

```
繁忙处理程序的唯一局限是它们可能不会关闭数据库。
```

* 会遇到的情况

```
遇到SQLITE_BUSY时的简单处理就是重新再调用一次。
SQLITE_SCHEMA情况存在的最终原因与VDBE有关。

SQLite中与线程相关的一个限制是UNIX平台上的系统调用fork()。决不
要尝试在fork()调用中将连接传递给子进程，否则将无法正常工作。
```
