---
title: Objective-C
date: 2019-03-07 22:02:55
tags: iOS
categories: iOS
---

##### `Objective-C` 与 `Cocoa`

`Cocoa`是`Cocoa`和`Cocoa Touch`的统称。`Cocoa`是使用`Objective-C`语言开发的功能强大的用户界面工具包，里面分别包含了`OS X`和`iOS`系统的所有用户界面元素和其他所有相关内容。在开发环境`Xcode`下，使用`Objective-C`操作工具包`Cocoa`来开发应用程序。苹果为开发`OS X`和`iOS`平台上的应用程序，提供了针对`OS X`系统的`Cocoa`工具包和针对`iOS`系统的`Cocoa Touch`工具包。

##### `.m`文件

`Xcode`通过`.m`扩展名来表示文件使用的是`Objective-C`代码，应由`Objective-C`编译器处理，扩展名`.m`代表`message`，指的是`Objective-C`的消息传递特性。在`Xcode`中，编译工作默认由`LLVM`处理，这个编译器能够理解`C`语言的全部3个变体。`C`编译器处理`.c`文件，`C++`编译器处理`.cpp`文件。**Objective-C本质上就是C语言。**

##### `#import`语句

`Objective-C`使用头文件来包含结构体、符号常量和函数原型等元素的声明。在`Objective-C`语言中用`#import`语句来通知编译器查询头文件中相应的定义代码。`#import`是由`Xcode`使用的编译器`LLVM`提供的。`#import`可保证头文件只被包含一次，无论此命令在该文件中出现了多少次。

在`C`语言中，通常使用基于`#ifdef`命令的方案来避免一个文件包含另一个文件而后者又包含前者的情况。在`Objective-C`中，使用`#import`命令来实现这个功能。

##### 框架

**框架**是一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。苹果将`Cocoa`、`Carbon`、`QuickTime`和`OpenGL`等技术作为框架集来提供。`Cocoa`的组成部分有`Foundation`和`Application Kit(AppKit)`框架。**`Foundation`框架处理的是用户界面之下的那些层`(Layer)`的特性，如数据结构和通信机制。**每个框架都是一个重要的技术集合，通常包含数十个甚至上百个头文件。每个框架都有一个主头文件，它包含了框架内所有的头文件。通过在主头文件中使用`#import`，就可以访问框架内的所有功能。

Tips:

```
Foundation框架的头文件占用了近1MB的磁盘存储空间，Xcode使用预编
译头文件(一种经过压缩的、摘要形式的头文件)来加快读取速度，通过
#import导入这种文件时，加载速度会非常快。
```

##### 布尔类型`(BOOL)`

`Objective-C`中的`BOOL`实际上是一种对带符号的字符类型`(signed char)`的类型定义`(typedef)`，它使用`8`位的存储空间。通过`#define`指令把`YES`定义为`1`，`NO`定义为`0`。`Objective-C`并不会将`BOOL`作为仅能保存`YES`或`NO`值的真正布尔类型来处理。编译器仍将`BOOL`认作`8`位二进制数，`YES`和`NO`值只是在习惯上的一种理解。这样会引发一个小问题：如果不小心将一个大于`1字节`的整型值(如`short`或`int`)赋给一个`BOOL`变量，那么只有低位字节会用作`BOOL`值。如果该低位字节刚好为`0`(如`8960`，写成十六进制为`0x2300`)，`BOOL`值将会被认作是`0`，即`NO`值。

---

##### 面向对象编程`(OOP)`

面向对象编程`(Object-Oriented Programming)`，即`OOP`。`OOP`是一种编程架构，可构建由多个对象组成的软件。`Cocoa`基于`OOP`概念，`Objective-C`是面向对象的语言。

##### 间接

在代码中**通过指针间接获取某个值**，而不是直接获取。是使用数据、实现功能的一种方式。如变量与间接，就是通过间接的方式去使用变量，避免魔鬼数字的产生；文件名与间接，就是通过文件名去查询文件内容，避免查询的内容改变时需要谨慎大量的修改代码，使用间接方式此时只需要替换文件内容，而无须修改代码。

间接是`OOP`的核心，`OOP`使用间接来获取数据，如使用变量、文件和参数。`OOP`真正的革命性在于它使用间接来调用代码，不是直接调用某个函数，而是间接调用，通过指针来体现。

##### 面向过程与面向对象

过程式编程建立在函数之上，数据为函数服务，而面向对象编程则以程序的数据为中心，函数为数据服务。在`OOP`中，不再重点关注程序中的函数，而是专注于数据。在`OOP`中，数据通过间接方式引用代码，代码可以对数据进行操作。

##### `id`

`id`是一种泛型，可以用来引用任何类型的对象。对象是一种包含代码的`struct`结构体，因此`id`实际上是一个指向结构体的指针。

##### 方括号`([])`

`Objective-C`中调用方法时方括号的功能：用于通知某个对象该去做什么，方括号里的第一项是对象，其余部分是需要对象执行的操作。`Objective-C`中通知对象执行某种操作称为发送消息(亦称调用方法)。向对象发送消息后，如何调用所需的代码，需要叫做类的幕后帮手来协助完成。对象含有一个指向其类的指针(类是一种能够实例化成对象的结构体)。类含有一个指针指向类所能实现功能的代码(方法列表)。

发送消息过程中如何调用对象中适当函数的流程：

```
1.对象是消息的目标，查询消息的目标对象属于哪个类。
2.在类中查找其代码块，获取函数的地址。
3.执行函数。
```

方法调用过程中体现了间接操作的使用，该过程中最终确定调用的函数和实现的功能，由`Objective-C`在幕后(运行时)决定，它(运行时)将查询对象属于哪个类。类对象的优势：如果在运行时改变某个类，则该类的所有对象会自动继承这些变化。

##### 关键术语

```
类：是一种表示对象类型的结构体。
对象：是一种包含值和指向其类的隐藏指针的结构体，它能够通过函数指针查找与之相关的代码。
消息：是对象可以执行的操作，用于通知对象去做什么。对象接收消息后，将查询相应的类，以便找到正确的代码来运行。 
方法：是为响应消息而运行的代码。
方法调度：是Objective-C使用的一种机制(方法调度机制)，用于推测执行什么方法以响应某个特定的消息。
接口：是类为对象提供的特性描述。(接口不提供实现代码的细节信息)
实现：是使接口能正常工作的代码。

实例变量：由于对象的局部变量只在对象的实例中有效，因此称它们为实例变量，通常简写为ivar。
```

##### `@interface`和`@implementation`

`@interface`和`@implementation`都是编译器指令。

创建某个特定类的对象之前，`Objective-C`编译器需要一些有关该类的信息，尤其是对象的数据成员(即对象的`C`语言类型结构体应该是什么样子)及其提供的功能，使用`@interface`指令把这些信息传递给编译器。

`@implementation`表明将为某个类提供代码，实现在`@interface`文件中所声明的方法的定义。也可以定义在`@interface`文件中没声明过的方法，此时该方法为仅能在当前类中所使用的私有方法。

Tips:

```
Objective-C中不存在真正的私有方法，也无法把某个方法标识为私有方法，从而禁止其他代码调用它。这是Objective-C动态本质的副作用。
```

##### `self`

在`Objective-C`中调用方法时，一个名为`self`的秘密隐藏参数将被传递给接收对象，而这个参数引用的就是该接收对象(对象自身)。使用self参数后，方法可以查找并操作对象的数据。方法的实现和对象数据的模板是由对象的类定义的。`self`的传递过程是秘密和自动的。`Objective-C`运行时`(runtime)`可以将不同的对象当成隐藏的`self`参数传递，所以那些对象的实例变量发生更改时，运行时也可进行相应的更改。

##### 建立类之间的关系

建立类之间的关系有：继承、复合。

继承是在两个类之间建立关系的一种方式，它可以避免许多重复的代码。

使用复合可组合多个对象，让它们分工协作。

```
继承的类之间建立的关系为“is a”(是一个)，如果可以说“X是一个Y”，那就可以使用继承。
复合的类之间建立的关系为“has a”(有一个)，如果可以说“X有一个Y”，那就可以使用复合。
```

##### 继承

某些编程语言(如`C++`)具有多继承，也就是一个类可以直接从两个或多个类继承而来。**但`Objective-C`不支持多继承。**在`Objective-C`中可以通过类别`(category)`和协议`(protocol)`来达到多继承的效果。

如果想改变方法的实现，需要重写`(override)`继承的方法。代码运行时，`Objective-C`会确保调用的是重写过的方法。

基于继承，可以实现多态性。多态性：使用更具体种类的对象来代替一般类型，这种能力被称为多态性。

继承可以让我们在需要超类的地方使用子类。

与实例方法一样，继承对类方法也同样适用。

Tips:

```
重写方法时，调用超类方法总是一个明智之举，这样可以实现更多的功能，调用继承的方法可以确保获得方法实现的所有特性。
```

##### 方法调度

当代码发送消息时，`Objective-C`的方法调度机制将在当前的类中搜索相应的方法。如果无法在接收消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。必要时它将会在继承链的每一个类中重复地执行上述操作。如果在最顶层的`NSObject`类中也没有找到该方法，则会出现一个运行时错误，同时还会出现一个编译时`(compile-time)`警告信息。

##### 实例变量和`isa`

在创建一个新类时，，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。

`NSObject`类声明了一个名为`isa`的实例变量，该变量保存一个指向对象当前类的指针。因为继承在子类和超类之间建立了一种`“is a”`(是一个)的关系，所以`NSObject`的实例变量叫做`isa`。

每个方法调用都获得了一个名为`self`的隐藏参数，它是一个指向接收消息的对象的指针。这些方法通过`self`参数来寻找它们需要用到的实例变量。

Tips:

```
编译器使用“基地址加偏移”的机制实现奇妙的功能。有了对象基地址，即第
一个实例变量的首个字节在内存中的位置，再在该地址上加上偏移地址，编
译器就可以查找其他实例变量的位置。
```

##### `super`

为了调用继承的方法在父类中的实现，需要使用`super`作为方法调用的目标。`super`既不是参数也不是实例变量，而是由`Objective-C`编译器提供的一种功能。当向`super`发送消息时，实际上是在请求`Objective-C`向该类的超类发送消息。如果超类中没有定义该消息，`Objective-C`会继续在继承链上一级中查找。

##### 复合

在`Objective-C`中，复合是通过包含作为实例变量的对象指针实现的。只有对象间的组合才能叫做复合。

##### `new`

使用`new`创建新对象时，系统其实在后台执行了两个步骤：第一步，为对象分配内存，即对象获得一个用来存放实例变量的内存块；第二步，自动调用`init`方法，使该对象进入可用状态。

Tips:

```
为了让超类将所有需要的初始化工作一次性完成，需要调用[super init]。init方法返回的值就是被初始化的对象。将[super init]返回的结果赋给self是Objective-C的惯例。这么做是为了防止超类在初始化过程中返回的对象与一开始创建的不一致。
```

##### 存取方法：`setter`和`getter`

存取方法`(accessor)`是用来读取或改变某个对象属性的方法。`setter`方法为对象中的变量赋值；`getter`方法为代码提供了通过对象自身访问对象属性的方式。

Tips:

```
如果要对对象中的属性进行操作，应该尽量使用对象提供的存取方法，绝对不能直接改变对象里面的值。直接改变对象里面属性值的操作语法：对象->对象属性值。
```

对于存取方法，`Cocoa`有自己的命名惯例。`setter`方法根据它所更改的属性的名称来命名，并加上前缀`set`，如：`setFont:`。`getter`方法则是以其返回的属性名称命名，如：`font`。

在`Objective-C`中所有对象间的交互都是通过指针实现的。

---

##### 源代码结构

`Objective-C`类的源代码分为，接口和实现两部分。

类的`@interface`指令、公共`struct`定义、`enum`变量、`#defines`和`extern`全局变量等存放在接口部分的文件中(`.h`文件，即头文件)。

类的`@implementation`指令、全局变量的定义、私有`struct`等类的实现内容都放在实现文件中(`.m`文件，实现文件)。

导入头文件有两种方法：使用引号或者尖括号。带尖括号的语句用于导入系统头文件，而带引号的语句则说明导入的是项目本地的头文件。系统头文件对于项目来说是只读的；可对项目头文件进行编辑。

类的使用者可以通过`#import`命令导入头文件来获得该类的功能。

##### 依赖关系

导入头文件使头文件和源文件之间建立了紧密的依赖关系。如果头文件有任何变化，那么所有依赖它的文件都得重新编译。这会在需要编译的文件中引发一连串的变化。文件导入(依赖关系)过于混乱会延长编译时间，也会导致不必要的重复编译，巧妙地使用`@class`指令，可以减少必须导入的头文件的数量，从而可以缩短编译时间。

导致依赖关系问题的原因是`Objective-C`编译器需要某些信息才能够工作。有时编译器需要知道类的全部信息，例如类的实例变量配置、类所继承的所有类等，而有的时候，编译器只需要知道类名即可，不需要了解整个类的定义。

---

##### `Xcode`操作

常用快捷键：

```
导航器面板：Command + 1~7切换视图。
导航器面板的显隐：Command + 0。
代码缩进处理：选中文本 + Control + I。
左右移动代码：Command + ]右移代码；Command + [左移代码。
缩进设置：Xcode -> Preferences -> Text Editing -> Indentation。
自动补全列表的操作：显隐：esc；翻页：Control + .向后翻页，Shift + Control + .向前翻页。
方法占位符的选择：按tab键。
替换项目中指定的类名：选中指定类，右键 -> Refactor -> Rename。
快速打开某个文件：Command + Shift + O。
辅助窗口：option + command + return (用于显示一个类的两个文件<头文件.h和实现文件.m>)。
折叠代码的操作可看：Editor -> Code Folding。
查看类的说明文档：option + 在类上轻点鼠标。
可通过快速帮助查看类信息：检查器的第二个选项即是该功能，切换光标指向即可改变快速帮助的内容。
查看类的结构：Control + 6。
```

调试快捷键：

```
激活/禁用断点：Command + Y。
继续运行：Command + Control + Y。
跳过：F6。
跳入：F7。
跳出：F8。
```

操作光标的快捷键：

**不局限于在`Xcode`上使用。**

```
Control-F：光标前移(Forward)。
Control-B：光标后退(Backward)。
Control-P：光标移动到上一行(Previous)。
Control-N：光标移动到下一行(Next)。
Control-A：光标移动到行首位置。
Control-E：光标移动到行尾位置(End)。
Control-T：交换光标两边的字符(Transpose)。
Control-D：删除光标右边的字符(Delete)。
Control-K：将当前行光标以后的所有字符全部删除(Kill)。
Control-L：将光标置于窗口正中央。
```

---

##### `Foundation`

`Foundation`框架是以另一个框架`CoreFoundation`为基础创建的。`CoreFoundation`框架是用纯C语言写的。

##### 类方法

`Objective-C`运行时生成一个类的时候，会创建一个代表该类的类对象`(class object)`。类对象包含了指向超类、类名和类方法列表的指针，还包含一个`long`类型的数据，为新创建的实例对象指定大小(以字节为单位)。如果在声明方法时添加了加号`(+)`，就是把这个方法定义为类方法`(class method)`。这个方法属于类对象(而不是类的实例对象)，通常用于创建新的实例。称这种用来创建新对象的类方法为工厂方法`(factory method)`。

通常所创建的大部分方法都是实例方法，用减号`(-)`作为前缀来进行声明。

##### `NSArray`

`NSArray`类的两个限制：

```
1.它只能存储Objective-C对象，而不能存储原始的C语言基础数据类型，
如int、float enum struct NSArray中的随机指针。
2.不能在NSArray中存储nil。因为在数组列表结尾添加nil代表列表结
束，这就是不能在数组中存储nil的原因一个原因。另一个原因是在数组通
过枚举器来遍历数组元素时，是通过nextObject返回的值是否为nil值，
来判断循环是否结束。
```

`NSArray`中的对象是从零开始编制索引的，这与`C`数组的规范一样。删除对象之后，数组中并没有留下漏洞，位于被删除对象后面的数组元素都被前移来填补空缺了。

遍历数组的方法：

```
1.通过索引；
2.使用NSEnumerator(枚举器)；
3.使用快速枚举(for in语法)；
4.代码块方法(block，通过代码块可以让循环操作并发执行)。
```

上述方法的使用场景：通常使用快速枚举或代码块，因为它们简洁快速。在需要通过索引访问数组时使用索引访问。枚举器在`Objective-C 2.0`中，会自动将枚举器的循环转换成快速枚举。

Tips:

```
C语言将字符串作为简单的字符数组进行处理，并且在数组最后添加尾部的零字节作为结束标志。
```

##### `NSValue`

`NSNumber`实际上是`NSValue`的子类，`NSValue`可以封装任意值。
`valueWithBytes: objCType:`
传递的参数是要封装的数值的地址(使用操作符`&`)。可提供一个用来描述这个数据类型的字符串(通常用来说明数值的类型和大小)，不用自己写代码来生成这个字符串，`@encode`编译器指令可以接收数据类型的名称并生成合适的字符串(`@encode`指令，它用于需要描述C语言基础类型的方法)。
可以使用`NSValue`将任意值放入`NSArray`或`NSDictionary`中。

##### `NSNull`

`[NSNull null]`总是返回一样的数值，因此可以使用运算符`==`将该值与其他值进行比较。

---

##### 对象生命周期

对象的生命周期包括诞生(通过`alloc`或`new`方法实现)、生存(接收消息并执行操作)、交友(通过复合以及向方法传递参数)以及最终死去(被释放掉)。当生命周期结束时，它们的原材料(内存)将被回收以供新的对象使用。

**引用计数**，是一种用来判断管理对象生命周期是否结束的技术。每个对象都有一个与之相关联的整数，被称作对象的引用计数器。当某段代码需要访问一个对象时，该代码就将该对象的引用计数器值加`1`。当这段代码结束对象访问时，将对象的引用计数器减`1`，表示它不再访问该对象。当引用计数器的值为`0`时，表示不再有代码访问该对象了，因此它将被销毁，其占用的内存被系统回收以便重用。

当使用`alloc`、`new`方法或者通过`copy`消息创建一个对象时，对象的引用计数器值被设置为`1`。要增加对象的引用计数器的值，可以给对象发送一条`retain`消息。要减少引用计数器的值的话，可以给对象发送一条`release`消息。

当一个对象因其引用计数器归`0`而即将被销毁时，`Objective-C`会自动向对象发送一条`dealloc`消息。可在对象中重写`dealloc`方法，这样就能释放掉已经分配的全部相关资源。一定不要直接调用`dealloc`方法，`Objective-C`会在需要销毁对象时自动调用它。

##### 对象所有权

如果一个对象内有指向其他对象的实例变量，则称该对象拥有这些对象。如果一个函数创建了一个对象，则称该函数拥有这个对象。

##### 访问方法中的保留和释放

在访问方法中，先保留新对象，然后再释放对象就不会出现问题了。针对操作的对象是同一个对象的时候，尤其要如上述流程编写代码。

##### 自动释放池

自动释放池，是一个用来存放对象的池子(集合)，并且能够自动释放。

`NSObject`类提供了一个叫做`autorelease`的方法：`- (id) autorelease;`。该方法预先设定了一条会在未来某个时间发送的`release`消息，其返回值是接收这条消息的对象。当给一个对象发送`autorelease`消息时，实际上是将该对象添加到了自动释放池中。当自动释放池被销毁时，会向该池中的所有对象发送`release`消息。

自动释放池以栈的形式实现：当你创建了一个新的自动释放池时，它就被添加到栈顶。接收`autorelease`消息的对象将被放入最顶端的自动释放池中。**如果将一个对象放入一个自动释放池中，然后创建一个新的自动释放池，再销毁该新建的自动释放池，则这个自动释放池对象仍将存在，因为容纳该对象的自动释放池仍然存在。**

Tips:

手动实现自动释放池的参考思路：

```
可以使用NSMutableArray来编写自己的自动释放池，以容纳对象并在dealloc方法中向池中的所有对象发送release消息。
```

当对象接收到一条`autorelease`消息时，其引用计数器的值并不会发生改变。

##### 自动释放池的销毁时间

有两种方法可以创建一个自动释放池：

```
1.通过@autoreleasepool关键字。
2.通过NSAutoreleasePool对象。
```

在`Foundation`库工具集中，创建和销毁自动释放池已经由`@autorelease`关键字完成。

当使用`@autorelease{}`时，所有在花括号里的代码都会被放入这个新池子里。这种情况下，任何在花括号里定义的变量在括号外就无法使用了。

第二种方法是使用`NSAutoreleasePool`对象。使用这种方法，创建和释放`NSAutoreleasePool`对象之间的代码就会使用这个新池子。创建了一个自动释放池后，该池就会自动成为活动的池子。释放该池后，其引用计数器的值归`0`，然后该池被销毁。在销毁的过程中，该池将释放其包含的所有对象。

销毁自动释放池中对象的方式：`-drain`：该方法只是清空自动释放池而不会销毁自动释放池。自己编写的代码中，使用`-release`方法，以兼容更古老的版本。

对同一对象而言，其销毁的过程中，在收到`release`消息将其引用计数器的值减少为`0`时，其`dealloc`方法被调用。

##### `Cocoa`的内存管理规则

> 1.当使用`new`、`alloc`或`copy`方法创建一个对象时，该对象的引用计数器的值为`1`。当不再使用该对象时，应该向该对象发送一条`release`或`autorelease`消息。这样，该对象将在其使用寿命结束时被销毁。
> 
> 2.当通过其他方法获得一个对象时，假设该对象的引用计数器的值为`1`，而且已经被设置为自动释放，那么不需要执行任何操作来确保该对象得到清理。如果打算在一段时间内拥有该对象，则需要保留它并确保在操作完成时释放它。
>
> 3.如果保留了某个对象，就需要释放或自动释放该对象。必须保持`retain`方法和`release`方法的使用次数相等。

无论什么时候拥有一个对象，有两件事必须弄清楚：

```
怎样获得该对象的？
打算拥有多长时间？
```

内存管理规则：

获得途径 | 临时对象 | 拥有对象
--- | --- | ---
alloc/new/copy | 不再使用时释放对象 | 在dealloc方法中释放对象
其他方法 | 不需要执行任何操作 | 获得对象时保留，在dealloc方法中释放对象

##### 事件循环

一个典型的图形应用程序往往花费许多时间等待用户操作。在控制程序运行的用户作出决定(如按下某个键)以前，程序将一直处于空闲状态。当发生如按下某个键的事件时，程序将被唤醒并开始工作，执行必要的操作以响应这一事件。在处理完这一事件后，程序返回到休眠状态并等待下一个事件发生。上述过程即为事件循环。(底层是通过`do-while`控制的)。

**为了降低程序的内存空间占用，`Cocoa`会在程序开始处理事件之前创建一个自动释放池，并在事件处理结束后销毁。这样可以尽量减少累积的临时对象的数量。**

如果使用除`alloc`、`new`或`copy`以外的方法获得了一个对象，需要记得保留该对象。如果编写的是`GUI`应用程序，要考虑到事件循环。需要保留自动释放的对象，以便这些对象在当前的事件循环结束以后仍能继续存在。在这种情况下，需要在执行保留操作的对象中的`dealloc`方法中释放它，以便它被清理掉。

自动释放池被清理的时间是完全确定的：

```
要么是在代码中程序员自己手动销毁；
要么是使用AppKit时在事件循环结束时销毁。(在调用函数的过程中自动释放池不会被销毁)
```

##### 内存管理机制的实现

> 垃圾回收，针对`OS X`应用程序。
> 
> 自动引用计数`(ARC)`，针对`iOS`应用程序。

**垃圾回收和`ARC`是无法一同使用的。**

##### 垃圾回收

`Objective-C 2.0`引入了自动内存管理机制，也称垃圾回收。启用垃圾回收以后，平常的内存管理命令全都变成了空操作指令。垃圾回收器定期检查变量和对象并且跟踪它们之间的指针，当发现没有任何变量指向某个对象时，就将该对象视为应该丢弃的垃圾。与自动释放池一样，垃圾回收器也是在事件循环结束时触发的。**垃圾回收功能只支持OS X应用开发，无法用在iOS应用程序上。**垃圾回收器在运行时工作，通过返回的代码来定期检查对象。

在支持垃圾回收的`Objective-C`中，`dealloc`方法无效，如果需要在销毁对象时执行某些操作，则需要重写`-finalize`方法，当对象最终被回收时该方法会被调用。

##### 自动引用计数`(ARC)`

在`iOS`中无法使用垃圾回收，主要原因是无法知道垃圾回收器什么时候会起作用。垃圾回收机制会对移动设备的可用性产生不利的影响，因为移动设备比电脑更私人化，资源更少。用户可不想在打电话的时候因为系统突然进行内存清理而卡住。

实现与垃圾回收功能相同的移动端解决方案为**自动引用计数`(automatic reference counting，ARC)`。**`ARC`会追踪你的对象并决定哪一个仍会使用，而哪一个不会再用到。如果启用了`ARC`，编译器会帮你插入`retain`和`release`语句。

`ARC`不是垃圾回收器，垃圾回收器在运行时工作，通过返回的代码来定期检查对象。`ARC`是在编译时进行工作的，`ARC`在代码中插入了合适的`retain`和`release`语句，完成了内存管理的工作。

注意：

```
ARC只对可保留的对象指针(ROPs)有效。可保留的对象指针主要有以下三种：
1.代码块指针
2.Objective-C对象指针
3.通过__attribute__((NSObject))类型定义的指针

所有其他的指针类型，如char *和CF对象(如CFStringRef)都不支持ARC
特性。如果使用的指针不支持ARC，那么将不得不亲自手动管理它们。ARC
可以与手动的内存管理共同发挥作用。
```

使用`ARC`的时候有两种命名规则需要注意：
> 1.属性名称不能以`new`开头。
> 
> 2.属性不能只有一个`read-only`而没有内存管理特性。默认的特性是`assign`(`assign`只是基础类型的赋值描述)，进行简单的修复，使用`unsafe_unretained`(`unsafe_unretained`有对象所用权的描述特性)就可以了。

**`ARC`转换是一个单程的操作，一旦转换成`ARC`版本，就不可以恢复了。**

`ARC`是基于文件进行工作的。

##### `ARC`-内存泄漏

程序无法访问到对象，但它们仍占用着内存容量。循环引用场景下会出现内存泄漏的情况。

##### `ARC`-归零弱引用

归零弱引用`(zeroing weak reference)`，不会使所引用的对象的引用计数器的值增加，同时在所引用的对象被释放时，归零弱引用就会被设置为`nil`。

如果想要使用归零弱引用，必须明确地声明它们。有两种方式可以声明归零弱引用：
> 1.声明变量时使用`__weak`关键字。
> 
> 2.对属性使用`weak`特性。

想在不支持弱引用的旧系统上使用`ARC`，使用`__unsafe_unretained`关键字和`unsafe_unretained`特性，这样`ARC`便知道这个特殊的引用是弱引用。

**注意：内存管理的关键字和特性是不能一起使用的，两者相互排斥。**

##### `ARC`-拥有者权限

指针支持`ARC`的一个条件是必须是可保留对象指针`(ROP)`。即不能简单地将一个`ROP`表示成不可保留对象指针`(non-ROP)`，因为指针的所有权会移交。在可保留对象指针`(ROP)`和不可保留对象指针`(non-ROP)`共同存在且相互有“交流”的情况下，为了让`ARC`便于工作，需要告诉编译器哪个对象是指针的拥有者。为此使用桥接转换`(bridged cast)`的`C`语言技术，这是一个标准的`C`语言类型转换，使用关键字：`__bridge`、`__bridge_retained`和`__bridge_transfer`。`bridge`指的是使用**不同的数据类型**达到**同一目的**的能力。

桥接转换类型：`__bridge`、`__bridge_retained`和`__bridge_transfer`的功能如下：

> `(__bridge类型)`操作符：这种类型的转换会传递指针但不会传递指针的所有权。
> 
> `(__bridge_retained类型)`操作符：使用这种类型，所有权会转移到`non-ROP`上。这个转换类型会给对象的引用计数器的值加`1`，所以在代码中要让它减`1`。因为`ARC`只会注意到`ROP`，所以要在不用的时候释放它。
> 
> `(__bridge_transfer类型)`操作符：这种转换类型与上一个相反，它把所有权转交给`ROP`。

桥接技术的使用场景：

结构体`(struct)`和集合体`(union)`不能使用ROP作为成员，因此下面的代码是不被允许的：

```
//Bad code.
struct {
	int32_t foo;
	char *bar;
	NSString *baz; //ROP成员
} MyStruct;
```

可以通过使用void *和桥接转换来解决这个问题。如想要分配并获取字符串，可使用如下代码：

```
struct {
	int32_t foo;
	char *bar;
	void *baz;
} MyStruct;
MyStruct.baz = (__bridge_retained void *)ropString;
NSString *myString = (__bridge_transfer NSString *)MyStruct.baz;
```

不能对`ARC`管理的对象**调用**的管理方法：

```
retain
retainCount
release
autorelease
dealloc
```

可以重写`dealloc`方法，因为有时需要释放不支持`ARC`的对象或执行其他清理操作，但是不能直接调用`[super dealloc]`。

不能对`ARC`对象进行**重写**的方法：

```
retain
retainCount
release
autorelease
```

##### 与异常有关的关键字

```
@try：定义用来测试的代码块以决定是否要抛出异常。
@catch：定义用来处理已抛出异常的代码块。接收一个参数，通常是NSException类型。
@finally：定义无论是否有抛出异常都会执行的代码块，这段代码总是会执行的。
@throw：抛出异常。
```

注：与当前`@catch`异常处理代码相关的`@finally`代码块会在`@throw`引发下一个异常处理调用之前执行代码，因为`@finally`是在`@throw`发生之前调用的。

##### 对象的分配和初始化

在`Cocoa`中，分配和初始化是两个分离的操作：来自`NSObject`的类方法`alloc`为对象分配一块内存区域并将其清零，实例方法`init`用于获得一个对象并使其运行。

##### 属性

`@property`是一种新的编译器功能，它意味着声明了一个对象的新属性。`@property`预编译指令的作用是自动声明属性的`setter`和`getter`方法。通常属性的名称与实例变量的名称相同。

Tips:

```
@synthesize是一种编译器功能，它表示“创建了该属性的访问代码”。访问代码指setter、getter方法。当遇到@synthesize代码时，编译器将添加实现对应的setter和getter方法的预编译代码。Xcode4.5以后的版本不必使用@synthesize了。

@synthesize预编译指令实现的setter和getter代码是看不到的，但是这些方法确实存在并可以被调用。
```

所有的属性都是基于变量的，所以在合成`(synthesize)``getter`和`setter`方法的时候，编译器会自动创建与属性名称相同的实例变量。如果没有声明这些变量，编译器也会声明的。有两个地方可以用来添加实例变量声明：头文件和实现文件。如果想要其他对象访问到实例变量，则声明在头文件中，反之声明在实现文件中。

点表达式`(.)`只是调用访问方法的一种便捷方式。

##### 属性特性的使用规则

属性的特性(`copy`、`retain`等)，表明属性会具有怎样的行为。

`nonatomic`声明，如果不在多线程中使用，这个声明可以提高访问方法的调用速度。

如果没有为属性指定任何特性，它们会默认使用`nonatomic`和`assign`。可以为可保留的指针(即`Objective-C`对象)指定`retain`和`copy`特性，而其他`C`类型和不可保留的指针必须使用`assign`特性并且要手动来管理内存。属性默认是可读写的。

如果自己定义了`setter`或`getter`方法，那么就不能使用`atomic`特性了，必须使用`nonatomic`特性。

在使用属性的过程中，如果不想要编译器为你创建变量、`getter`和`setter`方法，可以使用关键字`@dynamic`来告诉编译器不要生成该属性任何代码或创建相应的实例变量。

有时想要换掉默认生成的方法名称，可以指定编译器生成的`getter`和`setter`方法的名称，使用`getter=`和`setter=`特性就可以自定义想要的方法名称。如果这样做的话，需要注意会破坏键/值规则，因此除非有必须使用这些特性的原因，否则请尽量避免使用。

##### 类别`(category)`

类别是`Objective-C`允许你扩展现有的类(即使没有这些类的源代码)的方式。是一种为现有的类添加**新方法**的方式。利用`Objective-C`的动态运行时分配机制，可以为现有的类添加新方法。

可以在类别中添加属性，但不能添加实例变量，而且属性必须是`@dynamic`类型的。添加属性的好处在于可以通过点表达式来访问`setter`和`getter`方法。

类别有两个局限性：

> 第一是无法向类中添加新的实例变量。类别没有空间容纳实例变量。
> 
> 第二个就是名称冲突，也就是类别中的方法与现有的方法重名。当发生名称冲突时，类别具有更高的优先级。类别方法将完全取代初始方法，导致初始方法不再可用。

类别的主要三个用途：

> 将类的实现代码分散到多个不同文件或框架中；
> 
> 创建对私有方法的前向引用；
> 
> 向对象添加非正式协议`(informal protocol)`。

类别可以访问其继承的类的实例变量。类别的方法具有更高的优先级。

`run`循环(`runloop`)是一种`Cocoa`概念，它在等待某些事情发生之前一直处于阻塞状态，即不执行任何代码。

创建一个`NSObject`的类别称为“创建一个非正式协议”。协议是一组管理通信的规则。非正式协议的方法，是可选择实现`(@optional)`的方法。

##### 类扩展

类扩展是一个特殊的类别。

类扩展的特点：

> 它不需要名字；
> 
> 可以在包含源代码的类中使用它；
> 
> 可以添加实例变量；
> 
> 可以将只读权限改成可读写的权限；
> 
> 创建的数量不限。

类扩展名称的由来：因这部分代码没有继承的父类，基本上就是获取当前(目标)的类，并通过添加私有属性和方法来扩展当前(目标)类。

##### 选择器

选择器只是一个方法名称，它以Objective-C运行时使用的特殊方式编码，以快速执行查询。可以使用@selector()编译指令圆括号中的方法名称来指定选择器。

##### 正式协议

正式协议要求显式地采用，采用协议的办法是在类的`@interface`声明中列出协议的名称。

可以继承父协议。在声明语句协议名称后面的尖括号内可以指定父协议的名称。语法如：

```
@protocol customProtocolName <继承的父协议名称>
@end
```

##### 复制

`zone`是`NSZone`类的一个对象，指向一块可供分配的内存区域。当向一个对象发送`copy`消息时，该`copy`消息在到达目标对象代码之前会被转换为`copyWithZone:`方法。

`copyWithZone:`方法的首要任务是获得`self`参数所属的类，然后向`self`对象所属的类发送`allocWithZone:`消息，以分配内存并创建一个该类的新对象。

可以使用C语言风格的指针运算符直接访问实例变量。如：`obj->variate = newvVariate`。

##### 协议和数据类型

如果一个用尖括号括起来的协议名称跟随在`id`之后，则编译器将知道你会接受任意类型的对象，但前提是要遵守该协议。

##### 代码块

一个可以增强函数功能的`Objective-C`特性。代码块实际上是由`C`语言实现的。

代码块对象(简称代码块)，是对`C`语言中函数的扩展。除了函数中的代码，代码块还包含变量绑定。代码块包含两种类型的绑定：自动型与托管型。自动绑定使用的是栈中的内存，而托管绑定是通过堆创建的。

代码块可以访问与它相同的有效范围内声明的变量，也就是说代码块可以访问与它同时创建的有效变量。

##### 代码块和变量

代码块被声明后会捕捉创建点时的状态。代码块可以访问函数用到的标准类型的变量：

> 全局变量，包括在封闭范围内声明的本地静态变量。这种类型的变量值改变了，代码块内对应的变量值也同步改变了。
> 
> 全局函数。
> 
> 封闭范围内的参数。
> 
> 函数级别(即与代码块声明时相同的级别)的`__block`变量。`__block`修饰的变量是可以修改的变量。
> 有些变量是无法声明为`__block`类型的。它们有两个限制：
> 1.没有长度可变的数组；
> 2.没有包含可变长度数组的结构体。
> 
> 封闭范围内的非静态变量会被获取为常量。本地变量，因为变量是本地的，代码块会在定义时复制并保存它们的状态。(本地变量会被代码块作为常量获取到)。
> 
> `Objective-C`的实例变量。
> 
> 代码块内部的本地变量。

在代码块中访问`Objective-C`变量时必须小心，因为涉及到内存管理问题。

代码块访问`Objective-C`变量时，处理内存管理的规则：

> 如果引用了一个`Objective-C`对象，必须要保留它。
> 
> 如果通过引用访问了一个实例变量，要保留一次`self`(即执行方法的对象)。
> 
> 如果通过数值访问了一个实例变量，变量需要保留。

因为代码块是对象，所以可以向它发送任何与内存管理有关的消息。在`C`语言级别中，必须使用`Block_copy()`和`Block_release()`函数来适当地管理内存。

##### 并发性

能够在**同一时间**执行**多项任务**的程序称为并发的程序。编写并发性程序需要创建多个线程。

为了减轻在多核上编程的负担，苹果公司引入了`GCD`技术。如果想要使用`GCD`，需要提交代码块或函数作为线程来运行。

`GCD`是一个系统级别`(system-level)`的技术，因此你可以在任意级别的代码中使用它。`GCD`决定需要多少线程并安排它们运行的进度。因为`GCD`是运行在系统级别上的，所以可以平衡应用程序所有内容的加载，这样可以提高计算机或设备的执行效率。

##### 同步

同步思想：对临界区资源添加一个标记(flag)或一个互斥(mutex)机制，确保两个线程不会在同一时间进入临界区。

`Objective-C`提供了一个语言级别的关键字`@synchronized`。它可以确保不同的线程会连续地访问临界区的代码。这样可以使线程间对临界区的代码进行同步操作。

`nonatomic`与`atomic`对属性性能的影响：

```
若定义了一个属性并且指定关键字atomic作为属性的特性，此时编译器会生成强制彼此互斥的getter和setter方法，因编译器生成了@synchronize(mutex, atomic)语句来确保彼此互斥，这样设置代码和变量会产生一些消耗，会比直接访问更慢一些。因此若知道属性值不会被多个线程访问的话，可以添加nonatomic特性，这样做可以提高性能。
```

##### 简单的后台执行

`NSObject`提供了在后台执行代码的方法，能让一些代码在后台执行。这些方法的名字中都有`performSelector:`，它们通过创建一个线程来运行方法。`(NSThread)`

定义在后台运行的方法须遵从以下限制：

> 这些方法运行在各自的线程里，因此必须为这些`Cocoa`对象创建一个自动释放池。主自动释放池是与主线程相关的。
> 
> 这些方法不能有返回值，并且要么没有参数，要么只有一个参数对象。

当方法执行结束后，`Objective-C`运行时会特地清理并弃掉线程。方法执行结束后并不会通知你(如何自己实现方法执行结束后发出通知!!!)。

##### 后台执行复杂的操作

`GCD`可以使用调度队列`(dispatch queue)`，只需写下目标代码，把它指派给一个队列，系统就会执行它了。队列对象：`dispatch_queue_t`。

有以下`3`种类型的调度队列：

> 连续队列：每个连续队列都会根据指派的顺序执行任务。可以创建任意数量的队列，它们会并行操作任务。连续队列，任务执行顺序为先进先出`(FIFO)`：只要任务是异步提交的，队列会确保任务根据预定顺序执行。这些队列都是不会发生死锁的。连续队列创建的方法为：`dispatch_queue_create()`。连续队列的创建涉及到内存管理。
> 
> 并发队列：每个并发队列都能并发执行一个或多个任务。任务会根据指派到队列的顺序开始执行。无法创建并发队列，只能从系统提供的`3`种并发队列内选择一个来使用(`3`种并发队列：高优先级`(high)`、默认优先级`(default)`、低优先级`(low)`)。并发队列也遵从先进先出`(FIFO)`的规范。一次所运行的任务数量是无法预测的。每个应用程序都有上述`3`种并发队列可以使用。要使用它们，调用`dispatch_get_global_queue`方法，根据需要传入对应的参数，指定队列的优先级。并发队列都是全局的，所以无需为它们管理内存。
> 
> 主队列：它是应用程序中有效的主队列，执行的是应用程序的主线程任务。使用`dispatch_get_main_queue`可以访问与应用程序主线程相关的主队列。通常要以同步方式使用这个队列，提交多个任务并在它们操作完毕后执行一些操作。

可以通过调用`dispatch_get_current_queue()`来获取代码块当前所在的队列类型，即代码块所在的当前队列。如果在代码块对象之外调用了`dispatch_get_current_queue()`函数，则它将会返回主队列。

##### 调度队列的内存管理

调度队列是引用计数对象。使用`dispatch_retain()`和`dispatch_release()`来修改队列的引用计数器的值。只能对自己创建的队列使用这些函数，而无法用在全局调度队列上。

队列的上下文：

> 系统只能知道上下文包含了与队列有关的数据，上下文数据的内存管理只能由你来做。你必须在需要它的时候分配内存并在队列销毁之前进行清理。在为上下文数据分配内存的时候，可以使用`dispatch_set_context()`和`dispatch_get_context()`函数。

##### 添加任务

有两种方式可以向队列中添加任务：

> 同步：队列会一直等待前面任务结束。
> 
> 异步：添加任务后，不必等待任务，函数会立即返回。推荐优先使用这种方式，因为它不会阻塞其他代码的运行。

可以选择向队列提交代码块或函数。

##### 调度程序

调度程序需要使用调度函数，将任务添加到调度队列里。

调度函数有4个，分别是代码块和函数各自的同步与异步方式。(同步：dispatch_sync、dispatch_sync_f；异步：dispatch_async、dispatch_async_f)

添加任务可以通过代码块或函数。添加任务的最简单的方法是通过代码块。代码块必须是dispatch_block_t这样的类型，要定义为没有参数和返回值才行。如：typedef void (^dispatch_block_t)(void)。

也可以向队列中添加函数，函数的标准原型必须要像如下这样：void function_name(void *argument)。

队列创建完之后，就做好接收任务的准备了。当我们添加了一个任务，队列就会安排好它的进度。

暂停队列：dispatch_suspend();

重新启用队列：dispatch_resume();

##### 操作队列

操作(operation)API的使用，可以让队列在Objective-C层级上使用起来更加简单。(NSOperation)。

操作对应于任务；操作队列对应于调度队列。

如果想要使用操作，首先需要创建一个操作对象，然后将其指派给操作队列，并让队列执行它。

有3种创建操作的方式：

> `NSInvocationOperation`：如果已经拥有一个可以完成工作的类，并且想要在队列上执行，可使用这种方法。NSInvocationOperation会为执行任务的类调用选择器。
> 
> `NSBlockOperation`：像包含了需要执行代码块的dispatch_async函数。
> 
> 自定义的操作：根据需要可以创建自己的自定义类型。必须通过`NSOperation`子类来定义自己的操作。

`NSOperationQueue`一般会并发执行操作。它具有相关性，因此如果某操作是基于其他操作的，它们会相应地执行。

一旦向队列中添加了操作，它就会被安排进度并执行。

如果经常要使用并发任务，应避免发生死锁(任务互相关联导致程序永远无法结束)。

---

##### 图形框架介绍

`OS X`

通常在`Xcode`中为新创建的类添加前缀，因为`Objective-C`中没有命名空间，它用的是一种伪命名空间的方法，将应用程序中的一些名称储存起来了。`Xcode`内置了`Subversion(SVN)`和`Git`的源代码管理功能。

`nib`是`NeXT Interface Builder`的首字母缩写，是`Cocoa`从`NeXT`公司沿袭下来的技术结晶。使用中将`.xib`文件称为`nib`文件。`nib`件是包含了压缩对象的二进制文件，而`.xib`文件是`XML`格式的`nib`文件，在编译时，`.xib`文件将会编辑为`nib`格式。

`IBOutlet`的工作机制：

> 在加载`nib`文件时(创建项目时创建的如`mainxxx.nib`文件会在应用程序启动时自动加载)，存储在`nib`文件中的任何对象都会被重新创建。这意味着会在后台执行`alloc`和`init`方法。所以，当应用程序启动时，会分配并初始化一个`AppDelegate`实例。在执行`init`方法期间，所有`IBOutlet`实例变量都是`nil`。只有在生成了`nib`文件中的所有对象(如按钮等)后，所有连接才算完成。一旦建立了所有连接(也就是将`nib`中控件等对象的地址添加到`AppDelegate`的实例变量中)，就会向创建的每个对象发送消息`awakeFromNib`。需注意，对象的创建和`awakeFromNib`消息的发送没有任何既定的顺序。
> 
> 在`nib`项目中，在`awakeFromNib`方法中操作是最“稳妥”的，因此时对象已经创建并初始化完毕。对应于`iOS`中的`viewDidLoad`方法。

`iOS`

`iOS`没有命令行使用权。所有的应用程序都是在主窗口内运行的。视图控制器会在`nib`文件加载和对象初始化完成后调用`viewDidLoad`方法。

`iOS`不支持虚拟内存，应用程序只能使用设备中可用的内存。

`viewDidLoad`和`viewDidUnLoad`在视图的生命周期内只会调用到一次。

---

##### 文件处理

`Cocoa`提供了两个处理文件的通用类：属性列表和对象编码。

属性列表能存储：`NSArray`、`NSDictionary`、`NSString`、`NSNumber`、`NSDate`和`NSData`。

`NSTimeInterval`以秒为单位。

可以在终端查看`ASCII`表：在终端键入`man ascii`

##### 编码与解码

`Cocoa`具备一种将对象转换成某中格式并保存到磁盘中的机制。对象可以将它们的实例变量和其他数据编码为数据块，然后保存到磁盘中。这些数据块以后还可以读回内存中，并且还能基于保存到数据创建新对象。这个过程被称为编码与解码，也可以称为序列化与反序列化。

编码器的使用，`NSCoder`是一个抽象类，实现编码解码功能的是其子类，如`NSKeyedArchiver`和`NSKeyedUnarchiver`。

当使用`NSKeyedArchiver`和`NSKeyedUnarchiver`对对象进行编码解码时，会对应的调用`NSCoding`协议中的`encodeWithCoder`和`initWithCoder`的编码解码方法，因此对象若想实现编码解码功能，对应的类须遵从`NSCoding`协议，并实现`encodeWithCoder`和`initWithCoder`方法。使用时`NSKeyedArchiver`调用`archivedDataWithRootObject`进行编码；`NSKeyedUnarchiver`调用`unarchivedObjectOfClass`进行解码。

使用编码解码可以将大量对象转换成`NSData`，然后保存到磁盘中供以后读取。通过这种`NSData`，可以重新创建对象。

##### 键/值编码`(KVC)`

`KVC`，其实现方法是使用字符串表示要更改的对象状态。

键/值编码中的基本调用是`valueForKey`和`setValueForKey`方法。可以向对象发送消息，并传递想要访问的属性名称(即，键)作为参数。

`valueForKey`(检索值)的功能实现：

> `valueForKey:`会首先查找以参数名命名(格式为`-key`或`-isKey`)的`getter`方法。如果没有这样的`getter`方法，它将会在对象内寻找名称格式为`_key`或`key`的实例变量。`valueForKey`在`Objective-C`运行时中使用元数据打开对象并进入其中查找需要的信息。

通过使用`KVC`，没有相关`getter`方法也能获取对象值，不需要通过对象指针来直接访问实例变量。

对于`KVC`，`Cocoa`会自动装箱和开箱标量值。即，当使用`setValueForKey`时，它自动将标量值(`int`、`float`和`struct`)放入`NSNumber`或`NSValue`中；当使用`setValueForKey`时，它自动将标量值从这些对象中取出。仅`KVC`具有这种自动装箱功能，常规方法调用和属性语法不具备该功能。

`setValueForKey`(设置值)的功能实现：

> `setValueForKey`的工作方式和`valueForKey`相同。它首先查找名称的`setter`方法，如`-setKey`，然后调用它并传递参数。如果不存在`setter`方法，它将在类中寻找名为`key`或`_key`的实例变量，然后为它赋值。

如想设置一个标量值，在调用`setValueForKey`方法之前需要将标量值包装起来，即装箱到对象中。在对对象进行`setValueForKey`时，`setValueForKey`方法会先开箱取出该值，再调用对应的`setter`方法或更改对应的实例变量。

Tips:

```
编译器和苹果公司都以下划线开头的形式保存实例变量名称。
```

除了通过键设置值之外，键/值编码还支持指定键路径。对应的方法为：`valueForKeyPath`和`setValueForKeyPath`。

关于`KVC`常用的一点，如果使用某个键值来访问一个`NSArray`数组，它实际上会查询相应数组中的每个对象，然后将查询结果打包到另一个数组中并返回。这种方法也同样适用于通过键路径访问的位于对象中的数组。

将`valueForKey:`发送给数组时，键将作用于数组中的所有元素。

`key`部分的字符串值区分大小写。

##### 键路径的优点

键路径，它们是由点分割的键，用于在对象的网络中指定路径。

键路径不仅能引用对象值，还可以引用一些运算符来进行一些运算。

不要滥用`KVC`，因为`KVC`需要解析字符串来计算需要的答案，因此速度比较慢。此外，编译器还无法对它进行错误检查，因此编译器不能辅助判断错误。

##### 批处理

`KVC`包含两个调用，可以使用它们为对象进行批量更改。这两个方法是：`dictionaryWithValuesForKeys`(它接收一个字符串数组，该调用获取键的名称，并对每个键使用`valueForKey`方法，然后为键字符串和刚获取的值构建一个字典)和`setValuesForKeysWithDictionary`。

在使用`KVC`的过程中可根据错误提示信息对程序进行优化。如提示中含有`setNilValueForKey`，则是当前类没有对设置为`nil`时作兼容处理，此时在类中重写`setNilValueForKey`并作相应处理即可。类似情况可以处理未定义的键，同样重写`valueForUndefinedKey`和`setValue:forUndefinedKey`。

在使用`KVC`的`setValue:forKey:`方法时，通过这种方法，调用者可以直接传入`nil`值，不必在代码中检查它。而如果使用`NSDictionary`的`setObject:forKey:`方法时，提供`nil`值，会报警告信息。如果在字典中对`setValue:forKey:`方法传入`nil`值，字典会把对应键的值给删除。

`<null>`与`(null)`的区别：

```
<null>是一种[NSNull null]对象，而(null)是一个真正的nil值。
```

---

##### 静态分析器`(static analyzer)`

静态分析器，是一个不需要运行程序就可以从逻辑上检测代码的工具。静态分析器不是简单的浏览一遍源代码，而是在应用程序的代码通道中查找逻辑错误并反馈给你。

静态分析器可分析的几种错误：

> 安全问题，如内存泄漏和缓冲区溢出。
> 
> 并发性问题，如静态条件(即依赖时间的两个或多个任务失败)。
> 
> 逻辑问题，包括废代码和不好的编码习惯。

使用静态分析器的快捷键：`Command + shift + B`。

使用`NSPredicate`(谓词)类来过滤集合中的对象。