---
title: Objective-C
date: 2019-03-07 22:02:55
tags: iOS
categories: iOS
---

* `Objective-C` 与 `Cocoa`

`Cocoa`是`Cocoa`和`Cocoa Touch`的统称。`Cocoa`是使用`Objective-C`语言开发的功能强大的用户界面工具包，里面分别包含了`OS X`和`iOS`系统的所有用户界面元素和其他所有相关内容。在开发环境`Xcode`下，使用`Objective-C`操作工具包`Cocoa`来开发应用程序。苹果为开发`OS X`和`iOS`平台上的应用程序，提供了针对`OS X`系统的`Cocoa`工具包和针对`iOS`系统的`Cocoa Touch`工具包。

* `.m`文件

`Xcode`通过`.m`扩展名来表示文件使用的是`Objective-C`代码，应由`Objective-C`编译器处理，扩展名`.m`代表`message`，指的是`Objective-C`的消息传递特性。在`Xcode`中，编译工作默认由`LLVM`处理，这个编译器能够理解`C`语言的全部3个变体。`C`编译器处理`.c`文件，`C++`编译器处理`.cpp`文件。**Objective-C本质上就是C语言。**

* `#import`语句

`Objective-C`使用头文件来包含结构体、符号常量和函数原型等元素的声明。在`Objective-C`语言中用`#import`语句来通知编译器查询头文件中相应的定义代码。`#import`是由`Xcode`使用的编译器`LLVM`提供的。`#import`可保证头文件只被包含一次，无论此命令在该文件中出现了多少次。

在`C`语言中，通常使用基于`#ifdef`命令的方案来避免一个文件包含另一个文件而后者又包含前者的情况。在`Objective-C`中，使用`#import`命令来实现这个功能。

* 框架

**框架**是一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。苹果将`Cocoa`、`Carbon`、`QuickTime`和`OpenGL`等技术作为框架集来提供。`Cocoa`的组成部分有`Foundation`和`Application Kit(AppKit)`框架。**`Foundation`框架处理的是用户界面之下的那些层`(Layer)`的特性，如数据结构和通信机制。**每个框架都是一个重要的技术集合，通常包含数十个甚至上百个头文件。每个框架都有一个主头文件，它包含了框架内所有的头文件。通过在主头文件中使用`#import`，就可以访问框架内的所有功能。

Tips:

```
Foundation框架的头文件占用了近1MB的磁盘存储空间，Xcode使用预编
译头文件(一种经过压缩的、摘要形式的头文件)来加快读取速度，通过
#import导入这种文件时，加载速度会非常快。
```

* 布尔类型`(BOOL)`

`Objective-C`中的`BOOL`实际上是一种对带符号的字符类型`(signed char)`的类型定义`(typedef)`，它使用`8`位的存储空间。通过`#define`指令把`YES`定义为`1`，`NO`定义为`0`。`Objective-C`并不会将`BOOL`作为仅能保存`YES`或`NO`值的真正布尔类型来处理。编译器仍将`BOOL`认作`8`位二进制数，`YES`和`NO`值只是在习惯上的一种理解。这样会引发一个小问题：如果不小心将一个大于`1字节`的整型值(如`short`或`int`)赋给一个`BOOL`变量，那么只有低位字节会用作`BOOL`值。如果该低位字节刚好为`0`(如`8960`，写成十六进制为`0x2300`)，`BOOL`值将会被认作是`0`，即`NO`值。

---

##### 面向对象编程`(OOP)`

面向对象编程`(Object-Oriented Programming)`，即`OOP`。`OOP`是一种编程架构，可构建由多个对象组成的软件。`Cocoa`基于`OOP`概念，`Objective-C`是面向对象的语言。

* 间接

在代码中**通过指针间接获取某个值**，而不是直接获取。是使用数据、实现功能的一种方式。如变量与间接，就是通过间接的方式去使用变量，避免魔鬼数字的产生；文件名与间接，就是通过文件名去查询文件内容，避免查询的内容改变时需要谨慎大量的修改代码，使用间接方式此时只需要替换文件内容，而无须修改代码。

间接是`OOP`的核心，`OOP`使用间接来获取数据，如使用变量、文件和参数。`OOP`真正的革命性在于它使用间接来调用代码，不是直接调用某个函数，而是间接调用，通过指针来体现。

* 面向过程与面向对象

过程式编程建立在函数之上，数据为函数服务，而面向对象编程则以程序的数据为中心，函数为数据服务。在`OOP`中，不再重点关注程序中的函数，而是专注于数据。在`OOP`中，数据通过间接方式引用代码，代码可以对数据进行操作。

* `id`

`id`是一种泛型，可以用来引用任何类型的对象。对象是一种包含代码的`struct`结构体，因此`id`实际上是一个指向结构体的指针。

* 方括号`([])`

`Objective-C`中调用方法时方括号的功能：用于通知某个对象该去做什么，方括号里的第一项是对象，其余部分是需要对象执行的操作。`Objective-C`中通知对象执行某种操作称为发送消息(亦称调用方法)。向对象发送消息后，如何调用所需的代码，需要叫做类的幕后帮手来协助完成。对象含有一个指向其类的指针(类是一种能够实例化成对象的结构体)。类含有一个指针指向类所能实现功能的代码(方法列表)。

发送消息过程中如何调用对象中适当函数的流程：

```
1.对象是消息的目标，查询消息的目标对象属于哪个类。
2.在类中查找其代码块，获取函数的地址。
3.执行函数。
```

方法调用过程中体现了间接操作的使用，该过程中最终确定调用的函数和实现的功能，由`Objective-C`在幕后(运行时)决定，它(运行时)将查询对象属于哪个类。类对象的优势：如果在运行时改变某个类，则该类的所有对象会自动继承这些变化。

* 关键术语

```
类：是一种表示对象类型的结构体。
对象：是一种包含值和指向其类的隐藏指针的结构体，它能够通过函数指针查找与之相关的代码。
消息：是对象可以执行的操作，用于通知对象去做什么。对象接收消息后，将查询相应的类，以便找到正确的代码来运行。 
方法：是为响应消息而运行的代码。
方法调度：是Objective-C使用的一种机制(方法调度机制)，用于推测执行什么方法以响应某个特定的消息。
接口：是类为对象提供的特性描述。(接口不提供实现代码的细节信息)
实现：是使接口能正常工作的代码。

实例变量：由于对象的局部变量只在对象的实例中有效，因此称它们为实例变量，通常简写为ivar。
```

* `@interface`和`@implementation`

`@interface`和`@implementation`都是编译器指令。

创建某个特定类的对象之前，`Objective-C`编译器需要一些有关该类的信息，尤其是对象的数据成员(即对象的`C`语言类型结构体应该是什么样子)及其提供的功能，使用`@interface`指令把这些信息传递给编译器。

`@implementation`表明将为某个类提供代码，实现在`@interface`文件中所声明的方法的定义。也可以定义在`@interface`文件中没声明过的方法，此时该方法为仅能在当前类中所使用的私有方法。

Tips:

```
Objective-C中不存在真正的私有方法，也无法把某个方法标识为私有方法，从而禁止其他代码调用它。这是Objective-C动态本质的副作用。
```

* `self`

在`Objective-C`中调用方法时，一个名为`self`的秘密隐藏参数将被传递给接收对象，而这个参数引用的就是该接收对象(对象自身)。使用self参数后，方法可以查找并操作对象的数据。方法的实现和对象数据的模板是由对象的类定义的。`self`的传递过程是秘密和自动的。`Objective-C`运行时`(runtime)`可以将不同的对象当成隐藏的`self`参数传递，所以那些对象的实例变量发生更改时，运行时也可进行相应的更改。

---

* 继承

某些编程语言(如`C++`)具有多继承，也就是一个类可以直接从两个或多个类继承而来。**但`Objective-C`不支持多继承。**在`Objective-C`中可以通过类别`(category)`和协议`(protocol)`来达到多继承的效果。

如果想改变方法的实现，需要重写`(override)`继承的方法。代码运行时，`Objective-C`会确保调用的是重写过的方法。

基于继承，可以实现多态性。多态性：使用更具体种类的对象来代替一般类型，这种能力被称为多态性。

Tips:

```
重写方法时，调用超类方法总是一个明智之举，这样可以实现更多的功能，调用继承的方法可以确保获得方法实现的所有特性。
```

* 方法调度

当代码发送消息时，`Objective-C`的方法调度机制将在当前的类中搜索相应的方法。如果无法在接收消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。必要时它将会在继承链的每一个类中重复地执行上述操作。如果在最顶层的`NSObject`类中也没有找到该方法，则会出现一个运行时错误，同时还会出现一个编译时`(compile-time)`警告信息。

* 实例变量和`isa`

在创建一个新类时，，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。

`NSObject`类声明了一个名为`isa`的实例变量，该变量保存一个指向对象当前类的指针。因为继承在子类和超类之间建立了一种`“is a”`(是一个)的关系，所以`NSObject`的实例变量叫做`isa`。

每个方法调用都获得了一个名为`self`的隐藏参数，它是一个指向接收消息的对象的指针。这些方法通过`self`参数来寻找它们需要用到的实例变量。

Tips:

```
编译器使用“基地址加偏移”的机制实现奇妙的功能。有了对象基地址，即第
一个实例变量的首个字节在内存中的位置，再在该地址上加上偏移地址，编
译器就可以查找其他实例变量的位置。
```

* `super`

为了调用继承的方法在父类中的实现，需要使用`super`作为方法调用的目标。super既不是参数也不是实例变量，而是由Objective-C编译器提供的一种功能。当向super发送消息时，实际上是在请求Objective-C向该类的超类发送消息。如果超类中没有定义该消息，Objective-C会继续在继承链上一级中查找。

---

