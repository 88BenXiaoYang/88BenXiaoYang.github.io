---
title: Objective-C
date: 2019-03-07 22:02:55
tags: iOS
categories: iOS
---

* `Objective-C` 与 `Cocoa`

`Cocoa`是`Cocoa`和`Cocoa Touch`的统称。`Cocoa`是使用`Objective-C`语言开发的功能强大的用户界面工具包，里面分别包含了`OS X`和`iOS`系统的所有用户界面元素和其他所有相关内容。在开发环境`Xcode`下，使用`Objective-C`操作工具包`Cocoa`来开发应用程序。苹果为开发`OS X`和`iOS`平台上的应用程序，提供了针对`OS X`系统的`Cocoa`工具包和针对`iOS`系统的`Cocoa Touch`工具包。

* `.m`文件

`Xcode`通过`.m`扩展名来表示文件使用的是`Objective-C`代码，应由`Objective-C`编译器处理，扩展名`.m`代表`message`，指的是`Objective-C`的消息传递特性。在`Xcode`中，编译工作默认由`LLVM`处理，这个编译器能够理解`C`语言的全部3个变体。`C`编译器处理`.c`文件，`C++`编译器处理`.cpp`文件。**Objective-C本质上就是C语言。**

* `#import`语句

`Objective-C`使用头文件来包含结构体、符号常量和函数原型等元素的声明。在`Objective-C`语言中用`#import`语句来通知编译器查询头文件中相应的定义代码。`#import`是由`Xcode`使用的编译器`LLVM`提供的。`#import`可保证头文件只被包含一次，无论此命令在该文件中出现了多少次。

在`C`语言中，通常使用基于`#ifdef`命令的方案来避免一个文件包含另一个文件而后者又包含前者的情况。在`Objective-C`中，使用`#import`命令来实现这个功能。

* 框架

**框架**是一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。苹果将`Cocoa`、`Carbon`、`QuickTime`和`OpenGL`等技术作为框架集来提供。`Cocoa`的组成部分有`Foundation`和`Application Kit(AppKit)`框架。**`Foundation`框架处理的是用户界面之下的那些层`(Layer)`的特性，如数据结构和通信机制。**每个框架都是一个重要的技术集合，通常包含数十个甚至上百个头文件。每个框架都有一个主头文件，它包含了框架内所有的头文件。通过在主头文件中使用`#import`，就可以访问框架内的所有功能。

Tips:

```
Foundation框架的头文件占用了近1MB的磁盘存储空间，Xcode使用预编
译头文件(一种经过压缩的、摘要形式的头文件)来加快读取速度，通过
#import导入这种文件时，加载速度会非常快。
```

* 布尔类型`(BOOL)`

`Objective-C`中的`BOOL`实际上是一种对带符号的字符类型`(signed char)`的类型定义`(typedef)`，它使用`8`位的存储空间。通过`#define`指令把`YES`定义为`1`，`NO`定义为`0`。`Objective-C`并不会将`BOOL`作为仅能保存`YES`或`NO`值的真正布尔类型来处理。编译器仍将`BOOL`认作`8`位二进制数，`YES`和`NO`值只是在习惯上的一种理解。这样会引发一个小问题：如果不小心将一个大于`1字节`的整型值(如`short`或`int`)赋给一个`BOOL`变量，那么只有低位字节会用作`BOOL`值。如果该低位字节刚好为`0`(如`8960`，写成十六进制为`0x2300`)，`BOOL`值将会被认作是`0`，即`NO`值。

---

* 面向对象编程`(OOP)`

面向对象编程`(Object-Oriented Programming)`，即`OOP`。`OOP`是一种编程架构，可构建由多个对象组成的软件。`Cocoa`基于`OOP`概念，`Objective-C`是面向对象的语言。

* 间接

在代码中**通过指针间接获取某个值**，而不是直接获取。是使用数据、实现功能的一种方式。如变量与间接，就是通过间接的方式去使用变量，避免魔鬼数字的产生；文件名与间接，就是通过文件名去查询文件内容，避免查询的内容改变时需要谨慎大量的修改代码，使用间接方式此时只需要替换文件内容，而无须修改代码。

间接是`OOP`的核心，`OOP`使用间接来获取数据，如使用变量、文件和参数。`OOP`真正的革命性在于它使用间接来调用代码，不是直接调用某个函数，而是间接调用，通过指针来体现。

* 面向过程与面向对象

过程式编程建立在函数之上，数据为函数服务，而面向对象编程则以程序的数据为中心，函数为数据服务。在`OOP`中，不再重点关注程序中的函数，而是专注于数据。在`OOP`中，数据通过间接方式引用代码，代码可以对数据进行操作。

* `id`

`id`是一种泛型，可以用来引用任何类型的对象。对象是一种包含代码的`struct`结构体，因此`id`实际上是一个指向结构体的指针。

* 方括号`([])`

`Objective-C`中调用方法时方括号的功能：用于通知某个对象该去做什么，方括号里的第一项是对象，其余部分是需要对象执行的操作。`Objective-C`中通知对象执行某种操作称为发送消息(亦称调用方法)。向对象发送消息后，如何调用所需的代码，需要叫做类的幕后帮手来协助完成。对象含有一个指向其类的指针(类是一种能够实例化成对象的结构体)。类含有一个指针指向类所能实现功能的代码(方法列表)。

发送消息过程中如何调用对象中适当函数的流程：

```
1.对象是消息的目标，查询消息的目标对象属于哪个类。
2.在类中查找其代码块，获取函数的地址。
3.执行函数。
```

方法调用过程中体现了间接操作的使用，该过程中最终确定调用的函数和实现的功能，由`Objective-C`在幕后(运行时)决定，它(运行时)将查询对象属于哪个类。类对象的优势：如果在运行时改变某个类，则该类的所有对象会自动继承这些变化。

* 关键术语

```
类：是一种表示对象类型的结构体。
对象：是一种包含值和指向其类的隐藏指针的结构体，它能够通过函数指针查找与之相关的代码。
消息：是对象可以执行的操作，用于通知对象去做什么。对象接收消息后，将查询相应的类，以便找到正确的代码来运行。 
方法：是为响应消息而运行的代码。
方法调度：是Objective-C使用的一种机制(方法调度机制)，用于推测执行什么方法以响应某个特定的消息。
接口：是类为对象提供的特性描述。(接口不提供实现代码的细节信息)
实现：是使接口能正常工作的代码。

实例变量：由于对象的局部变量只在对象的实例中有效，因此称它们为实例变量，通常简写为ivar。
```

* `@interface`和`@implementation`

`@interface`和`@implementation`都是编译器指令。

创建某个特定类的对象之前，`Objective-C`编译器需要一些有关该类的信息，尤其是对象的数据成员(即对象的`C`语言类型结构体应该是什么样子)及其提供的功能，使用`@interface`指令把这些信息传递给编译器。

`@implementation`表明将为某个类提供代码，实现在`@interface`文件中所声明的方法的定义。也可以定义在`@interface`文件中没声明过的方法，此时该方法为仅能在当前类中所使用的私有方法。

Tips:

```
Objective-C中不存在真正的私有方法，也无法把某个方法标识为私有方法，从而禁止其他代码调用它。这是Objective-C动态本质的副作用。
```

* `self`

在`Objective-C`中调用方法时，一个名为`self`的秘密隐藏参数将被传递给接收对象，而这个参数引用的就是该接收对象(对象自身)。使用self参数后，方法可以查找并操作对象的数据。方法的实现和对象数据的模板是由对象的类定义的。`self`的传递过程是秘密和自动的。`Objective-C`运行时`(runtime)`可以将不同的对象当成隐藏的`self`参数传递，所以那些对象的实例变量发生更改时，运行时也可进行相应的更改。

* 建立类之间的关系

建立类之间的关系有：继承、复合。

继承是在两个类之间建立关系的一种方式，它可以避免许多重复的代码。

使用复合可组合多个对象，让它们分工协作。

```
继承的类之间建立的关系为“is a”(是一个)，如果可以说“X是一个Y”，那就可以使用继承。
复合的类之间建立的关系为“has a”(有一个)，如果可以说“X有一个Y”，那就可以使用复合。
```

* 继承

某些编程语言(如`C++`)具有多继承，也就是一个类可以直接从两个或多个类继承而来。**但`Objective-C`不支持多继承。**在`Objective-C`中可以通过类别`(category)`和协议`(protocol)`来达到多继承的效果。

如果想改变方法的实现，需要重写`(override)`继承的方法。代码运行时，`Objective-C`会确保调用的是重写过的方法。

基于继承，可以实现多态性。多态性：使用更具体种类的对象来代替一般类型，这种能力被称为多态性。

继承可以让我们在需要超类的地方使用子类。

与实例方法一样，继承对类方法也同样适用。

Tips:

```
重写方法时，调用超类方法总是一个明智之举，这样可以实现更多的功能，调用继承的方法可以确保获得方法实现的所有特性。
```

* 方法调度

当代码发送消息时，`Objective-C`的方法调度机制将在当前的类中搜索相应的方法。如果无法在接收消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。必要时它将会在继承链的每一个类中重复地执行上述操作。如果在最顶层的`NSObject`类中也没有找到该方法，则会出现一个运行时错误，同时还会出现一个编译时`(compile-time)`警告信息。

* 实例变量和`isa`

在创建一个新类时，，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。

`NSObject`类声明了一个名为`isa`的实例变量，该变量保存一个指向对象当前类的指针。因为继承在子类和超类之间建立了一种`“is a”`(是一个)的关系，所以`NSObject`的实例变量叫做`isa`。

每个方法调用都获得了一个名为`self`的隐藏参数，它是一个指向接收消息的对象的指针。这些方法通过`self`参数来寻找它们需要用到的实例变量。

Tips:

```
编译器使用“基地址加偏移”的机制实现奇妙的功能。有了对象基地址，即第
一个实例变量的首个字节在内存中的位置，再在该地址上加上偏移地址，编
译器就可以查找其他实例变量的位置。
```

* `super`

为了调用继承的方法在父类中的实现，需要使用`super`作为方法调用的目标。`super`既不是参数也不是实例变量，而是由`Objective-C`编译器提供的一种功能。当向`super`发送消息时，实际上是在请求`Objective-C`向该类的超类发送消息。如果超类中没有定义该消息，`Objective-C`会继续在继承链上一级中查找。

* 复合

在`Objective-C`中，复合是通过包含作为实例变量的对象指针实现的。只有对象间的组合才能叫做复合。

* `new`

使用`new`创建新对象时，系统其实在后台执行了两个步骤：第一步，为对象分配内存，即对象获得一个用来存放实例变量的内存块；第二步，自动调用`init`方法，使该对象进入可用状态。

Tips:

```
为了让超类将所有需要的初始化工作一次性完成，需要调用[super init]。init方法返回的值就是被初始化的对象。将[super init]返回的结果赋给self是Objective-C的惯例。这么做是为了防止超类在初始化过程中返回的对象与一开始创建的不一致。
```

* 存取方法：`setter`和`getter`

存取方法`(accessor)`是用来读取或改变某个对象属性的方法。`setter`方法为对象中的变量赋值；`getter`方法为代码提供了通过对象自身访问对象属性的方式。

Tips:

```
如果要对对象中的属性进行操作，应该尽量使用对象提供的存取方法，绝对不能直接改变对象里面的值。直接改变对象里面属性值的操作语法：对象->对象属性值。
```

对于存取方法，`Cocoa`有自己的命名惯例。`setter`方法根据它所更改的属性的名称来命名，并加上前缀`set`，如：`setFont:`。`getter`方法则是以其返回的属性名称命名，如：`font`。

在`Objective-C`中所有对象间的交互都是通过指针实现的。

---

* 源代码结构

`Objective-C`类的源代码分为，接口和实现两部分。

类的`@interface`指令、公共`struct`定义、`enum`变量、`#defines`和`extern`全局变量等存放在接口部分的文件中(`.h`文件，即头文件)。

类的`@implementation`指令、全局变量的定义、私有`struct`等类的实现内容都放在实现文件中(`.m`文件，实现文件)。

导入头文件有两种方法：使用引号或者尖括号。带尖括号的语句用于导入系统头文件，而带引号的语句则说明导入的是项目本地的头文件。系统头文件对于项目来说是只读的；可对项目头文件进行编辑。

类的使用者可以通过`#import`命令导入头文件来获得该类的功能。

* 依赖关系

导入头文件使头文件和源文件之间建立了紧密的依赖关系。如果头文件有任何变化，那么所有依赖它的文件都得重新编译。这会在需要编译的文件中引发一连串的变化。文件导入(依赖关系)过于混乱会延长编译时间，也会导致不必要的重复编译，巧妙地使用`@class`指令，可以减少必须导入的头文件的数量，从而可以缩短编译时间。

导致依赖关系问题的原因是`Objective-C`编译器需要某些信息才能够工作。有时编译器需要知道类的全部信息，例如类的实例变量配置、类所继承的所有类等，而有的时候，编译器只需要知道类名即可，不需要了解整个类的定义。

---

* `Xcode`操作

常用快捷键：

```
导航器面板：Command + 1~7切换视图。
导航器面板的显隐：Command + 0。
代码缩进处理：选中文本 + Control + I。
左右移动代码：Command + ]右移代码；Command + [左移代码。
缩进设置：Xcode -> Preferences -> Text Editing -> Indentation。
自动补全列表的操作：显隐：esc；翻页：Control + .向后翻页，Shift + Control + .向前翻页。
方法占位符的选择：按tab键。
替换项目中指定的类名：选中指定类，右键 -> Refactor -> Rename。
快速打开某个文件：Command + Shift + O。
辅助窗口：option + command + return (用于显示一个类的两个文件<头文件.h和实现文件.m>)。
折叠代码的操作可看：Editor -> Code Folding。
查看类的说明文档：option + 在类上轻点鼠标。
可通过快速帮助查看类信息：检查器的第二个选项即是该功能，切换光标指向即可改变快速帮助的内容。
查看类的结构：Control + 6。
```

调试快捷键：

```
激活/禁用断点：Command + Y。
继续运行：Command + Control + Y。
跳过：F6。
跳入：F7。
跳出：F8。
```

操作光标的快捷键：

**不局限于在`Xcode`上使用。**

```
Control-F：光标前移(Forward)。
Control-B：光标后退(Backward)。
Control-P：光标移动到上一行(Previous)。
Control-N：光标移动到下一行(Next)。
Control-A：光标移动到行首位置。
Control-E：光标移动到行尾位置(End)。
Control-T：交换光标两边的字符(Transpose)。
Control-D：删除光标右边的字符(Delete)。
Control-K：将当前行光标以后的所有字符全部删除(Kill)。
Control-L：将光标置于窗口正中央。
```

---

* `Foundation`

`Foundation`框架是以另一个框架`CoreFoundation`为基础创建的。`CoreFoundation`框架是用纯C语言写的。

* 类方法

`Objective-C`运行时生成一个类的时候，会创建一个代表该类的类对象`(class object)`。类对象包含了指向超类、类名和类方法列表的指针，还包含一个`long`类型的数据，为新创建的实例对象指定大小(以字节为单位)。如果在声明方法时添加了加号`(+)`，就是把这个方法定义为类方法`(class method)`。这个方法属于类对象(而不是类的实例对象)，通常用于创建新的实例。称这种用来创建新对象的类方法为工厂方法`(factory method)`。

通常所创建的大部分方法都是实例方法，用减号`(-)`作为前缀来进行声明。

* `NSArray`

`NSArray`类的两个限制：

```
1.它只能存储Objective-C对象，而不能存储原始的C语言基础数据类型，
如int、float enum struct NSArray中的随机指针。
2.不能在NSArray中存储nil。因为在数组列表结尾添加nil代表列表结
束，这就是不能在数组中存储nil的原因一个原因。另一个原因是在数组通
过枚举器来遍历数组元素时，是通过nextObject返回的值是否为nil值，
来判断循环是否结束。
```

`NSArray`中的对象是从零开始编制索引的，这与`C`数组的规范一样。删除对象之后，数组中并没有留下漏洞，位于被删除对象后面的数组元素都被前移来填补空缺了。

遍历数组的方法：

```
1.通过索引；
2.使用NSEnumerator(枚举器)；
3.使用快速枚举(for in语法)；
4.代码块方法(block，通过代码块可以让循环操作并发执行)。
```

上述方法的使用场景：通常使用快速枚举或代码块，因为它们简洁快速。在需要通过索引访问数组时使用索引访问。枚举器在`Objective-C 2.0`中，会自动将枚举器的循环转换成快速枚举。

Tips:

```
C语言将字符串作为简单的字符数组进行处理，并且在数组最后添加尾部的零字节作为结束标志。
```

* `NSValue`

`NSNumber`实际上是`NSValue`的子类，`NSValue`可以封装任意值。
`valueWithBytes: objCType:`
传递的参数是要封装的数值的地址(使用操作符`&`)。可提供一个用来描述这个数据类型的字符串(通常用来说明数值的类型和大小)，不用自己写代码来生成这个字符串，`@encode`编译器指令可以接收数据类型的名称并生成合适的字符串(`@encode`指令，它用于需要描述C语言基础类型的方法)。
可以使用`NSValue`将任意值放入`NSArray`或`NSDictionary`中。

* `NSNull`

`[NSNull null]`总是返回一样的数值，因此可以使用运算符`==`将该值与其他值进行比较。

---

* 对象生命周期

对象的生命周期包括诞生(通过`alloc`或`new`方法实现)、生存(接收消息并执行操作)、交友(通过复合以及向方法传递参数)以及最终死去(被释放掉)。当生命周期结束时，它们的原材料(内存)将被回收以供新的对象使用。

**引用计数**，是一种用来判断管理对象生命周期是否结束的技术。每个对象都有一个与之相关联的整数，被称作对象的引用计数器。当某段代码需要访问一个对象时，该代码就将该对象的引用计数器值加`1`。当这段代码结束对象访问时，将对象的引用计数器减`1`，表示它不再访问该对象。当引用计数器的值为`0`时，表示不再有代码访问该对象了，因此它将被销毁，其占用的内存被系统回收以便重用。

当使用`alloc`、`new`方法或者通过`copy`消息创建一个对象时，对象的引用计数器值被设置为`1`。要增加对象的引用计数器的值，可以给对象发送一条`retain`消息。要减少引用计数器的值的话，可以给对象发送一条`release`消息。

当一个对象因其引用计数器归`0`而即将被销毁时，`Objective-C`会自动向对象发送一条`dealloc`消息。可在对象中重写`dealloc`方法，这样就能释放掉已经分配的全部相关资源。一定不要直接调用`dealloc`方法，`Objective-C`会在需要销毁对象时自动调用它。

* 对象所有权

如果一个对象内有指向其他对象的实例变量，则称该对象拥有这些对象。如果一个函数创建了一个对象，则称该函数拥有这个对象。

* 访问方法中的保留和释放

在访问方法中，先保留新对象，然后再释放对象就不会出现问题了。针对操作的对象是同一个对象的时候，尤其要如上述流程编写代码。

* 自动释放池

自动释放池，是一个用来存放对象的池子(集合)，并且能够自动释放。

`NSObject`类提供了一个叫做`autorelease`的方法：`- (id) autorelease;`。该方法预先设定了一条会在未来某个时间发送的`release`消息，其返回值是接收这条消息的对象。当给一个对象发送`autorelease`消息时，实际上是将该对象添加到了自动释放池中。当自动释放池被销毁时，会向该池中的所有对象发送`release`消息。

自动释放池以栈的形式实现：当你创建了一个新的自动释放池时，它就被添加到栈顶。接收`autorelease`消息的对象将被放入最顶端的自动释放池中。**如果将一个对象放入一个自动释放池中，然后创建一个新的自动释放池，再销毁该新建的自动释放池，则这个自动释放池对象仍将存在，因为容纳该对象的自动释放池仍然存在。**

Tips:

手动实现自动释放池的参考思路：

```
可以使用NSMutableArray来编写自己的自动释放池，以容纳对象并在dealloc方法中向池中的所有对象发送release消息。
```

* 自动释放池的销毁时间

有两种方法可以创建一个自动释放池：

```
1.通过@autoreleasepool关键字。
2.通过NSAutoreleasePool对象。
```

在`Foundation`库工具集中，创建和销毁自动释放池已经由`@autorelease`关键字完成。

当使用`@autorelease{}`时，所有在花括号里的代码都会被放入这个新池子里。这种情况下，任何在花括号里定义的变量在括号外就无法使用了。

第二种方法是使用`NSAutoreleasePool`对象。使用这种方法，创建和释放`NSAutoreleasePool`对象之间的代码就会使用这个新池子。创建了一个自动释放池后，该池就会自动成为活动的池子。释放该池后，其引用计数器的值归`0`，然后该池被销毁。在销毁的过程中，该池将释放其包含的所有对象。

销毁自动释放池中对象的方式：`-drain`：该方法只是清空自动释放池而不会销毁自动释放池。自己编写的代码中，使用`-release`方法，以兼容更古老的版本。

对同一对象而言，其销毁的过程中，在收到`release`消息将其引用计数器的值减少为`0`时，其`dealloc`方法被调用。

* `Cocoa`的内存管理规则

> 1.当使用`new`、`alloc`或`copy`方法创建一个对象时，该对象的引用计数器的值为`1`。当不再使用该对象时，应该向该对象发送一条`release`或`autorelease`消息。这样，该对象将在其使用寿命结束时被销毁。
> 
> 2.当通过其他方法获得一个对象时，假设该对象的引用计数器的值为`1`，而且已经被设置为自动释放，那么不需要执行任何操作来确保该对象得到清理。如果打算在一段时间内拥有该对象，则需要保留它并确保在操作完成时释放它。
>
> 3.如果保留了某个对象，就需要释放或自动释放该对象。必须保持`retain`方法和`release`方法的使用次数相等。

无论什么时候拥有一个对象，有两件事必须弄清楚：

```
怎样获得该对象的？
打算拥有多长时间？
```

内存管理规则：

|获得途径|临时对象|拥有对象|
|---|---|---|
|alloc/new/copy|不再使用时释放对象|在dealloc方法中释放对象|
|其他方法|不需要执行任何操作|获得对象时保留，在dealloc方法中释放对象|

* 事件循环

一个典型的图形应用程序往往花费许多时间等待用户操作。在控制程序运行的用户作出决定(如按下某个键)以前，程序将一直处于空闲状态。当发生如按下某个键的事件时，程序将被唤醒并开始工作，执行必要的操作以响应这一事件。在处理完这一事件后，程序返回到休眠状态并等待下一个事件发生。上述过程即为事件循环。(底层是通过`do-while`控制的)。

**为了降低程序的内存空间占用，`Cocoa`会在程序开始处理事件之前创建一个自动释放池，并在事件处理结束后销毁。这样可以尽量减少累积的临时对象的数量。**

如果使用除`alloc`、`new`或`copy`以外的方法获得了一个对象，需要记得保留该对象。如果编写的是`GUI`应用程序，要考虑到事件循环。需要保留自动释放的对象，以便这些对象在当前的事件循环结束以后仍能继续存在。在这种情况下，需要在执行保留操作的对象中的`dealloc`方法中释放它，以便它被清理掉。

自动释放池被清理的时间是完全确定的：

```
要么是在代码中程序员自己手动销毁；
要么是使用AppKit时在事件循环结束时销毁。(在调用函数的过程中自动释放池不会被销毁)
```

* 内存管理机制的实现

> 垃圾回收，针对`OS X`应用程序。
> 
> 自动引用计数`(ARC)`，针对`iOS`应用程序。

**垃圾回收和`ARC`是无法一同使用的。**

* 垃圾回收

Objective-C 2.0引入了自动内存管理机制，也称垃圾回收。启用垃圾回收以后，平常的内存管理命令全都变成了空操作指令。垃圾回收器定期检查变量和对象并且跟踪它们之间的指针，当发现没有任何变量指向某个对象时，就将该对象视为应该丢弃的垃圾。与自动释放池一样，垃圾回收器也是在事件循环结束时触发的。**垃圾回收功能只支持OS X应用开发，无法用在iOS应用程序上。**垃圾回收器在运行时工作，通过返回的代码来定期检查对象。

* 自动引用计数`(ARC)`

在`iOS`中无法使用垃圾回收，主要原因是无法知道垃圾回收器什么时候会起作用。垃圾回收机制会对移动设备的可用性产生不利的影响，因为移动设备比电脑更私人化，资源更少。用户可不想在打电话的时候因为系统突然进行内存清理而卡住。

实现与垃圾回收功能相同的移动端解决方案为**自动引用计数`(automatic reference counting，ARC)`。**`ARC`会追踪你的对象并决定哪一个仍会使用，而哪一个不会再用到。如果启用了`AR`C，编译器会帮你插入`retain`和`release`语句。

ARC不是垃圾回收器，垃圾回收器在运行时工作，通过返回的代码来定期检查对象。ARC是在编译时进行工作的，ARC在代码中插入了合适的retain和release语句，完成了内存管理的工作。

注意：

```
ARC只对可保留的对象指针(ROPs)有效。可保留的对象指针主要有以下三种：
1.代码块指针
2.Objective-C对象指针
3.通过__attribute__((NSObject))类型定义的指针

所有其他的指针类型，如char *和CF对象(如CFStringRef)都不支持ARC
特性。如果使用的指针不支持ARC，那么将不得不亲自手动管理它们。ARC
可以与手动的内存管理共同发挥作用。
```

使用`ARC`的时候有两种命名规则需要注意：
> 1.属性名称不能以`new`开头。
> 
> 2.属性不能只有一个`read-only`而没有内存管理特性。默认的特性是`assign`(`assign`只是基础类型的赋值描述)，进行简单的修复，使用`unsafe_unretained`(`unsafe_unretained`有对象所用权的描述特性)就可以了。

**`ARC`转换是一个单程的操作，一旦转换成`ARC`版本，就不可以恢复了。**

`ARC`是基于文件进行工作的。

* 内存泄漏

程序无法访问到对象，但它们仍占用着内存容量。循环引用场景下会出现内存泄漏的情况。

* 归零弱引用

归零弱引用`(zeroing weak reference)`，不会使所引用的对象的引用计数器的值增加，同时在所引用的对象被释放时，归零弱引用就会被设置为`nil`。

如果想要使用归零弱引用，必须明确地声明它们。有两种方式可以声明归零弱引用：
> 1.声明变量时使用`__weak`关键字。
> 
> 2.对属性使用`weak`特性。

想在不支持弱引用的旧系统上使用`ARC`，使用`__unsafe_unretained`关键字和`unsafe_unretained`特性，这样`ARC`便知道这个特殊的引用是弱引用。

**注意：内存管理的关键字和特性是不能一起使用的，两者相互排斥。**

* 拥有者权限

需理解！！！（Objective-C P153）

