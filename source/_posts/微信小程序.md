---
title: 微信小程序
date: 2019-02-07 11:34:46
tags: 前端
categories: 前端
---

### 背景

当微信中的`WebView`逐渐成为移动`Web`的一个重要入口时，微信就有相关的`JS API`了。为了使在微信中对网页的开发简洁、高效，微信在`2015`年发布了一整套**网页开发工具包`JS-SDK`**，让开发者可以使用到微信的原生能力。

`JS-SDK`解决了**移动网页**能力不足的问题，通过暴露微信的接口使得`Web`开发者能够拥有更多的能力，然而在更多的能力之外，`JS-SDK`的模式并没有解决使用移动网页遇到的体验不良的问题。

使用移动网页遇到的体验不良问题，有：

1. 白屏过程(在移动端，受限于设备性能和网络速度，白屏会更加明显。有微信`Web`资源离线存储的解决方案)
   * 微信`Web`资源离线存储是面向`Web`开发者提供的基于微信内的`Web`加速方案：通过使用微信离线存储，`Web`开发者可借助微信提供的资源存储能力，直接从微信本地加载`Web`资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有`Web App`累计最多可缓存`5M`的资源
   * 简单的页面通过**离线存储**能够解决白屏问题，但对于复杂页面(如页面加载了大量的`CSS`或是`JavaScript`文件)，依然会有白屏问题，因为构建复杂页面的文件的执行时间占用了大量的`UI`线程
2. 缺少操作的反馈，主要表现在：
   * 页面切换的生硬
   * 点击的迟滞感

为解决上述的用户体验问题，使开发者对移动网页的开发简洁、高效，全新的系统小程序应运而生。小程序具有以下特点：

* 快速的加载
* 更强大的能力
* 原生的体验
* 易用且安全的微信数据开放
* 高效和简单的开发

### 小程序与普通网页开发的区别

小程序的主要开发语言是`JavaScript`

网页开发**渲染线程**和**脚本线程**是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种**浏览器暴露出来的`DOM API`**，进行`DOM`选中和操作。小程序的**逻辑层**和**渲染层**是分开的，逻辑层运行在`JSCore`中，并没有一个完整**浏览器对象**，因而缺少相关的`DOM API`和`BOM API`。这一区别导致了前端开发非常熟悉的一些库，例如`jQuery`、`Zepto`等，在小程序中是无法运行的。同时`JSCore`的环境同`NodeJS`环境也是不尽相同，所以一些`NPM`的包在小程序中也是无法运行的。

**网页开发**者需要面对的环境是各式各样的**浏览器**，`PC`端需要面对`IE`、`Chrome`、`QQ`浏览器等，在移动端需要面对`Safari`、`Chrome`以及`iOS`、`Android`系统中的各式`WebView`。而小程序开发过程中需要面对的是两大操作系统`iOS`和`Android`的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，区别如下：

![小程序的运行环境](微信小程序/小程序的运行环境.png)

### 小程序代码组成

小程序由配置代码`JSON`文件、模板代码`WXML`文件、样式代码`WXSS`文件以及**逻辑代码**`JavaScript`文件组成。

##### `JSON`配置

`JSON`是一种数据格式，并不是编程语言。在小程序中`.json`为后缀的`JSON`文件是配置文件。

`JSON`文件在小程序代码中扮演静态配置的作用，在小程序运行之前就决定了小程序一些表现，需要注意的是小程序是无法在运行过程中去动态更新`JSON`配置文件从而发生对应变化的。

* `JSON`语法

通过`key-value`的方式来表达数据，`JSON`中键和值都用双引号包裹。`JSON`文件中无法使用注释，添加注释将会引发报错。

* `JSON`的值只能是以下几种数据格式
  1. 数字，包含浮点数和整数
  2. 字符串，需要包裹在双引号中
  3. `Bool`值，`true`或者`false`
  4. 数组，需要包裹在方括号中`[]`
  5. 对象，需要包裹在大括号中`{}`
  6. `Null`

**小程序配置 app.json**

`app.json` 是当前小程序的**全局配置**，包括了小程序的：

```
所有页面路径、
界面表现、
网络超时时间、
底部 tab 等。
```

主要配置项的含义：

```
pages - 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径+文件名 信息。
文件名不需要写文件后缀，框架会自动去寻找对应位置的 .json, .js, .wxml, .wxss 四个文件进行处理。

pages配置项的值是数组，数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。

tabBar - 指定 tab 栏的表现，以及 tab 切换时显示的对应页面。
其中 tabBar 的 list 属性接受一个数组，只能配置最少 2 个、最多 5 个 tab。tab 按数组的顺序排序，每个项都是一个对象。
```

配置项细节可参考[小程序的配置 app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)

**工具配置 project.config.json**

使用场景：开发者在小程序开发者工具上做的任何配置都会写入到这个文件，当重新安装工具或换电脑时，只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到之前开发项目时的个性化配置。

配置项细节可参考[开发者工具的配置](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)

**页面配置 page.json**

这类配置是`pages/xxx`目录下和小程序页面相关的配置。让开发者可以独立定义每个页面的属性，如顶部颜色、是否允许下拉刷新。

页面的配置只能设置`app.json`中部分`window`配置项的内容，页面中配置项会覆盖`app.json`的`window`中相同的配置项。

配置项细节可参考[页面配置](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#页面配置)

##### `.wxml`后缀的`WXML`模板文件

`WXML`全称是`WeiXin Markup Language`，是小程序框架设计的一套标签语言，结合小程序的基础组件、事件系统，可以构建出页面的结构。`WXML`要求标签必须是严格闭合的，没有闭合将会导致编译错误。

**标签**可以拥有**属性**，属性提供了有关的**`WXML`元素**更多信息。**属性总是定义在开始标签中**，除了一些特殊的属性外，其余**属性的格式都是key="value"的方式成对出现**。需要注意的是，`WXML`中的**属性是大小写敏感的**，也就是说`class`和`Class`在`WXML`中是不同的属性。

网页编程采用的是`HTML + CSS + JS`这样的组合，其中：

```
HTML： 是用来描述当前这个页面的结构；
CSS： 用来描述页面的样子；
JS： 通常是用来处理这个页面和用户的交互。
```

和`HTML`相似，`WXML`由标签、属性等构成。也有很多不一样的地方，区别如下：

1. 标签名字不一样：

```
写 HTML 的时候，经常会用到的标签是 div，p，span，在写一个页面的
时候可以根据这些基础的标签组合出不一样的组件，如日历、弹窗等。基于
此小程序把常用的组件包装起来，用指定的标签表示包装起来的组件，同时
被包装起来的组件拥有对应的基本能力。如小程序的 WXML 用的标签是 
view，button，text等，这些标签就是小程序给开发者包装好的基本组件
能力，除此之外微信还提供了地图、视频、音频等组件能力。
```

更多组件能力的详细信息可参考[小程序的能力](https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/framework.html)、[小程序的组件](https://developers.weixin.qq.com/miniprogram/dev/component/)

2. 多了一些`wx:if`这样的属性

```
多了一些 wx:if 这样的属性以及 {{}} 这样的表达式。

小程序中，wx:if 这样的属性和 {{}} 这样的表达式引入的背景：

在网页的一般开发流程中，通常会通过 JS 操作 DOM（对应 HTML 的描述
产生的树），以引起界面的一些变化响应用户的行为。如，用户点击某个按
钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操
控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时
候，代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不
是一个很好的开发模式，因此就有了 MVVM 的开发模式（如React，
Vue），提倡把渲染和逻辑分离。
```

**小程序框架的思路：**简单来说就是不要再让 `JS` 直接操控 `DOM`，`JS` 只需要管理状态即可，然后再通过一种**模板语法**来描述状态和界面结构的关系即可。

* 数据绑定

```
数据绑定实现程序运行的过程中，可以动态的去改变渲染界面。在Web开发中，开发者使用JavaScript
通过Dom接口来完成界面的实时更新。在小程序中，使用WXML语言所提供的数据绑定功能，来完成
此项功能。

WXML通过{{变量名}}来绑定WXML文件和对应的JavaScript文件中的data对象属性。

属性值也可以动态的去改变，有所不同的是，属性值必须被包裹在双引号中。需要注意的是变量名是大小写敏
感的，也就是说{{name}}和{{Name}}是两个不同的变量。没有被定义的变量或者是被设置为
undefined的变量不会被同步到wxml中。
```

* 逻辑语法

```
通过{{变量名}}语法可以使得WXML拥有动态渲染的能力，除此外还可以在{{ }}内进行简单的逻辑运算。

{{}}内支持的逻辑运算：
  * 三元运算
  * 算数运算(类似于算数运算，支持字符串的拼接)
  * {{}}中可以直接放置数字、字符串或者是数组
```

* 条件逻辑

`WXML`中，使用`wx:if="{{condition}}"`来判断是否需要**渲染**该代码块。使用`wx:elif`和`wx:else`来添加一个`else`块。

因为`wx:if`是一个**控制属性**，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个`<block/>`标签将多个组件包装起来，并在上边使用`wx:if`控制属性。

* 列表渲染

在组件上使用`wx:for`控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为`index`，数组当前项的变量名默认为`item`。使用`wx:for-item`指定数组当前元素的变量名，使用`wx:for-index`指定数组当前下标的变量名(相当于命名别名)。

如果需要保持列表项目的特征和状态时(如：`<input/>`中的输入内容，`<switch/>`的选中状态)，需要使用`wx:key`来指定列表中项目的唯一标识符。基于在渲染时，带有`key`的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

`wx:key`的值以两种形式提供：

1. **字符串**，代表在`for`循环的`array`中`item`的某个`property`，该`property`的值需要是列表中**唯一的字符串或数字，且不能动态改变**
2. 保留关键字`this`代表在`for`循环中的`item`本身，这种表示需要`item`本身是一个唯一的字符串或者数字

* 模版

`WXML`提供模板(`template`)，可以在模板中定义代码片段，然后在不同的地方调用。使用`name`属性，作为模板的名字。然后在`<template/>`内定义代码片段。

定义模版：

```
<template name="msgItem">
  <view>
    <text> {{index}}: {{msg}} </text>
    <text> Time: {{time}} </text>
  </view>
</template>
```

使用`is`属性，声明需要使用的模板，然后将模板所需要的`data`传入。`is`可以动态决定具体需要渲染哪个模板。

* 引用

`WXML`提供两种文件引用方式`import`和`include`。

1. `import`可以在该文件中使用目标文件定义的`template`。需要注意的是`import`有作用域的概念，即只会`import`目标文件中定义的`template`，而不会`import`目标文件中`import`的`template`，简言之就是`import`不具有递归的特性
2. `include`可以将目标文件中除了`<template/>``<wxs/>`外的整个代码引入，相当于是拷贝到`include`位置

##### `.wxss`后缀的`WXSS`样式文件

`WXSS`(`WeiXin Style Sheets`)是一套用于小程序的**样式语言**，用于描述`WXML`的**组件样式**，也就是视觉上的效果。`WXSS`与`Web`开发中的`CSS`类似。

`app.wxss`为项目的公共样式，它会被注入到小程序的每个页面。页面样式，是与`app.json`注册过的页面同名且位置同级的`.wxss`文件。其他样式，可以被项目公共样式和页面样式引用。

在小程序开发中，开发者不需要像`Web`开发那样去优化样式文件的请求数量，只需要考虑**代码的组织**即可，样式文件最终会被编译优化。

在`WXSS`中，引入了`rpx`(`responsive pixel`)尺寸单位，以适配不同宽度的屏幕。小程序编译后，`rpx`会做一次`px`换算。换算是以`375`个物理像素为基准，也就是在一个宽度为`375`物理像素的屏幕下，`1rpx = 1px`。

常用机型`rpx`尺寸换算表：

![常用机型rpx尺寸换算表](微信小程序/常用机型rpx尺寸换算表.png)

由于`WXSS`最终会被**编译打包**到目标文件中，用户只需要下载一次，在使用过程中不会因为样式的引用而产生多余的文件请求。小程序中样式文件的引用格式为：`@import '.wxss文件路径'`。

小程序中`WXSS`内联样式与`Web`一样。即通过样式属性`style`进行设置。小程序支持动态更新内联样式。

小程序`WXSS`现阶段支持的选择器：

![小程序WSXX现阶段支持的选择器](微信小程序/小程序WSXX现阶段支持的选择器.png)

`WXSS`选择器优先级：

![WXSS选择器优先级](微信小程序/WXSS选择器优先级.png)

**权重越高越优先。在优先级相同的情况下，后设置的样式优先级高于先设置的样式。**

##### `.js`后缀的`JS`脚本逻辑文件

小程序的主要开发语言是`JavaScript`，开发者使用`JavaScript`来**开发业务逻辑**以及调用小程序的`API`来完成业务需求。

小程序中的`JavaScript`与浏览器中的`JavaScript`和`NodeJS`中的`JavaScript`的区别：

* 浏览器中的`JavaScript`
  * 浏览器中的`JavaScript`是由**`ECMAScript`**和**`BOM`(浏览器对象模型)**以及**`DOM`(文档对象模型)**组成的，`Web`前端开发者会很熟悉这两个对象模型，它使得开发者可以去操作浏览器的一些表现，比如修改`URL`、修改页面呈现、记录数据等等。

* `NodeJS`中`JavaScript`
  * `NodeJS`中的`JavaScript`是由**`ECMAScript`**和**`NPM`**以及**`Native`模块**组成，`NodeJS`的开发者会非常熟悉`NPM`的包管理系统，通过各种拓展包来快速的实现一些功能，同时通过使用一些原生的模块例如`FS`、`HTTP`、`OS`等等来拥有一些语言本身所不具有的能力。

* 小程序中的`JavaScript`
  * 小程序中的`JavaScript`是由**`ECMAScript`**以及**小程序框架**和**小程序`API`**来实现的。同浏览器中的`JavaScript`相比没有`BOM`以及`DOM`对象，所以类似`JQuery`、`Zepto`这种浏览器类库是无法在小程序中运行起来的，同样的缺少`Native`模块和`NPM`包管理的机制，小程序中无法加载原生库，也无法直接使用大部分的`NPM`包。

除`JavaScript`不同外，不同的平台的小程序的脚本执行环境也是有所区别的。目前小程序可以运行在三大平台，`iOS平台`、`Android平台`、`小程序IDE`，这种区别主要是体现三大平台实现的`ECMAScript`的标准有所不同。

浏览器中，所有`JavaScript`是运行在同一个作用域下的，定义的参数或者方法可以被后续加载的脚本访问或者改写。与浏览器不同，小程序中可以将任何一个`JavaScript`文件作为一个模块，通过`module.exports`或者`exports`对外暴露接口。

使用`require(path)`将模块引入。

* 脚本的执行顺序

浏览器中，脚本严格按照加载的顺序执行。在小程序中脚本的执行顺序与浏览器中的有所不同，小程序的执行入口文件是`app.js`，会根据其中`require`的模块顺序决定文件的运行顺序。当`app.js`执行结束后，小程序会按照开发者在`app.json`中定义的`pages`的顺序，逐一执行。

* 作用域

小程序脚本的作用域，在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响。

当需要使用全局变量的时候，通过使用全局函数`getApp()`获取全局的实例，并设置相关属性值，来达到设置全局变量的目的。

注，脚本中全局变量的访问，对全局变量声明所在的脚本和变量所使用的脚本有顺序上的依赖关系，只有变量声明所在的脚本先执行了，变量使用的脚本才能有效的使用变量。

当需要保证全局的数据可以在任何文件中安全的被使用到，那么可以在`App()`中进行设置(即在`app.js`中的`App()`中进行设置)。

### 小程序的宿主环境

微信客户端给小程序提供了宿主环境，小程序可以调用宿主环境提供的微信客户端的能力，这使得小程序比普通网页拥有更多的能力。

小程序的运行环境分成**渲染层**和**逻辑层**。`WXML`模板和`WXSS`样式工作在渲染层，`JS`脚本工作在逻辑层。在小程序中渲染层和逻辑层是分离的。

* 通信模型

小程序的渲染层和逻辑层分别由`2`个线程管理：渲染层的界面使用了`WebView`进行渲染；逻辑层采用`JsCore`线程运行`JS`脚本。一个小程序存在多个界面，所以渲染层存在多个`WebView`线程，这两个线程的通信会经由微信客户端(可用`Native`来代指微信客户端)做中转，逻辑层发送网络请求也经由`Native`转发。

* 数据驱动

通常界面视图和变量状态是相关联的，通过**数据驱动**可省去手动修改视图的工作。

小程序数据驱动的基本原理：`WXML`结构实际上等价于一棵`Dom`树，通过一个`JS`对象也可以来表达`Dom`树的结构。`WXML`可以先转成`JS`对象，然后再渲染出真正的`Dom`树。数据状态变化后，产生的`JS`对象对应的节点就会发生变化，此时可以对比前后两个`JS`对象得到变化的部分，然后把这个差异应用到原来的`Dom`树上，从而达到更新`UI`的目的。(即：状态更新的时候，通过对比前后`JS`对象变化，进而改变视图层的`Dom`树)

* 双线程下的界面渲染

小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把`WXML`转化成对应的`JS`对象，在逻辑层发生数据变更的时候，通过宿主环境提供的`setData`方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的`Dom`树上，渲染出正确的`UI`界面。

大致流程如下：

1. 描述界面
2. 传递页面数据
3. 对比应用差异重新渲染界面

* 小程序界面渲染的基本原理
  * 小程序的页面结构由`WXML`进行描述，`WXML`可以通过**数据绑定**的语法绑定从逻辑层传递过来的数据字段，这里所说的数据其实就是来自于页面`Page`构造器的`data`字段，`data`参数是页面第一次渲染时从逻辑层传递到渲染层的数据

##### 程序与页面

从逻辑组成来说，一个小程序是由多个“页面”组成的“程序”。

小程序与程序的区别：**小程序**指的是产品层面的程序；**程序**指的是代码层面的程序实例。

* 程序构造器`App()`

宿主环境提供了`App()`构造器用来注册一个程序`App`，需要留意的是`App()`构造器必须写在项目根目录的`app.js`里，**`App`实例是单例对象**，在其他`JS`脚本中可以使用宿主环境提供的`getApp()`来获取**程序实例**。

`App`构造器接受一个`Object`参数，其中`onLaunch`/`onShow`/`onHide`三个回调是`App`实例的生命周期函数。

`App`构造器的参数

![App构造器的参数](微信小程序/App构造器的参数.png)

* 程序的生命周期和打开场景
  * 程序生命周期
     * 初次进入小程序的时候，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境，初始化完毕后，微信客户端就会给`App`实例派发`onLaunch`事件，`App`构造器参数所定义的`onLaunch`方法会被调用
     * 进入小程序之后，用户可以点击右上角的关闭，或者按手机设备的`Home`键离开小程序，此时小程序并没有被直接销毁，把这种情况称为“小程序进入后台状态”，App构造器参数所定义的`onHide`方法会被调用
     * 当再次回到微信或者再次打开小程序时，微信客户端会把“后台”的小程序唤醒，把这种情况称为“小程序进入前台状态”，`App`构造器参数所定义的`onShow`方法会被调用
  * `App`的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，不应该从其他代码里主动调用`App`实例的生命周期函数
  * 在微信客户端中打开小程序的途径
     * 从群聊会话里打开
     * 从小程序列表中打开
     * 通过微信扫一扫二维码打开
     * 从另外一个小程序打开当前小程序
     * 针对不同途径的打开方式，小程序有时需要做不同的业务处理，所以微信客户端会把打开方式带给`onLaunch`和`onShow`的调用参数`options`

     ![onLaunch_onShow的参数](微信小程序/onLaunch_onShow的参数.png)

* 小程序全局数据

小程序的`JS`脚本是运行在`JsCore`的线程里，小程序的每个页面各自有一个`WebView`线程进行渲染，所以小程序切换页面时，小程序逻辑层的`JS`脚本运行上下文依旧在同一个`JsCore`线程中。`App`实例是单例的，因此不同页面直接可以通过`App`实例下的属性来共享数据，`App`构造器可以传递其他参数作为全局属性以达到全局共享数据的目的。

要特别留意一点，所有页面的脚本逻辑都跑在同一个`JsCore`线程，页面使用`setTimeout`或者`setInterval`的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理。

* 页面

一个页面是分三部分组成：界面、配置和逻辑。**界面**由`WXML`文件和`WXSS`文件来负责描述，**配置**由`JSON`文件进行描述，**页面逻辑**则是由`JS`脚本文件负责。

一个页面的文件需要放置在同一个目录下，其中`WXML`文件和`JS`文件是必须存在的，`JSON`和`WXSS`文件是可选的。

页面路径需要在小程序代码根目录`app.json`中的`pages`字段声明，否则这个页面不会被注册到宿主环境中。

默认`pages`字段的第一个页面路径为小程序的首页。

* 页面构造器`Page()`

宿主环境提供了`Page()`构造器用来注册一个小程序页面，`Page()`在页面对应的脚本`.js`中调用。`Page()`构造器接受一个`Object`参数，其中`data`属性是当前页面`WXML`模板中可以用来做数据绑定的初始数据。

`Page`实例的生命周期函数：`onLoad`/`onReady`/`onShow`/`onHide`/`onUnload`

页面的用户行为：`onPullDownRefresh`/`onReachBottom`/`onShareAppMessage`/`onPageScroll`

`Page`构造器的参数

![Page构造器的参数01](微信小程序/Page构造器的参数01.png)
![Page构造器的参数02](微信小程序/Page构造器的参数02.png)

* 页面的生命周期和打开参数
  * 页面初次加载的时候，微信客户端就会给`Page`实例派发`onLoad`事件，`Page`构造器参数所定义的`onLoad`方法会被调用，`onLoad`在页面没被销毁之前只会触发`1`次，在`onLoad`的回调中，可以获取当前页面所调用的打开参数`option`
  * 页面显示之后，`Page`构造器参数所定义的`onShow`方法会被调用，一般从别的页面返回到当前页面时，当前页的`onShow`方法都会被调用
  * 在页面初次渲染完成时，`Page`构造器参数所定义的`onReady`方法会被调用，`onReady`在页面没被销毁前只会触发`1`次，`onReady`触发时，表示页面已经准备妥当，在逻辑层就可以和视图层进行交互了
  * 事件触发的时机是`onLoad`早于`onShow`，`onShow`早于`onReady`
  * 页面不可见时，`Page`构造器参数所定义的`onHide`方法会被调用，这种情况会在使用`wx.navigateTo`切换到其他页面、底部`tab`切换时触发
  * 当前页面使用`wx.redirectTo`或`wx.navigateBack`返回到其他页时，当前页面会被微信客户端销毁回收，此时`Page`构造器参数所定义的`onUnload`方法会被调用
  * `Page`的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，我们不应该在其他代码中主动调用`Page`实例的生命周期函数
  * 打开参数
     * 小程序把页面的**打开路径**定义成**页面`URL`**，其组成格式和网页的`URL`类似，在页面路径后使用英文`?`分隔`path`和`query`部分，`query`部分的多个参数使用`&`进行分隔，参数的名字和值使用`key=value`的形式声明
     * 在页面`Page`构造器里`onLoad`的`option`可以拿到当前页面的**打开参数**，其类型是一个`Object`，其键值对与页面`URL`上`query`键值对一一对应
     * 和网页`URL`一样，页面`URL`上的`value`如果涉及特殊字符（例如：`&`字符、`?`字符、中文字符等，详情参考`URI`的`RFC3986`说明 ），需要采用`UrlEncode`后再拼接到页面`URL`上

* 页面的数据

宿主环境所提供的`Page`实例的原型中有`setData`函数，可以在`Page`实例下的方法调用`this.setData`把数据传递给渲染层，从而达到更新界面的目的。

由于小程序的渲染层和逻辑层分别在两个线程中运行，所以`setData`传递数据实际是一个异步的过程。`setData`的第二个参数是一个`callback`回调，在这次`setData`对界面渲染完毕后触发。

`setData`其一般调用格式是`setData(data, callback)`，其中`data`是由多个`key: value`构成的`Object`对象。`data`中的`key`还可以非常灵活，以数据路径的形式给出。

设置修改页面数据时需要注意的点：

1. 直接修改`Page`实例的`this.data`而不调用`this.setData`是无法改变页面的状态的，还会造成数据不一致
2. 由于`setData`是需要两个线程的一些通信消耗，**为了提高性能，每次设置的数据不应超过`1024kB`**
3. 不要把`data`中的任意一项的`value`设为`undefined`，否则可能会引起一些不可预料的`bug`

**提高小程序渲染性能遵循的原则：每次只设置需要改变的最小单位数据。**

* 页面的用户行为

小程序宿主环境提供了四个和页面相关的用户行为回调：

1. 下拉刷新`onPullDownRefresh`
   * 监听用户下拉刷新事件，需要在`app.json`的`window`选项中或页面配置`page.json`中设置`enablePullDownRefresh`为`true`。当处理完数据刷新后，`wx.stopPullDownRefresh`可以停止当前页面的下拉刷新
2. 上拉触底`onReachBottom`
   * 监听用户上拉触底事件。可以在`app.json`的`window`选项中或页面配置`page.json`中设置触发距离`onReachBottomDistance`。在触发距离内滑动期间，本事件只会被触发一次
3. 页面滚动`onPageScroll`
   * 监听用户滑动页面事件，参数为`Object`，包含`scrollTop`字段，表示页面在垂直方向已滚动的距离(单位`px`)
4. 用户转发`onShareAppMessage`
   * 只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮，在用户点击转发按钮的时候会调用，此事件需要`return`一个`Object`，包含`title`和`path`两个字段，用于自定义转发内容

* 页面跳转和路由

小程序通过**页面栈**来管理页面。(页面栈即是页面层级)

一个小程序拥有多个页面，可以通过`wx.navigateTo`推入一个新的页面，新的页面会进入页面栈内。

小程序宿主环境限制了页面栈的最大层级为`10`层，也就是当页面栈到达`10`层之后就没有办法再推入新的页面了。

和导航相关的`API`：(基于已有的页面栈`[pageA,pageB,pageC]`进行描述)

1. 使用`wx.navigateTo({url: 'pageD'})`可以往当前页面栈多推入一个`pageD`，此时页面栈变成`[pageA, pageB, pageC, pageD]`
2. 使用`wx.navigateBack()`可以退出当前页面栈的最顶上页面，此时页面栈变成`[pageA, pageB, pageC]`
3. 使用`wx.redirectTo({url: 'pageE'})`是替换当前页变成`pageE`，此时页面栈变成`[pageA, pageB, pageE]`，当页面栈到达`10`层没法再新增的时候，往往就是使用`redirectTo`这个`API`进行页面跳转
4. 小程序提供了原生的`Tabbar`支持，我们可以在`app.json`声明`tabBar`字段来定义`Tabbar`页
   * 可以在有`Tabbar`页的页面栈中，使用`wx.switchTab({url: 'pageF'})`，此时原来的页面栈会被清空(除了已经声明为`Tabbar`页`pageA`外其他页面会被销毁)，然后会切到`pageF`所在的`tab`页面，页面栈变成`[pageF]`，此时点击`Tab_PageA`切回到`pageA`时，`pageA`不会再触发`onLoad`，因为`pageA`没有被销毁
   * `Tabbar`页面初始化之后不会被销毁
5. 可以使用`wx.reLaunch({url: 'pageH'})`重启小程序，并且打开`pageH`，此时页面栈为`[pageH]`

**注：`wx.navigateTo`和`wx.redirectTo`只能打开非`TabBar`页面，`wx.switchTab`只能打开`Tabbar`页面**

[页面路由及对应的页面生命周期函数详情](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0004eec99acc808b00861a5bd5280a)见文档底部

##### 组件

