<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ben&#39;Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Ben&#39;Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ben&#39;Blog">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Ben'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ben'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工欲善其事，必先利其器</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/23/视图绘制渲染-性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/23/视图绘制渲染-性能优化/" class="post-title-link" itemprop="url">视图绘制渲染&性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-23 14:50:43" itemprop="dateCreated datePublished" datetime="2019-06-23T14:50:43+08:00">2019-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="UIKit框架结构"><a href="#UIKit框架结构" class="headerlink" title="UIKit框架结构"></a><code>UIKit</code>框架结构</h3><p><img src="/2019/06/23/视图绘制渲染-性能优化/UIKitFramework.png" alt="UIKitFramework"></p>
<p><code>UIKit</code>是常用的框架，显示、动画都通过<code>Core Animation</code>。<code>Core Animation</code>是核心动画，依赖于<code>OpenGL ES</code>做<code>GPU</code>渲染，<code>Core Graphics</code>做<code>CPU</code>渲染。最底层的<code>Graphics HardWare</code>是图形硬件。</p>
<h3 id="视图绘制渲染过程"><a href="#视图绘制渲染过程" class="headerlink" title="视图绘制渲染过程"></a>视图绘制渲染过程</h3><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><ul>
<li>软硬件流程</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/UIViewDrawFlow.png" alt="UIViewDrawFlow"></p>
<p>在屏幕上显示视图，需要<code>CPU</code>和<code>GPU</code>一起协作。一部分数据通过<code>Core Graphics</code>、<code>Core Image</code>由<code>CPU</code>预处理，最终通过<code>OpenGL ES</code>将数据传送到<code>GPU</code>，最终显示到屏幕</p>
<p><strong>Tips：</strong><code>Core Image支持CPU、GPU两种处理模式</code></p>
<ul>
<li>硬件参与流程</li>
</ul>
<p>上述流程硬件间数据的交互情况如下</p>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/HardwareDataFlow.png" alt="HardwareDataFlow"></p>
<p>整个流程中<code>CPU</code>将准备好的<code>bitmap</code>放到<code>RAM</code>里，<code>GPU</code>去搬这块内存到<code>VRAM</code>中处理。这个过程<code>GPU</code>所能承受的极限大概在<code>16.67ms</code>完成一帧的处理，所以<code>60fps</code>就是<code>GPU</code>能处理的最高频率</p>
<h4 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h4><h5 id="UIView从Draw到Render的过程"><a href="#UIView从Draw到Render的过程" class="headerlink" title="UIView从Draw到Render的过程"></a><code>UIView</code>从<code>Draw</code>到<code>Render</code>的过程</h5><p><img src="/2019/06/23/视图绘制渲染-性能优化/DrawToRenderFlow.jpeg" alt="DrawToRenderFlow"></p>
<ul>
<li>每一个<code>UIView</code>都有一个<code>layer</code>，每一个<code>layer</code>都有个<code>content</code>，这个<code>content</code>指向的是一块缓存，叫做<code>backing store</code></li>
<li><code>UIView</code>的绘制和渲染是两个过程，当<code>UIView</code>被绘制时，<code>CPU</code>执行<code>drawRect</code>，通过<code>context</code>将数据写入<code>backing store</code></li>
<li>当<code>backing store</code>写完后，通过<code>render server</code>交给<code>GPU</code>去渲染，将<code>backing store</code>中的<code>bitmap</code>数据显示在屏幕上</li>
</ul>
<h5 id="底层显示逻辑"><a href="#底层显示逻辑" class="headerlink" title="底层显示逻辑"></a>底层显示逻辑</h5><p><img src="/2019/06/23/视图绘制渲染-性能优化/DisplayFlow.png" alt="DisplayFlow"></p>
<ol>
<li><code>Core Animation</code>：通过<code>CPU</code>创建绘制视图，提交会话，包括自己和子树<code>(view hierarchy)</code>的<code>layout</code>状态，图片的解码和格式转换等</li>
<li><code>Render Server</code>：解析提交的子树状态，生成绘制指令</li>
<li><code>GPU</code>：执行绘制指令</li>
<li>显示渲染后的数据</li>
</ol>
<ul>
<li><code>Core Animation</code>和<code>Render Server</code>流程</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/CommitRenderDetailFlow.png" alt="CommitRenderDetailFlow"></p>
<ul>
<li><code>Core Animation</code>中<code>Commit Transaction</code>的详细过程</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/CommitTransactionDetailFlow.png" alt="CommitTransactionDetailFlow"></p>
<ul>
<li><code>Layout</code>(布局)</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/TransactionLayout.png" alt="TransactionLayout"></p>
<ol>
<li>调用<code>layoutSubviews</code>方法</li>
<li>调用<code>addSubview</code>方法(会触发调用<code>drawRect</code>方法)</li>
<li>填充内容，数据库查询</li>
<li>通常会造成<code>CPU</code>或者<code>I/O</code>瓶颈</li>
</ol>
<ul>
<li><code>Display</code>(显示)</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/TransactionDisplay.png" alt="TransactionDisplay"></p>
<ol>
<li>通过<code>drawRect:</code>绘制内容</li>
<li><code>String</code>绘制</li>
<li>通常会造成<code>CPU</code>或者内存瓶颈<ol>
<li>每个<code>UIView</code>都有<code>CALayer</code>，同时图层有一个像素存储空间，存放视图。调用<code>-setNeedsDisplay</code>的时候，仅会设置图层为<code>dirty</code>。当渲染系统准备就绪，调用视图的<code>-display</code>方法，同时装配像素存储空间，建立一个<code>Core Graphics</code>上下文(<code>CGContextRef</code>)，将上下文<code>push</code>进上下文堆栈，绘图程序进入对应的内存存储空间</li>
<li>如重写了视图的<code>-drawRect</code>，并在里面实现了指定的绘制代码，<code>UIKit</code>会将自动生成的<code>CGContextRef</code>放入上下文堆栈。当绘制完成后，视图的像素会被渲染到屏幕上。当下次再次调用视图的<code>-setNeedsDisplay</code>，将会再次调用<code>-drawRect</code>方法</li>
</ol>
</li>
</ol>
<ul>
<li><code>Prepare</code>(准备提交)</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/TransactionPrepare.png" alt="TransactionPrepare"></p>
<ol>
<li>图片解码，把图片从<code>PNG</code>或<code>JPEG</code>等格式中解压出来，得到像素数据</li>
<li>图片格式转换，如果<code>GPU</code>不支持这种颜色格式，<code>CPU</code>需要进行格式转换，因此尽量使用GPU能支持的图片格式。比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化</li>
</ol>
<ul>
<li><code>Commit</code>(提交)</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/TransactionCommit.png" alt="TransactionCommit"></p>
<ol>
<li>打包<code>layers</code>并且提交到<code>Render Server</code>中</li>
<li>递归提交子树的<code>layers</code></li>
<li>如果子树很复杂，对<code>CPU</code>消耗很大，对性能造成影响，因此尽可能简化<code>viewTree</code></li>
</ol>
<h5 id="页面卡顿"><a href="#页面卡顿" class="headerlink" title="页面卡顿"></a>页面卡顿</h5><ul>
<li><p>相关概念</p>
<ul>
<li>帧率：以一致且稳定的帧速率呈现您的绘图。<ul>
<li><code>60fps</code>是<code>Apple</code>给出的最佳帧率，相当于每帧<code>16.67ms</code>。但是实际中如果能保证帧率可以稳定到<code>30fps</code>就能保证不会有卡顿的现象，<code>60fps</code>更多用在游戏上。所以如果应用能够保证<code>33.4ms</code>绘制一次屏幕，基本上就不会卡了</li>
</ul>
</li>
<li><code>VSync</code>信号<ul>
<li><code>iOS</code>的显示系统是由<code>VSync</code>信号驱动的，<code>VSync</code>信号由硬件时钟生成，每秒钟发出<code>60</code>次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。<code>iOS</code>图形服务接收到<code>VSync</code>信号后，会通过<code>IPC</code>通知到<code>App</code>内。<code>App</code>的<code>Runloop</code>在启动后会注册对应的<code>CFRunLoopSource</code>通过<code>mach_port</code>接收传过来的时钟信号通知，随后<code>Source</code>的回调会驱动整个<code>App</code>的动画与显示</li>
</ul>
</li>
</ul>
</li>
<li><p>卡顿原因</p>
</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/LoseFrame.png" alt="LoseFrame"></p>
<p>在<code>VSync</code>信号到来后，系统图形服务会通过<code>CADisplayLink</code>等机制通知<code>App</code>，<code>App</code>主线程开始在<code>CPU</code>中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后<code>CPU</code>会将计算好的内容提交到<code>GPU</code>去，由<code>GPU</code>进行变换、合成、渲染。随后<code>GPU</code>会把渲染结果提交到帧缓冲区去，等待下一次<code>VSync</code>信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个<code>VSync</code>时间内，<code>CPU</code>或者<code>GPU</code>没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<p>由此可知<code>CPU</code>和<code>GPU</code>不论哪个阻碍了显示流程(执行的操作复杂，耗时超过了<code>16.67ms</code>)，都会造成掉帧产生卡顿现象。所以开发时，需要分别对<code>CPU</code>和<code>GPU</code>压力进行评估和优化(进行渲染性能优化的依据)。</p>
<h5 id="绘制渲染过程中CPU、GPU资源消耗的情况"><a href="#绘制渲染过程中CPU、GPU资源消耗的情况" class="headerlink" title="绘制渲染过程中CPU、GPU资源消耗的情况"></a>绘制渲染过程中<code>CPU</code>、<code>GPU</code>资源消耗的情况</h5><h6 id="CPU资源消耗的原因"><a href="#CPU资源消耗的原因" class="headerlink" title="CPU资源消耗的原因"></a><code>CPU</code>资源消耗的原因</h6><ul>
<li>对象创建 <ul>
<li>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗<code>CPU</code>资源。<strong>尽量用轻量的对象代替重量的对象，可以对性能有所优化。</strong>比如用<code>CALayer</code>代替<code>UIView</code>,用<code>CATextLayer</code>代替<code>UILabel</code></li>
<li>通过<code>Storyboard</code>创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多</li>
</ul>
</li>
<li>对象销毁<ul>
<li>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显</li>
<li>如果对象可以放到后台线程去释放，那就挪到后台线程去释放</li>
</ul>
</li>
<li>对象调整<ul>
<li>当视图层次调整时，<code>UIView</code>、<code>CALayer</code>之间会出现很多方法调用与通知，所以在<strong>优化性能时，应该尽量避免调整视图层次、添加和移除视图</strong></li>
</ul>
</li>
<li>布局计算<ul>
<li>视图布局的计算是<code>App</code>中最为常见的消耗<code>CPU</code>资源的地方</li>
<li>如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了</li>
</ul>
</li>
<li><code>Autolayout</code><ul>
<li><code>Autolayout</code>对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，<code>Autolayout</code>带来的<code>CPU</code>消耗会呈指数级上升。参考数据可看<a href="http://pilky.me/36/" target="_blank" rel="noopener">这里</a></li>
</ul>
</li>
<li>文本计算<ul>
<li>如果一个界面中包含大量文字，文本的宽高计算会占用很大一部分资源，并且不可避免</li>
<li>如果对文本显示没有特殊要求，可以参考下<code>UILabel</code>内部的实现方式：用<code>[NSAttributedString boundingRectWithSize:options:context:]</code>来计算文本宽高，用<code>-[NSAttributedString drawWithRect:options:context:]</code>来绘制文本。另外这两个操作尽可能的在后台操作</li>
</ul>
</li>
<li>文本渲染<ul>
<li>屏幕上能看到的所有文本内容控件，包括<code>UIWebView</code>，在底层都是通过<code>CoreText</code>排版、绘制为<code>Bitmap</code>显示的</li>
<li>常见的文本控件(<code>UILabel</code>、<code>UITextView</code>等)，其排版和绘制都是在主线程进行的，当显示大量文本时，<code>CPU</code>的压力会非常大<ul>
<li>对此解决方案只有一个，那就是自定义文本控件，用<code>TextKit</code>或最底层的<code>CoreText</code>对文本异步绘制</li>
<li>尽管这实现起来非常麻烦，但其带来的优势也非常大，<code>CoreText</code>对象创建好后，能直接获取文本的宽高等信息，避免了多次计算(调整<code>UILabel</code>大小时算一遍、<code>UILabel</code>绘制时内部再算一遍)。<code>CoreText</code>对象占用内存较少，可以缓存下来以备稍后多次渲染</li>
</ul>
</li>
</ul>
</li>
<li>图片的解码<ul>
<li>当用<code>UIImage</code>或<code>CGImageSource</code>的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到<code>UIImageView</code>或者<code>CALayer.contents</code>中去，并且<code>CALayer</code>被提交到<code>GPU</code>前，<code>CGImage</code>中的数据才会得到解码。<strong>这一步是发生在主线程的，并且不可避免。</strong></li>
<li>如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到<code>CGBitmapContext</code>中，然后从<code>Bitmap</code>直接创建图片。目前常见的网络图片库都自带这个功能</li>
</ul>
</li>
<li>图像的绘制<ul>
<li>图像的绘制通常是指用那些以<code>CG</code>开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。</li>
<li>图像绘制最常见的地方就是<code>[UIView drawRect:]</code>里面了。由于<code>Core Graphic</code>方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行</li>
</ul>
</li>
<li>图片的格式<ul>
<li>把图片从<code>PNG</code>或<code>JPEG</code>等格式中解压出来，得到像素数据。如果<code>GPU</code>不支持这种颜色格式，需要<code>CPU</code>进行格式转换，所以，图片要用<code>GPU</code>支持的图片数据格式</li>
</ul>
</li>
</ul>
<h6 id="图片解码和图像绘制的代码示例"><a href="#图片解码和图像绘制的代码示例" class="headerlink" title="图片解码和图像绘制的代码示例"></a>图片解码和图像绘制的代码示例</h6><p><img src="/2019/06/23/视图绘制渲染-性能优化/图片解码和图像绘制的代码示例.png" alt="图片解码和图像绘制的代码示例"></p>
<h6 id="GPU资源消耗的原因"><a href="#GPU资源消耗的原因" class="headerlink" title="GPU资源消耗的原因"></a><code>GPU</code>资源消耗的原因</h6><p>相对于<code>CPU</code>来说，<code>GPU</code>能干的事情比较单一：接收提交的纹理(<code>Texture</code>)和顶点描述(三角形)，应用变换(<code>transform</code>)、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理(图片)和形状(三角模拟的矢量图形)两类</p>
<ul>
<li>纹理的渲染<ul>
<li>所有的<code>Bitmap</code>，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为<code>GPU Texture</code></li>
<li>不论是提交到显存的过程，还是<code>GPU</code>调整和渲染<code>Texture</code>的过程，都要消耗不少<code>GPU</code>资源</li>
<li>当在较短时间显示大量图片时(比如<code>TableView</code>存在非常多的图片并且快速滑动时)，<code>CPU</code>占用率很低，<code>GPU</code>占用非常高，界面仍然会掉帧</li>
<li>避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示</li>
<li>当图片过大，超过<code>GPU</code>的最大纹理尺寸时，图片需要先由<code>CPU</code>进行预处理，这对<code>CPU</code>和<code>GPU</code>都会带来额外的资源消耗</li>
<li>目前来说，<code>iPhone 4S</code>以上机型，纹理尺寸上限都是<code>4096x4096</code>。所以，尽量不要让图片和视图的大小超过这个值。详细资料可看<a href="http://iosres.com" target="_blank" rel="noopener">这里</a></li>
</ul>
</li>
<li>视图的混合(<code>Composing</code>)<ul>
<li>当出现重叠的<code>UIView</code>或者<code>CALayer</code>的时候，<code>GPU</code>会去计算混合部分的像素，所以，尽可能少的设置<code>alpha</code>,尽可能多的设置背景颜色为纯色的背景</li>
<li>设置<code>backgroundColor</code>较设置<code>opaque = true</code>更为有效</li>
</ul>
</li>
<li>图形的生成<ul>
<li><code>CALayer</code>的<strong><code>border</code>、圆角、阴影、遮罩(<code>mask</code>)，<code>CASharpLayer</code>的矢量图形显示</strong>，通常<strong>会触发离屏渲染(<code>offscreen rendering</code>)</strong>，而<strong>离屏渲染通常发生在<code>GPU</code>中</strong>。离屏渲染的过程会消耗大量的<code>GPU</code>资源，因此因尽量避免触发离屏渲染<ul>
<li>如，当一个列表视图中出现大量圆角的<code>CALayer</code>，并且快速滑动时，可以观察到<code>GPU</code>资源已经占满，而<code>CPU</code>资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低</li>
<li>为了避免这种情况，可以尝试开启<code>CALayer.shouldRasterize</code>属性，但这会把原本离屏渲染的操作转嫁到<code>CPU</code>上去</li>
</ul>
</li>
<li>对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果</li>
<li>最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性</li>
</ul>
</li>
</ul>
<h5 id="Tile-Based渲染"><a href="#Tile-Based渲染" class="headerlink" title="Tile-Based渲染"></a><code>Tile-Based</code>渲染</h5><p><code>Tiled-Based</code>渲染是移动设备的主流。整个屏幕会分解成<code>N*Npixels</code>组成的瓦片(<code>Tiles</code>)，<code>tiles</code>存储于<code>SoC</code>缓存(<code>SoC=system on chip</code>，片上系统，是在整块芯片上实现一个复杂系统功能，如<code>intel cpu</code>，整合了集显，内存控制器，<code>cpu</code>运核心，缓存，队列、非核心和<code>I/O</code>控制器)。几何形状会分解成若干个<code>tiles</code>，对于每一块<code>tile</code>，把必须的几何体提交到<code>OpenGL ES</code>，然后进行渲染(光栅化)。完毕后，将<code>tile</code>的数据发送回<code>cpu</code>。资料见<a href="https://github.com/loyinglin/LearnOpenGLES/tree/master/util/资料" target="_blank" rel="noopener">落影大神的PDF</a></p>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/TiledBased.png" alt="TiledBased"></p>
<ul>
<li><code>GPU</code>屏幕渲染的两种方式<ul>
<li>当前屏幕渲染(<code>On-Screen Rendering</code>，即正常渲染)，指的是<code>GPU</code>的渲染操作是在当前用于显示的屏幕缓冲区中进行</li>
<li>离屏渲染(<code>Off-Screen Rendering</code>)，指的是<code>GPU</code>在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
</ul>
</li>
</ul>
<h6 id="正常渲染和离屏渲染"><a href="#正常渲染和离屏渲染" class="headerlink" title="正常渲染和离屏渲染"></a>正常渲染和离屏渲染</h6><ul>
<li>正常渲染的渲染管道</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/NormalRenderPipe.png" alt="NormalRenderPipe"></p>
<ol>
<li><code>Command Buffer：`</code>OpenGL<code>提交一个渲染指令给</code>Command Buffer<code>，然后进行</code>GPU`渲染</li>
<li><code>Tiler：</code>调用顶点着色器，把顶点数据进行分块(<code>Tiling</code>)</li>
<li><code>Parameter Buffer：</code>接受分块完毕的<code>tile</code>和对应的渲染参数</li>
<li><code>Renderer：</code>调用片元着色器，进行像素渲染</li>
<li><code>Render Buffer:：</code>缓冲区，存储渲染完毕的像素</li>
</ol>
<ul>
<li><p>离屏渲染</p>
<ul>
<li><p>为什么需要离屏渲染</p>
<ul>
<li>一般情况下，<code>OpenGL</code>会将提交到渲染服务(<code>Render Server</code>)的动画直接渲染，但是对于一些复杂的图像动画不能直接进行叠加渲染显示，而是需要根据<code>Command Buffer</code>分通道进行渲染之后再组合，在组合过程中，有些渲染通道不会直接显示，而这些没有直接显示在屏幕上的通道就是<code>Offscreen Render Pass</code></li>
<li>离屏渲染(<code>Offscreen Render</code>)需要更多的渲染通道，而不同的渲染通道切换需要耗费一定的时间，这个时间内<code>GPU</code>会闲置，当通道达到一定数量，对性能会有较大的影响</li>
</ul>
</li>
<li><p>离屏渲染的渲染管道(不同的离屏渲染效果，会有不同数量的渲染通道)</p>
<ul>
<li>遮罩(<code>mask</code>)</li>
</ul>
</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/MaskOffscreenRender.png" alt="MaskOffscreenRender"></p>
<ol>
<li>在第一条渲染管道中，<code>GPU</code>创建了一个新的缓存区来存储相机纹理(<code>Texture</code>)的渲染结果(渲染<code>layer</code>的<code>mask</code>纹理，同<code>Tile-Based的</code>基本渲染逻辑)</li>
<li>在第二条渲染管道中，<code>GPU</code>创建了一个新的缓存区来存储蓝色的蒙版(<code>layer</code>)的渲染结果(渲染<code>layer</code>的<code>content</code>纹理，同<code>Tile-Based</code>的基本渲染逻辑)</li>
<li>在第三条渲染管道中，才把前面的两个渲染结果取出来，合并组合，放到<code>Render Buffer</code>中(<code>Compositing</code>操作，合并<code>1、2</code>的纹理)</li>
</ol>
<p><strong>注意：前面的两个渲染结果并没有直接放到Render Buffer中，而是临时保存</strong></p>
<p>由此可见，离屏渲染的消耗主要体现在两方面：</p>
<ol>
<li>创建新的缓存区</li>
<li><p>上下文的切换。先是从当前屏幕切换到离屏，等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的</p>
<ul>
<li>模糊效果(<code>UIBlurEffect</code>)</li>
</ul>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/BlurEffect01.png" alt="BlurEffect01"></p>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/BlurEffect02.png" alt="BlurEffect02"></p>
<p>使用<code>UIBlurEffect</code>，应该是尽可能小的<code>view</code>，因为性能消耗巨大</p>
</li>
</ol>
</li>
</ul>
<h6 id="常见的会触发离屏渲染操作的情况如下"><a href="#常见的会触发离屏渲染操作的情况如下" class="headerlink" title="常见的会触发离屏渲染操作的情况如下"></a>常见的会触发离屏渲染操作的情况如下</h6><ul>
<li><p><code>shouldRasterize</code>(光栅化)</p>
<ul>
<li>这是一个手动开启离屏渲染的操作，开启光栅化是将一个<code>layer</code>预先渲染成位图(<code>bitmap</code>)，然后加入缓存中，当需要的时候再从缓存中拿出来，如果光栅化的元素在<code>100ms</code>内没有被使用就会被移除</li>
<li>因此，光栅化适用于静态内容的视图，也就是内部结构和内容不发生变化的视图，当视图的内容和结构一直在发生变化，就不应该开启光栅化，因为它会一直创建缓存</li>
</ul>
</li>
<li><p><code>masks</code>(遮罩)</p>
<ul>
<li>单独设置<code>cornerRadius</code>或者<code>masksToBounds = true</code>，并不会引起离屏渲染，他们的合体才会引起离屏渲染</li>
<li>为避免遮罩引起的离屏渲染，效果上的处理，可参考<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVebo</a>，在要添加圆角的视图上再叠加一个部分透明的视图，只对圆角部分进行遮挡，遮挡的部分背景与周围背景相同</li>
<li>彻底的方法还是在后台线程中利用<code>CoreGraphic</code>来绘制图片，避免引起离屏渲染</li>
</ul>
</li>
<li><p><code>shadows</code>(阴影)</p>
<ul>
<li>可以通过指定阴影路径，避免离屏渲染。如，<code>imgView.layer.shadowPath =UIBezierPath(rect: imgView.bounds).CGPath</code></li>
</ul>
</li>
<li><p><code>EdgeAntialiasing</code>(抗锯齿)</p>
<ul>
<li>这个功能貌似在<code>iOS 8</code>和<code>iOS 9</code>上并不会触发离屏渲染，对性能也没有什么影响，也许这个功能已经被优化了</li>
</ul>
</li>
<li><p><code>-(void)drawRect</code>(<code>CPU</code>离屏渲染)</p>
<ul>
<li>如果重写了<code>drawRect</code>方法，并且使用<code>Core Graphics</code>的技术进行了绘制操作，就涉及到了<code>CPU</code>渲染</li>
<li>整个渲染过程由<code>CPU</code>在<code>App</code>内同步地完成，渲染得到的<code>bitmap</code>最后再交由<code>GPU</code>用于显示</li>
<li>但是应该尽量避免这种方法，因为如果使用这个方法不恰当的话会使内存暴涨，因<code>CPU</code>自身做渲染的性能也不好。重写drawRect致使内存暴涨的原因见<a href="https://bihongbo.com/2016/01/03/memoryGhostdrawRect/" target="_blank" rel="noopener">内存恶鬼drawRect</a></li>
<li>因此，能避免重写drawRect方法就尽可能避免</li>
</ul>
</li>
</ul>
<p>离屏渲染的优化可见<a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a></p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p><code>WWDC</code>推荐的检查项目</p>
<p><img src="/2019/06/23/视图绘制渲染-性能优化/PropertyOptimizeByWWDC.png" alt="PropertyOptimizeByWWDC"></p>
<ul>
<li>根据<code>WWDC</code>推荐的检查项目进行检查<ul>
<li>帧率一般在多少？<ul>
<li><code>60</code>帧每秒 (<code>TimeProfiler</code>)</li>
</ul>
</li>
<li>是否存在<code>CPU</code>和<code>GPU</code>瓶颈？(通过工具查看占有率来进行检查)<ul>
<li>更少的使用<code>CPU</code>和<code>GPU</code>可以有效的保存电量</li>
</ul>
</li>
<li>额外的使用<code>CPU</code>来进行渲染？<ul>
<li>重写了<code>drawRect</code>会导致<code>CPU</code>渲染</li>
<li>在<code>CPU</code>进行渲染时，<code>GPU</code>大多数情况是处于等待状态</li>
</ul>
</li>
<li>是否存在过多离屏渲染？<ul>
<li>越少越好</li>
<li>离屏渲染会导致上下文切换，<code>GPU</code>产生<code>idle</code>(闲置)；</li>
</ul>
</li>
<li>是否渲染过多视图？<ul>
<li>视图越少越好</li>
<li>透明度为1的视图更受欢迎</li>
</ul>
</li>
<li>使用奇怪的图片格式和大小？<ul>
<li>避免格式转换和调整图片大小</li>
<li>一个图片如果不被<code>GPU</code>支持，那么需要<code>CPU</code>来转换。（<code>Xcode</code>有对<code>PNG</code>图片进行特殊的算法优化）</li>
</ul>
</li>
<li>使用昂贵的特效？<ul>
<li>理解特效的消耗，同时调整合适的大小</li>
<li>例如前面提到的<code>UIBlurEffect</code></li>
</ul>
</li>
<li>视图树上不必要的元素？<ul>
<li>理解视图树上所有点的必要性，去掉不必要的元素</li>
<li>忘记<code>remove</code>视图是很常见的事情，特别是当<code>View</code>的类比较大的时候，因此需检查<code>remove</code>掉不需要的视图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="性能检查中使用的工具"><a href="#性能检查中使用的工具" class="headerlink" title="性能检查中使用的工具"></a>性能检查中使用的工具</h4><p>遇到性能问题，先分析、定位问题所在。分析、定位问题可使用工具<code>Xcode</code>、<code>Instrument</code>。</p>
<h5 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a><code>Xcode</code></h5><p>使用<code>Xcode</code>查看应用的渲染情况。查看渲染情况选项的设置，<code>Xcode</code>导航栏 中的<code>Debug -&gt;View Debuging -&gt;Rendering</code>。</p>
<h6 id="具体选项的功能及标识颜色"><a href="#具体选项的功能及标识颜色" class="headerlink" title="具体选项的功能及标识颜色"></a>具体选项的功能及标识颜色</h6><ul>
<li><p><code>Color Blended Layers</code>(混合)</p>
<ul>
<li>这个选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，<strong>越红表示性能越差</strong>，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起</li>
</ul>
</li>
<li><p><code>Color Hits Green and Misses Red</code>(命中/不命中)</p>
<ul>
<li>当<code>UIView.layer.shouldRasterize = YES</code>时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如<code>UITableViewCell</code>的复用)使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。<strong>红色越多，性能越差</strong>。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜</li>
</ul>
</li>
<li><p><code>Color Copied Images</code></p>
<ul>
<li>对于<code>GPU</code>不支持的色彩格式的图片只能由<code>CPU</code>来处理，把这样的图片标为蓝色。<strong>蓝色越多，性能越差</strong></li>
</ul>
</li>
<li><p><code>Color Immediately</code></p>
<ul>
<li>通常<code>Core Animation Instruments</code>以每毫秒<code>10</code>次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）</li>
</ul>
</li>
<li><p><code>Color Misaligned Images</code></p>
<ul>
<li>这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。<strong>黄色、紫色越多，性能越差</strong></li>
</ul>
</li>
<li><p><code>Color Offscreen-Rendered Yellow</code>(离屏渲染)</p>
<ul>
<li>这个选项会把那些离屏渲染的图层显示为黄色。<strong>黄色越多，性能越差</strong>。这些显示为黄色的图层很可能需要用<code>shadowPath</code>或者<code>shouldRasterize</code>来优化</li>
</ul>
</li>
<li><p><code>Color OpenGL Fast Path Blue</code></p>
<ul>
<li>这个选项会把任何直接使用<code>OpenGL</code>绘制的图层显示为蓝色。蓝色越多，性能越好。如果仅仅使用<code>UIKit</code>或者<code>Core Animation</code>的<code>API</code>，那么不会有任何效果</li>
</ul>
</li>
<li><p><code>Flash Updated Regions</code></p>
<ul>
<li>这个选项会把重绘的内容显示为黄色。<strong>黄色越多，性能越差</strong>。通常我们希望只是更新的部分被标记为黄色</li>
</ul>
</li>
</ul>
<h5 id="Instrument"><a href="#Instrument" class="headerlink" title="Instrument"></a><code>Instrument</code></h5><p>开启<code>Instrument</code>，<code>command + I</code></p>
<p>使用<code>Instrument</code>除了跟踪程序崩溃原因，还可使用其<code>Core Animation</code>和<code>GPU driver</code>来看视图渲染过程中的性能</p>
<ul>
<li><code>Core Animation</code><ul>
<li><code>Color Blended Layers</code>：看半透明<code>layer</code>的遮盖情况</li>
<li><code>Core Animation template</code>只是能让开发者直观地看到哪些地方有可能需要优化，但是到底要不要优化，还是要看<code>GPU driver</code>的表现</li>
</ul>
</li>
<li><code>GPU Driver</code><ul>
<li><code>Renderer Utilization</code> ——如果这个值大于50%的话，表示<code>GPU</code>的性能受到<code>fill-rate</code>的限制，可能有太多的<code>Offscreen rendering</code>，<code>overdraw</code>，<code>blending</code></li>
<li><code>Tiler Utilization</code> ——如果这个值大于<code>50%</code>，表示可能有太多的<code>layers</code></li>
</ul>
</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol>
<li><code>APP</code>从点击屏幕（硬件）到完全渲染，中间发生了什么?(视图呈现到屏幕上，经过了哪些流程?)</li>
</ol>
<p>程序执行<code>addSubview:</code>时，一个视图由<code>CPU</code>进行<code>Frame</code>布局，准备视图和图层的层级关系，查询是否有重写<code>drawRect:</code>或<code>drawLayer:inContext:</code>方法。<strong>注意：如果有重写的话，这里的渲染是会占用CPU进行处理的。</strong><code>CPU</code>会将处理视图和图层的层级关系打包，通过<code>IPC</code>(内部处理通信)通道提交给渲染服务，渲染服务由<code>OpenGL ES</code>和<code>GPU</code>组成。渲染服务首先将图层数据交给<code>OpenGL ES</code>进行纹理生成和着色。生成前后帧缓存，再根据显示硬件的刷新频率，一般以设备的<code>Vsync</code>信号和<code>CADisplayLink</code>为标准，进行前后帧缓存的切换。最后，将最终要显示在画面上的后帧缓存交给<code>GPU</code>，进行采集图片和形状，运行变换，应用文理和混合。最终显示在屏幕上。</p>
<ol start="2">
<li><p><code>UIView</code>是如何显示到屏幕上的</p>
<ul>
<li>需要从<code>RunLoop</code>开始，<code>RunLoop</code>是一个<code>60fps</code>的回调，即每<code>16.67ms</code>绘制一次屏幕，也就是需要在这个时间内完成<code>view</code>缓冲区的创建</li>
<li><code>view</code>内容的绘制是<code>CPU</code>的工作，然后把缓冲区交给<code>GPU</code>渲染</li>
<li>渲染包括了多个view的拼接<code>(compositing)</code>、纹理的渲染<code>(Texture)</code>等，最后<code>Display</code>到屏幕上</li>
<li>但如果在<code>16.67ms</code>内要处理的操作太多，导致<code>CPU、GPU</code>无法在指定的时间内完成指定的工作，那么就会出现卡顿现象，即丢帧<ul>
<li><code>60fps</code>是<code>Apple</code>给出的最佳帧率，但是实际中如果能保证帧率可以稳定到<code>30fps</code>就能保证不会有卡顿的现象，<code>60fps</code>更多用在游戏上。所以如果应用能够保证<code>33.4ms</code>绘制一次屏幕，基本上就不会卡了</li>
</ul>
</li>
</ul>
</li>
<li><p><code>UIView</code>从<code>Draw</code>到<code>Render</code>的过程有如下几步</p>
<ul>
<li>每一个<code>UIView</code>都有一个<code>layer</code>，每一个<code>layer</code>都有个<code>content</code>，这个<code>content</code>指向的是一块缓存，叫做<code>backing store</code>。<strong>缓存区</strong></li>
<li><code>UIView</code>的绘制和渲染是两个过程，当<code>UIView</code>被绘制时，<code>CPU</code>执行<code>drawRect</code>，通过<code>context</code>将数据写入<code>backing store</code>。<strong>绘制数据写入缓存区</strong></li>
<li>当<code>backing store</code>写完后，通过<code>render server</code>交给<code>GPU</code>去渲染，将<code>backing store</code>中的<code>bitmap</code>数据显示在屏幕上。<strong>缓存区数据的渲染</strong></li>
<li>总结：<code>CPU</code>就是做绘制的操作把内容放到缓存里，<code>GPU</code>负责从缓存里读取数据然后渲染到屏幕上。<strong>CPU-绘制、GPU-渲染</strong>。过程如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Screen -Display/Link-&gt; GPU(VRAM) &lt;-&gt; CPU(RAM)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>  即<code>CPU</code>将准备好的<code>bitmap</code>放到<code>RAM</code>里，<code>GPU</code>去搬这块内存到<code>VRAM</code>中处理。这个过程<code>GPU</code>所能承受的极限大概在<code>16.67ms</code>完成一帧的处理，所以<code>60fps</code>就是<code>GPU</code>能处理的最高频率</p>
<ol start="4">
<li><code>iOS</code>上视图或动画渲染的各个阶段</li>
</ol>
<p>共有<code>6</code>个步骤</p>
<p>在<code>APP</code>内部的有<code>4</code>个阶段</p>
<ul>
<li>布局，在这个阶段，设置<code>layer</code>的属性</li>
<li>创建，创建<code>backing image</code>。可以通过<code>setContents</code>将一个<code>image</code>传给<code>layer</code>，或通过<code>drawRect:/drawLayer:inContext:</code>来画出来</li>
<li>准备，在这个阶段，准备要渲染的<code>layer</code>的各种属性数据，以及要做的动画的参数，准备传给<code>render server</code>。同时在这个阶段会解压要渲染的<code>image</code></li>
<li>提交，在这个阶段，<code>Core Animation</code>打包<code>layer</code>的信息以及要做的动画的参数，通过<code>IPC</code>传递给<code>render server</code></li>
</ul>
<p>在<code>APP</code>外部的<code>2</code>个阶段，当提交的数据到达<code>render server</code>后，会做下面两件事</p>
<ul>
<li>根据<code>layer</code>的各种属性(如果是动画的，会计算动画的<code>layer</code>的属性的中间值)，用<code>OpenGL</code>准备渲染</li>
<li>渲染这些可视的<code>layer</code>到屏幕</li>
</ul>
<ol start="5">
<li>渲染性能优化的注意点</li>
</ol>
<ul>
<li>隐藏的绘制：<code>catextlayer</code>和<code>uilabel</code>都是将<code>text</code>画入<code>backing image</code>的。如果改了一个包含<code>text</code>的<code>view</code>的<code>frame</code>的话，<code>text</code>会被重新绘制</li>
<li><code>Rasterize</code>：当使用<code>layer</code>的<code>shouldRasterize</code>的时候（记得设置适当的<code>layer</code>的<code>rasterizationScale</code>），<code>layer</code>会被强制绘制到一个<code>offscreen image</code>上，并且会被缓存起来。这种方法可以用来缓存绘制耗时（比如有比较绚的效果）但是不经常改的<code>layer</code>，如果<code>layer</code>经常变，就不适合用</li>
<li>避免离屏渲染，因使用圆角、遮罩、阴影等效果，会产生离屏渲染过程。因此想要上述效果时，能通过图片伸展实现的，就尽量不要使<code>layer</code>上对应的属性来实现上述效果。如，实现<code>rounded corner</code>，可以将一个圆形的图片赋值于<code>layer</code>的<code>content</code>的属性。并且设置好<code>contentsCenter</code>和<code>contentScale</code>属性</li>
<li><code>Blending and Overdraw</code>：如果一个<code>layer</code>被另一个<code>layer</code>完全遮盖，<code>GPU</code>会做优化不渲染被遮盖的<code>layer</code>，但是计算一个<code>layer</code>是否被另一个<code>layer</code>完全遮盖是很耗<code>cpu</code>的。将几个半透明的<code>layer</code>的<code>color</code>融合在一起也是很消耗<code>cpu</code>的</li>
</ul>
<p>基于上述原因，在开发过程中，为保证渲染性能的最优，常依据如下规则进行操作</p>
<ul>
<li>设置<code>view</code>的<code>backgroundColor</code>为一个固定的，不透明的<code>color</code></li>
<li>如果一个<code>view</code>是不透明的，设置<code>opaque</code>属性为<code>YES</code>。（直接告诉程序这个是不透明的，而不是让程序去计算）这样会减少<code>blending</code>(调和)和 <code>overdraw</code></li>
<li>如果使用<code>image</code>的话，尽量避免设置<code>image</code>的<code>alpha</code>为透明的，如果一些效果需要几个图片融合而成，就让设计用一张图画好，不要让程序在运行的时候去动态的融合</li>
</ul>
<ol start="6">
<li><code>GPU</code>的挑战</li>
</ol>
<ul>
<li>将数据从<code>RAM</code>搬到<code>VRAM</code>中</li>
<li><p>将<code>Texture</code>(纹理)渲染到屏幕上(主要的瓶颈点)，渲染纹理基本要处理以下问题</p>
<ul>
<li>合成<code>(compositing)</code><ul>
<li><code>Compositing</code>是指将多个纹理拼到一起的过程，对应<code>UIKit</code>，是指处理多个<code>view</code>合到一起的情况(<code>drawRect</code>只有当<code>addsubview</code>情况下才会触发)。如果<code>view</code>之间没有叠加，那么<code>GPU</code>只需要做普通渲染即可。 如果多个<code>view</code>之间有叠加部分，<code>GPU</code>需要做混合<code>(blending)</code></li>
</ul>
</li>
<li>尺寸<code>(Size)</code><ul>
<li>这个问题，主要是处理<code>image</code>带来的，假如内存里有一张<code>400x400</code>的图片，要放到<code>100x100</code>的<code>imageview</code>里，如果不做任何处理，直接丢进去，问题就大了，这意味着，<code>GPU</code>需要对大图进行缩放到小的区域显示，需要做像素点的(取样)<code>sampling</code>，这种<code>smapling</code>的代价很高，又需要兼顾像素配向<code>pixel alignment</code>。计算量会飙升。</li>
</ul>
</li>
<li><p>离屏渲染<code>(Offscreen Rendering And Mask)</code></p>
<ul>
<li><p><code>iOS</code>中图形绘制框架的结构<br><code>UIKit</code>是<code>iOS</code>中用来管理用户图形交互的框架，但是<code>UIKit</code>本身构建在<code>Core Animation</code>框架之上，<code>Core Animation</code>分成了两部分<code>OpenGL ES</code>和<code>Core Graphics</code>，<code>OpenGL ES</code>是直接调用底层的<code>GPU</code>进行渲染；<code>Core Graphics</code>是一个基于<code>CPU</code>的绘制引擎</p>
</li>
<li><p><code>OpenGL</code>中，<code>GPU</code>屏幕渲染有以下两种方式</p>
<ul>
<li><code>On-Screen Rendering</code>即当前屏幕渲染，指的是<code>GPU</code>的渲染操作是在当前用于显示的屏幕缓冲区中进行</li>
<li><code>Off-Screen Rendering</code>即离屏渲染，指的是<code>GPU</code>在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
<li>离屏渲染的代价主要包括两方面内容<ul>
<li>创建新的缓冲区</li>
<li>上下文的切换<ul>
<li>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕<code>(On-Screen)</code>切换到离屏<code>(Off-Screen)</code>；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的</li>
</ul>
</li>
</ul>
</li>
<li>触发离屏渲染的方式<ul>
<li><code>shouldRasterize</code>（光栅化）</li>
<li><code>masks</code>（遮罩）</li>
<li><code>shadows</code>（阴影）</li>
<li><code>edge antialiasing</code>（抗锯齿）</li>
<li><code>group opacity</code>（不透明）</li>
</ul>
</li>
</ul>
</li>
<li><p>对于<strong>当屏渲染、离屏渲染和CPU渲染</strong>的来说，当屏渲染永远是最好的选择</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/18/网络编程/" class="post-title-link" itemprop="url">网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-18 10:46:25" itemprop="dateCreated datePublished" datetime="2019-06-18T10:46:25+08:00">2019-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是网络编程"><a href="#什么是网络编程" class="headerlink" title="什么是网络编程"></a>什么是网络编程</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>网络编程就是如何在<strong>程序中实现</strong>两台计算机的通信。网络通信是两台计算机上的两个进程之间的通信。<strong>网络编程是为了实现网络通信</strong>。网络编程对所有开发语言都是一样的，用不同的开发语言进行网络编程，就是在对应的开发语言开发的<strong>程序本身这个进程内</strong>，连接别的服务器进程的通信端口进行通信。网络通讯中的对象是进程，在网络通讯过程中，通过主机名(或IP地址)和端口号的组合来唯一确定进程。</p>
<p>网络编程最主要的工作就是在发送端把信息通过<strong>规定的协议</strong>进行组装包，在接收端按照规定好的协议把包进行解析，从而提取出对应的信息，达到通信的目的。网络编程过程中，主要的操作是数据包的组装、过滤、捕获、分析。</p>
<p>现在的网络编程基本上是基于<strong>请求/响应方式</strong>的，即一个设备发送请求数据给另外一个设备，然后接收另一个设备的反馈。目前较为流行的网络编程模型是客户端/服务器(C/S)结构。在网络编程中，发起连接请求的程序为客户端(Client)，等待其他程序连接的程序为服务器(Server)。</p>
<h5 id="网络编程中的两个主要问题"><a href="#网络编程中的两个主要问题" class="headerlink" title="网络编程中的两个主要问题"></a>网络编程中的两个主要问题</h5><ul>
<li>如何准确的定位网络上的主机(使用IP协议定位主机)</li>
<li>找到主机后如何<strong>可靠高效</strong>的进行数据传输(使用TCP协议进行可靠传输)</li>
</ul>
<h5 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h5><p>网络编程，是通过使用<strong>套接字</strong>来达到进程间通信目的的编程，是通过操作相应API调度计算机资源硬件，并且利用管道(网线)进行数据交互的过程。</p>
<h3 id="编程介绍"><a href="#编程介绍" class="headerlink" title="编程介绍"></a>编程介绍</h3><h5 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h5><ul>
<li>IP地址：是网络中计算机的唯一标识<ul>
<li>使用“点分十进制”法来表示</li>
<li>组成：网络号段+主机号段<ul>
<li>A类：第一号段为网络号段+后三段的主机号段<ul>
<li>网络地址的最高位必须是”0”</li>
<li>有126个网络，每个网络可容纳的主机数16777214</li>
</ul>
</li>
<li>B类：前二号段为网络号段+后二段的主机号段<ul>
<li>网络地址的最高位必须是”10”</li>
<li>有16384个网络，每个网络可容纳的主机数65534</li>
</ul>
</li>
<li>C类：前三号段为网络号段+后一段的主机号段<ul>
<li>网络地址的最高位必须是”110”</li>
<li>有209万余个网络，每个网络可容纳的主机数254</li>
</ul>
</li>
</ul>
</li>
<li>两个DOS命令<ul>
<li>ipconfig/ifconfig：查看本机ip地址</li>
<li>ping：ping只是一个对联网环境的检测，并不能解决问题<ul>
<li>查看本机网络环境：ping 127.0.0.1(本机回环地址)，连不上网的时候可以ping一下本机回环地址，看是否是自己电脑的问题</li>
<li>ping：后面跟ip地址。测试本机与指定的ip地址间的通信是否正常，即查看网络是否有问题</li>
</ul>
</li>
</ul>
</li>
<li>在计算机中，IP地址是分配给网卡的，每个网卡有一个唯一的IP地址，如果一个计算机有多个网卡，则该台计算机则拥有多个不同的IP地址，在同一个网络内部，IP地址不能相同</li>
</ul>
</li>
<li>端口：用于找到对应的应用。每个应用对应一个端口(逻辑端口)，端口是用来区分应用程序的，即每个运行的应用程序进程有相应的端口号<ul>
<li>正在运行的程序的标识</li>
<li>有效端口：0～65535，其中0～1024系统使用或保留端口</li>
<li>物理端口，即是网卡口。通常所说的都是逻辑端口</li>
<li>使用过程中，建议使用系统分配的默认端口，如果更改端口，可能导致其它进程无法启动</li>
<li>端口号是和Socket编程相关的一个概念</li>
</ul>
</li>
<li>协议：约定通信的方式(通信的规则)<ul>
<li>协议(约定)大于配置，在网络传输中依然适用，网络的传输是健壮、稳定的，得益于基础的协议构成</li>
</ul>
</li>
</ul>
<p>三要素的作用流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到计算机 -&gt; 根据端口找到应用程序 -&gt; 按照协议沟通</span><br></pre></td></tr></table></figure>
<h5 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h5><p>网络协议是一个分层的协议族，即是由一组协议构成，从下往上各自负责各自的功能。协议，是在网络中多个计算节点进行交互、沟通的规定。通过对数据格式的规范化，从而使计算机之间能够彼此明确对方的意图。</p>
<p>网络协议是网络中不同计算机信息通信的语言，为了实现交互，这个语言就需要有一定的格式。</p>
<h5 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h5><ul>
<li>模型：描述网络的结构原理和工作原理</li>
<li><p>协议：指定层上进行数据交换的规则</p>
</li>
<li><p>OSI参考模型</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>层级</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>应用层</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
</tr>
</tbody>
</table>
<ul>
<li>TCP/IP模型</li>
</ul>
<table>
<thead>
<tr>
<th>层级</th>
<th>名称</th>
<th>对应OSI参数模型中的层级</th>
<th>使用的协议和服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>应用层</td>
<td>应用层、表示层、会话层</td>
<td>HTTP、FTTP、Telnet、NTP、DHCP、PING</td>
</tr>
<tr>
<td>3</td>
<td>传输层</td>
<td>传输层</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>2</td>
<td>网络层</td>
<td>网络层</td>
<td>IP、ARP、ICMP、IGMP、DNS</td>
</tr>
<tr>
<td>1</td>
<td>网络接口层</td>
<td>数据链路层、物理层</td>
<td>Ethernet</td>
</tr>
</tbody>
</table>
<h6 id="基于TCP-IP模型理解网络编程"><a href="#基于TCP-IP模型理解网络编程" class="headerlink" title="基于TCP/IP模型理解网络编程"></a>基于<code>TCP/IP模型</code>理解网络编程</h6><ul>
<li><p>网络链路层(网络接口层)</p>
<ul>
<li><p>以太网协议</p>
<ul>
<li>确定了一系列约定，让一股又一股的电流能够传递信息：0或1</li>
<li>规定一组信号组成一个数据包 - 帧</li>
<li>帧由标头和数据两部分组成<ul>
<li>标头，包括目的地址、源地址、类型(目的地址和源地址，用MAC地址来标识)，长度固定为18字节</li>
<li>数据，数据包的具体内容，最短为46字节，最长为1500字节，如超出最长值，就必须分割成多个帧进行发送</li>
</ul>
</li>
</ul>
</li>
<li><p>MAC地址 </p>
<ul>
<li>MAC地址，即网卡地址，就是数据包的发送地址(源地址)和接收地址(目的地址)</li>
<li>以太网规定，接入网络的所有设备，都必须有网卡接口。数据包必须是从一块网卡，传送到另一块网卡</li>
<li>每一张网卡都有唯一的MAC地址</li>
<li>MAC地址长度是48个二进制位，通常用12个十六进制数表示，如：AA:BB:CC:DD:EE:FF。前6个是厂商编号，后6个是该厂商的网卡流水号</li>
<li><strong>有了MAC地址，就可以定位网卡和数据包的路径了(目的地址和源地址)</strong></li>
</ul>
</li>
<li><p>类型</p>
<ul>
<li>两个字节大小</li>
<li>当这两个字节的值小于1518时，就代表其后数据字段的长度</li>
<li>当这两个字节的值大于1518时，则表示该以太网帧中的数据属于哪个上层协议。如，0x800，代表IP数据包；0x806，代表ARP数据包</li>
</ul>
</li>
<li><p>广播</p>
<ul>
<li>广播以知道对方的MAC地址路径</li>
<li>通过ARP协议</li>
</ul>
</li>
<li><p>常用协议</p>
<ul>
<li>ARP协议<ul>
<li>地址解析协议(Address Resolution Protocol)</li>
<li>是通过IP地址获取MAC地址的协议 </li>
<li>ARP缓存有生命期</li>
<li>ARP只能用于IPv4，不能用于IPv6。在IPv6中可以用ICMPv6替代ARP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li>产生的背景<ul>
<li>计算机通过“广播”的方式传递信息，“广播”只局限于发送者所在的子网内(如没有子网设计，在网络上的所有计算机都能收到“广播”的信息，这将是一场灾难)</li>
<li>基于子网的设计，信息发送有两种方式<ul>
<li>当发送者和接收者都在同一个子网内，采用“广播”的方式发送信息</li>
<li>当发送者和接收者不在同一个子网内，采用“路由”的方式发送信息</li>
</ul>
</li>
<li>基于上述因素，诞生了“网络层”</li>
</ul>
</li>
<li>作用<ul>
<li>引进一套新的地址，用于能够区分不同的计算机是否属于同一个子网络</li>
<li>这套地址叫做“网络地址”，简称“网址”</li>
</ul>
</li>
<li>结果<ul>
<li>引入网址后，计算机有了两种地址<ul>
<li>MAC地址，绑定在网卡上的</li>
<li>网络地址，管理员分配的</li>
</ul>
</li>
<li>两种地址之间没有任何联系，它们只是随机组合在一起</li>
<li>通过网络地址，可以得出计算机所在的子网络</li>
</ul>
</li>
<li>常用协议<ul>
<li>IP协议<ul>
<li>IP是Internet Protocol（网络之间互连的协议）的缩写</li>
<li>是能使连接到网上的所有计算机网络实现相互通信的一套规则</li>
<li>用来规定网络地址的协议<ul>
<li>IPv4，32个二进制组成，32位</li>
<li>IPv6，128位</li>
</ul>
</li>
<li>首部主要包括总长度、源地址、目的地址等信息</li>
<li>数据部分是IP数据包的具体内容</li>
<li>以太网数据包的数据部分就是整个IP数据</li>
<li>IP数据包的“标头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。因此，理论上，一个IP数据包的“数据”部分，最长为65515字节</li>
<li>如果IP数据包超过了1500字节，需要将IP数据包分割成几个以太网数据包，分开发送了</li>
<li>IP协议常与ARP协议搭配使用</li>
<li>子网掩码<ul>
<li>子网编址：IP地址 = 网络号 + 子网号 + 主机号</li>
<li>其中值为1的比特留给网络号和子网号，为0的比特留给主机号，给定IP地址和子网掩码以后，主机就可以确定IP数据报的目标地址，根据子网掩码可知道子网号与主机号之间的分界线</li>
<li>也是32位的一个IP地址，它的用途是识别本网络内的计算机。两台不同主机的IP地址同时与子网掩码进行AND运算，如果得出结果相同，则说明这两台计算机处于同一个子网内，可以进行直接通信</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>传输层</p>
<ul>
<li>端口<ul>
<li>是每一个使用网卡的程序的编号</li>
<li>用以表示数据包到底供哪个程序(进程)使用</li>
</ul>
</li>
<li>传输层的功能，就是建立“端口到端口”的通信。相比之下，网络层是建立“主机到主机”的通信</li>
<li>常用协议<ul>
<li>TCP协议<ul>
<li>TCP数据包的数据格式<ul>
<li>包含了首部和数据部分，在TCP协议的控制逻辑中，首部起着最为关键的作用。它是TCP协议中诸如建立连接、断开连接、重传和错误校验等各种特性的基础</li>
<li>首部最重要的是源端口和目的端口</li>
<li>数据部分就是具体的内容</li>
<li>Sequence number(顺序号码)(对应数据包中的seq)、Acknowledge number(确认号码)(对应数据包中的ack)<ul>
<li>序号<ul>
<li>占4个字节，它的范围在0-2^32-1，序号随着通信的进行不断的递增，当达到最大值的时候重新回到0在开始递增</li>
<li>TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号</li>
<li>整个要传送的字节流的起始号必须在连接建立时设置</li>
<li>首部中的序列号字段指的是本报文段所发送的数据的第一个字节的序号</li>
</ul>
</li>
<li>确认号<ul>
<li>占4个字节，是对下一个想要接受的字节的期望，这里隐式确认了对上一个数据包的成功接收</li>
</ul>
</li>
</ul>
</li>
<li>TCP标志位(位码)，有6种<ul>
<li>SYN(synchronous建立联机)，发起一个新连接</li>
<li>ACK(acknowledgement确认)，确认序号有效</li>
<li>PSH(push传送)</li>
<li>FIN(finish结束)，释放一个连接</li>
<li>RST(reset重置)，重置连接</li>
<li>URG(urgent紧急)</li>
</ul>
</li>
</ul>
</li>
<li>IP数据包的数据部分就是整个TCP报文段数据</li>
<li>是可靠的传输协议，可靠性的保证(两点)<ul>
<li>具有CRC校验，这样如果数据包中的某些数据出现错误可以通过校验来发现</li>
<li>每个数据包都有一个序号，这样就能保证数据包的顺序性，如果出现错位的数据包可以请求重发</li>
</ul>
</li>
</ul>
</li>
<li>TCP与UDP的区别<ul>
<li>TCP：建立连接通道、传输数据大小无限制、速度慢、可靠</li>
<li>UDP：把数据打包、传输数据大小有限制(限制在64KB之内)、不建立连接、速度快、不可靠</li>
</ul>
</li>
<li>报文段<ul>
<li>通过报文段可以查询各个网络路由网段、IP地址、交换协议等IP数据包信息</li>
<li>报文段充当整个TCP/IP协议数据包的导航路由功能</li>
<li>报文在传输过程中会不断的封装成分组、包、帧来传输</li>
<li><strong>封装的方式就是添加一些控制信息组成的首部，即报文头</strong></li>
</ul>
</li>
</ul>
</li>
<li>建立连接/断开连接<ul>
<li>TCP的连接是逻辑的连接。物理连接基于底层的协议已经建立完成，而且TCP建立连接需要假设底层连接已经成功。简单理解TCP的连接，就是客户端和服务端分别记录了各自接收到的数据包的序号，并且将自身设置为某种状态</li>
<li>TCB传输控制块Transmission Control Block，存储每一个连接中的重要信息，如TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号</li>
<li>建立起一个TCP连接需要经过“三次握手”<ul>
<li>服务端B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。若有，则作出响应</li>
<li><strong>第一次握手：</strong>客户端A的TCP客户进程也是首先创建传输控制块TCB，然后向服务端B发出连接请求报文段，（首部的同步位SYN=1，初始序号seq=x），（SYN=1的报文段不能携带数据）但要消耗掉一个序号(消耗掉的原因，见“序号”的定义及特点)，此时TCP客户进程进入SYN-SEND（同步已发送）状态。</li>
<li><strong>第二次握手：</strong>服务端B收到连接请求报文段后，如同意建立连接，则向客户端A发送确认，在确认报文段中（SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y），测试TCP服务器进程进入SYN-RCVD（同步收到）状态</li>
<li><strong>第三次握手：</strong>TCP客户进程收到服务端B的确认后，要向服务端B给出确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED（已建立连接）</li>
<li>当服务端B收到客户端A的确认后，也进入ESTABLISHED状态</li>
<li>总结：起初客户端A和服务端B都处于CLOSED状态——服务端B创建TCB，处于LISTEN状态，等待客户端A请求——客户端A创建TCB，发送连接请求（SYN=1，seq=x），进入SYN-SENT状态——服务端B收到连接请求，向客户端A发送确认（SYN=ACK=1，确认号ack=x+1，初始序号seq=y），进入SYN-RCVD状态——客户端A收到服务端B的确认后，给服务端B发出确认（ACK=1，ack=y+1，seq=x+1），客户端A进入ESTABLISHED状态——服务端B收到客户端A的确认后，进入ESTABLISHED状态<strong>(连接的建立需要经过3次确认的过程)</strong></li>
<li>连接的建立需要经过多次交互，因此建立连接是高成本的操作。在实际生产环境中，为了应对建立连接时的高成本问题，会减少连接建立的频度，通常做法是建立连接池，传输数据时直接从连接池中获取连接，而不是建立新连接</li>
</ul>
</li>
<li>TCP连接的断开过程需要经过“四次挥手”(如客户端发起断开)<ul>
<li>客户端A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待服务端B的确认</li>
<li>服务端B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），服务端B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端A到服务端B的连接释放</li>
<li>客户端A收到服务端B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待服务端B发出的连接释放报文段</li>
<li>服务端B没有要向客户端A发出的数据，服务端B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端B进入LAST-ACK（最后确认）状态，等待客户端A的确认</li>
<li>客户端A收到服务端B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端A才进入CLOSED状态</li>
<li>总结：起初客户端A和服务端B处于ESTABLISHED状态——客户端A发出连接释放报文段并处于FIN-WAIT-1状态——服务端B发出确认报文段且进入CLOSE-WAIT状态——客户端A收到确认后，进入FIN-WAIT-2状态，等待服务端B的连接释放报文段——服务端B没有要向客户端A发出的数据，服务端B发出连接释放报文段且进入LAST-ACK状态——客户端A发出确认报文段且进入TIME-WAIT状态——服务端B收到确认报文段后进入CLOSED状态——客户端A经过等待计时器时间2MSL后，进入CLOSED状态<strong>(断开连接的过程中，发起方的状态有ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSED；接收方的状态有ESTABLISHED、CLOSE-WAIT、LAST-ACK、CLOSED)</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>应用层</p>
<ul>
<li>应用层是在用户空间实现的，负责处理业务逻辑，如文件传输、网络管理。应用层规定了应用程序的数据格式，即应用数据</li>
<li><p>常用协议</p>
<ul>
<li>HTTP协议<ul>
<li>HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议，是一种<strong>无状态的协议</strong>(HTTP是无状态协议，它不对之前发生过的请求和响应保留相应的状态)，使用URI(统一资源标识符)定位互联网上的资源</li>
<li>HTTP协议(超文本传送协议)，是Web联网的基础，也是手机联网常用的协议之一</li>
<li>HTTP协议是建立在TCP协议之上的一种应用</li>
<li>HTTP连接显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接</li>
<li>在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接</li>
<li>在HTTP 1.1中，则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求<ul>
<li>HTTP1.1中的方法<ul>
<li>GET方法：获取资源</li>
<li>POST方法：传输实体主体</li>
<li>PUT方法：传输文件</li>
<li>HEAD方法：获得报文首部</li>
<li>DELETE方法：删除文件</li>
<li>OPTIONS方法：询问支持的方法</li>
<li>TRACE方法:追踪路径</li>
<li>CONNECT方法：要求用隧道协议连接代理</li>
</ul>
</li>
</ul>
</li>
<li>HTTP协议采用了请求/响应模型</li>
<li>Cookie<ul>
<li>通过引入Cookie技术，解决HTTP无状态的问题</li>
<li>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。它会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息</li>
</ul>
</li>
<li>HTTP报文结构、状态码，见<a href="https://88benxiaoyang.github.io/2019/01/25/图解HTTP/" target="_blank" rel="noopener">图解HTTP</a></li>
</ul>
</li>
</ul>
</li>
<li><p>两个计算机之间的交流无非是两个端口之间的数据通信，具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。如HTTP、FTP</p>
</li>
</ul>
</li>
</ul>
<h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它<strong>是网络通信过程中端点的抽象表示</strong>，包含进行<strong>网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口</strong></p>
<p>Tips</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">网络编程也称为Socket编程，Socket通常译为“套接字”，但原意应该为“接口”，是操作系统提供给开发人员进行网络开发的API接口。这套接口通过对参数的不同调整可以支持多种协议，包括TCP、UDP和IP等。</span><br><span class="line"></span><br><span class="line">Socket的作用，在网络传输中用于唯一标识两个端点的连接</span><br><span class="line">Socket的组成，IP Address + Port number = Socket(一个Socket由一个IP地址和一个端口号唯一确定)</span><br><span class="line"></span><br><span class="line">在实际生产环境中为了提高数据传输和处理的效率，通常采用异步模式</span><br><span class="line"></span><br><span class="line">在传统的UNIX环境下可以操作TCP/IP协议的接口不止Socket一个，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。通常，Socket编程主要是指基于TCP/IP协议的网络编程。</span><br></pre></td></tr></table></figure>
<ul>
<li>背景</li>
</ul>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务</p>
<ul>
<li>平时说得最多的Socket是什么</li>
</ul>
<p>平时说得最多的Socket，实际上是对TCP/IP协议的封装，<strong>Socket本身并不是协议，而是一套调用接口(API)</strong>。通过Socket，我们使用TCP/TP协议方便了。实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，希望也能适应其他的网络协议。所以说，<strong>Socket</strong>的出现只是使得使用TCP/TP协议栈变得更方便，<strong>是对TCP/IP协议的抽象，从而形成了一些最基本的函数接口，如create、listen、connect、accept、send、read和write等。</strong></p>
<p>TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。</p>
<p>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而<strong>Socket本身不算是协议，它只是提供了一个针对TCP或UDP编程的接口。</strong>Socket是用于<strong>端口通信</strong>开发的工具，它要更底层以一些。</p>
<ul>
<li><p>对于一个功能齐全的Socket，包含以下四个基本步骤</p>
<ol>
<li>创建Socket</li>
<li>打开连接到Socket的输入/出流</li>
<li><strong>按照一定的协议对Socket进行读/写操作</strong></li>
<li>关闭Socket</li>
</ol>
<ul>
<li>其中第三步是实际操作过程中用来调用Socket和实现程序功能的关键步骤(需要根据不同的程序进行对应的操作，主要是针对编程语言而言)</li>
</ul>
</li>
<li><p>建立Socket连接</p>
<ul>
<li>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket</li>
<li>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认<ul>
<li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求</li>
<li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求</li>
<li>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求</li>
</ul>
</li>
<li>Socket通常用来实现C/S结构。使用Socket进行Client/Server程序设计的一般连接过程是这样的：Server端Listen(监听)某个端口是否有连接请求，Client端向Server端发出Connect(连接)请求，Server端向Client端发回Accept（接受）消息，一个连接就建立起来了。Server端和Client端都可以通过Send，Write等方法与对方通信</li>
<li>Socket连接与TCP连接/HTTP连接<ul>
<li>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。通常情况下Socket连接就是TCP连接</li>
<li>实际网络应用中，通过Socket建立客户端与服务端之间的长连接需要穿越多个中间节点，如路由器、网关、防火墙等，因大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态</li>
<li>HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据</li>
<li>总结：实际使用中，很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h5><p>数据包，指在应用层，数据或报文按照一定事先规定好的规则整合的数据集合。实际操作中，包括组包(打包)、数据包传送、解包。数据包经常通过套接字来传送。</p>
<ul>
<li>组包(打包)：指按照协议把零散的数据或报文按照一定的规则组合起来</li>
<li>数据包传送：指数据包的电气物理传输</li>
<li>解包：指接收端对接收到的数据进行解析，获得有用的信息和数据</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>网络编程就是使用IP地址或域名和端口连接到另一台计算机上对应的程序，按照规定的协议(数据格式)来交换数据，实现计算机间的通信功能。实际编程中建立连接、发送和接收数据在语言级已经实现，做得更多的工作是设计协议，以及编写生成和解析数据的代码，然后把数据转换成逻辑结构的显示或控制逻辑即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/05/内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/05/内存管理/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-05 18:44:17" itemprop="dateCreated datePublished" datetime="2019-06-05T18:44:17+08:00">2019-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h5><p>对象的生命周期包括诞生(通过<code>alloc</code>或<code>new</code>方法实现)、生存(接收消息并执行操作)、交友(通过复合以及向方法传递参数)以及最终死去(被释放掉)。当生命周期结束时，对象的原材料(内存)将被回收以供新的对象使用。</p>
<h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>引用计数是用于供系统感知对象生命周期是否结束，以便于系统对对象所占用的内存进行管理(主要用于对对象占用的内存何时回收进行管理)的技术。</p>
<ul>
<li><p><code>iOS</code>内存管理的方式是“引用计数”，一般内存管理的方式是“谁申请谁释放”</p>
</li>
<li><p>引用计数工作原理</p>
<ul>
<li>每个对象都有一个与之相关联的整数，被称作对象的<strong>引用计数器</strong>或<strong>保留计数器</strong>。</li>
<li>对象创建出来时，其保留计数(引用计数)至少为<code>1</code>。</li>
<li>当某段代码需要访问一个对象时，该代码就将该对象的保留计数器值加<code>1</code>，表示“我要访问该对象”，调用<code>retain</code>方法。当这段代码结束对象访问时，将对象的保留计数器减<code>1</code>，表示代码不再访问该对象，调用<code>release</code>或<code>autorelease</code>方法。当对象的保留计数器的值为<code>0</code>时，表示不再有代码访问该对象了，因此对象将被销毁，其占用的内存被系统回收以便重用。此时，所有指向该对象的引用也都变得无效了。</li>
</ul>
</li>
</ul>
<h5 id="内存管理规则"><a href="#内存管理规则" class="headerlink" title="内存管理规则"></a>内存管理规则</h5><ul>
<li>当使用new、alloc或copy方法创建一个对象时，该对象的保留计数器的值为1。当不再使用该对象时，应该向该对象发送一条release或autorelease消息。这样，该对象将在其使用寿命结束时被销毁</li>
<li>当通过其他方法获得一个对象时，假设该对象的保留计数器的值为1，而且已经被设置为自动释放，那么不需要执行任何操作来确保该对象得到清理。如果打算在一段时间内拥有该对象，则需要保留它并确保在操作完成时释放它</li>
<li>如果保留了某个对象，就需要(最终)释放或自动释放该对象。必须保持retain方法和release方法的使用次数相等</li>
</ul>
<h5 id="引用计数式内存管理的思考方式"><a href="#引用计数式内存管理的思考方式" class="headerlink" title="引用计数式内存管理的思考方式"></a>引用计数式内存管理的思考方式</h5><ul>
<li>自己生成的对象，自己所持有<ul>
<li>使用<code>alloc/new/copy/mutableCopy</code>名称开头的方法名意味着自己生成的对象只有自己持有</li>
</ul>
</li>
<li>非自己生成的对象，自己也能持有<ul>
<li>通过<code>retain</code>方法，非自己生成的对象跟用<code>alloc/new/copy/mutableCopy</code>方法生成并持有的对象一样，成为了自己所持有的</li>
</ul>
</li>
<li>不再需要自己持有的对象时释放<ul>
<li>自己持有的对象，一旦不再需要，持有者有义务释放该对象。释放使用<code>release</code>方法。</li>
<li>自己生成而非自己所持有的对象，若用<code>retain</code>方法变为自己持有，也同样可以用<code>release</code>方法释放。</li>
<li>用<code>alloc/new/copy/mutableCopy</code>方法生成并持有的对象，或者用<code>retain</code>方法持有的对象，一旦不再需要，务必要用<code>release</code>方法进行释放。</li>
</ul>
</li>
<li><p>非自己持有的对象无法释放</p>
<ul>
<li>对于用<code>alloc/new/copy/mutableCopy</code>方法生成并持有的对象，或是用retain方法持有的对象，由于持有者是自己，所以在不需要该对象时需要将其释放。而由此以外所得到的对象绝对不能释放，倘若在应用程序中释放了非自己所持有的对象就会造成崩溃。</li>
</ul>
</li>
<li><p><code>Objective-C</code>方法与对象操作的对应</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Objective-C方法</th>
<th>对象操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc/new/copy/mutableCopy等方法</td>
<td>生成并持有对象</td>
</tr>
<tr>
<td>retain方法</td>
<td>持有对象</td>
</tr>
<tr>
<td>release方法</td>
<td>释放对象</td>
</tr>
<tr>
<td>dealloc方法</td>
<td>废弃对象</td>
</tr>
</tbody>
</table>
<p>Tips</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象的生成和持有是不同的功能</span><br><span class="line"></span><br><span class="line">引用计数式内存管理的思考方式是理解操作 retain 和 release 的依据</span><br></pre></td></tr></table></figure>
<h5 id="引用计数的类型"><a href="#引用计数的类型" class="headerlink" title="引用计数的类型"></a>引用计数的类型</h5><ul>
<li><code>MRC</code>手动引用计数</li>
<li><code>ARC</code>自动引用计数<ul>
<li><code>ARC</code>几乎把所有内存管理事宜都交由编译器来决定，开发者只需专注于业务逻辑。引用计数式内存管理的本质没变</li>
<li>内存管理的思考方式在<code>ARC</code>环境下是可行的，只是在<strong>源代码的记述方法上有所不同</strong>。不同体现在，<code>ARC</code>中追加所有权声明，引入了所有权修饰符</li>
<li><code>ARC</code>有效时，<code>id</code>类型和对象类型同<code>C</code>语言其他类型不同，其类型上必须附加所有权修饰符(指明对象为谁所持有)<ul>
<li>所有权修饰符(从对象的所有者和对象的生命周期理解所有权修饰符的作用)<ol>
<li><code>__strong</code>修饰符<ul>
<li><code>__strong</code>修饰符是<code>id</code>类型和对象类型默认的所有权修饰符。<code>id</code>类型和对象类型在没有明确指定所有权修饰符时，默认为<code>__strong</code>修饰符</li>
<li><code>__strong</code>修饰符表示对对象的“强引用”。持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放</li>
<li>附有<code>__strong</code>修饰符的变量之间可以相互赋值</li>
<li><code>__strong</code>修饰符的变量，不仅只在变量作用域中，在赋值上也能够正确地管理其对象的所有者</li>
<li>对象的所有者不存在时，对象会被废弃</li>
<li>通过<code>__strong</code>修饰符，不必再次键入<code>retain</code>或者<code>release</code>，完美地满足了“引用计数式内存管理的思考方式”</li>
</ul>
</li>
<li><code>__weak</code>修饰符<ul>
<li>用以解决循环引用。循环引用容易发生内存泄漏，内存泄漏就是应当废弃的对象在超出其生命周期后继续存在</li>
<li><code>__weak</code>提供弱引用，弱引用不能持有对象实例</li>
<li>在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于<code>nil</code></li>
<li>通过检查附有<code>__weak</code>修饰符的变量是否为<code>nil</code>，可以判断被赋值的对象是否已废弃</li>
</ul>
</li>
<li><code>__unsafe_unretained</code>修饰符<ul>
<li>是不安全的所有权修饰符</li>
<li>附有<code>__unsafe_unretained</code>修饰符的变量不属于编译器的内存管理对象</li>
<li><code>__unsafe_unretained</code>的使用，是为了兼容，<code>iOS4</code>之前版本中不存在<code>__weak</code>的解决方案</li>
</ul>
</li>
<li><code>__autoreleasing</code>修饰符<ul>
<li><code>ARC</code>有效时，要通过将对象赋值给附加了<code>__autoreleasing</code>修饰符的变量来替代调用<code>autorelease</code>方法。对象赋值给附有<code>__autoreleasing</code>修饰符的变量等价于在<code>ARC</code>无效时调用对象的<code>autorelease</code>方法，即对象被注册到<code>autoreleasepool</code>。可理解为，在<code>ARC</code>有效时，用<code>@autoreleasepool</code>块替代<code>NSAutoreleasePool</code>类，用附有<code>__autoreleasing</code>修饰符的变量替代<code>autorelease</code>方法<ul>
<li><code>__strong</code>、<code>__weak</code>、<code>__autoreleasing</code>这些修饰符，可以保证将附有这些修饰符的自动变量初始化为<code>nil</code></li>
<li>所有权修饰符的引入，隐藏了<code>retain</code>、<code>release</code>的添加，交由编译器去实现</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="ARC的规则"><a href="#ARC的规则" class="headerlink" title="ARC的规则"></a><code>ARC</code>的规则</h5><p>在<code>ARC</code>有效的情况下编译源代码，必须遵守一定的规则</p>
<ul>
<li>不能使用<code>retain/release/retainCount/autorelease</code><ul>
<li>设置<code>ARC</code>有效时，禁止再次键入<code>retain</code>或<code>release</code>代码</li>
</ul>
</li>
<li>不能使用<code>NSAllocateObject/NSDeallocateObject</code></li>
<li>须遵守内存管理的方法命名规则<ul>
<li>在<code>ARC</code>有效或无效的情况下，以<code>alloc/new/copy/mutableCopy</code>名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象</li>
<li>在<code>ARC</code>有效的情况下，以<code>init</code>开始的方法的规则要比<code>alloc/new/copy/mutableCopy</code>更严格。<code>init</code>方法必须是实例方法，并且必须要返回对象，返回的对象应为<code>id</code>类型或该方法声明类的对象类型，抑或是该类的超类型或子类型，该返回对象并不注册到<code>autoreleasepool</code>上，基本上只是对<code>alloc</code>方法返回值的对象进行初始化处理并返回该对象</li>
</ul>
</li>
<li>不要显示调用<code>dealloc</code><ul>
<li>即不显示调用如<code>[super dealloc]</code></li>
</ul>
</li>
<li>使用<code>@autoreleasepool</code>块替代<code>NSAutoreleasePool</code><ul>
<li><code>ARC</code>有效时，使用<code>@autoreleasepool</code>块替代<code>NSAutoreleasePool</code></li>
</ul>
</li>
<li>不能使用区域<code>(NSZone)</code><ul>
<li>区域在现在的运行时系统中已单纯地被忽略</li>
</ul>
</li>
<li>对象型变量不能作为<code>C</code>语言结构体<code>(struct/union)</code>的成员<ul>
<li><code>C</code>语言的规约上没有方法来管理结构体成员的生命周期。因<code>ARC</code>把内存管理的工作分配给编译器，所以编译器必须能够知道并管理对象的生命周期。</li>
<li>要把对象型变量加入到结构体成员中时，可强制转换为<code>void *</code>或是附加<code>__unsafe_unretained</code>修饰符。因附有<code>__unsafe_unretained</code>修饰符的变量不属于编译器的内存管理对象</li>
</ul>
</li>
<li><p>显示转换<code>id</code>和<code>void *</code></p>
<ul>
<li>在<code>ARC</code>无效时，<code>id</code>和<code>void *</code>相互强制转换时，不会出问题</li>
<li><p>但在<code>ARC</code>有效时，<code>id</code>和<code>void *</code>直接相互强制转换会有问题。此时<code>id</code>型或对象型变量赋值给<code>void *</code>或者逆向赋值时都需要进行特定的转换。有如下几种转换</p>
<ul>
<li><p><code>__bridge</code>转换 ，安全性与赋值给<code>__unsafe_unretained</code>修饰符相近，用法如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge void *)obj;</span><br><span class="line">id o = (__bridge id)p;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__bridge_retained</code>转换，可使要转换赋值的变量也持有所赋值的对象，<code>__bridge_retained</code>转换变为了<code>retain</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge_retained void *)obj; //p持有对象obj</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__bridge_transfer</code>转换，被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。同<code>__bridge_retained</code>转换与<code>retain</code>类似，<code>__bridge_transfer</code>转换与<code>release</code>相似</p>
</li>
<li>使用<code>__bridge_retained</code>、<code>__bridge_transfer</code>转换，不使用id型或对象型变量也可以生成、持有以及释放对象，但不推荐这样做</li>
<li>这些转换多数使用在<code>Objective-C</code>对象与<code>Core Foundation</code>对象之间的相互变换中</li>
<li><code>Foundation</code>框架的<code>API</code>生成并持有的对象可以用<code>Core Foundation</code>框架的<code>API</code>释放，反之亦然</li>
<li>函数<code>CFBridgeRetain()</code>和<code>CFBridgeRelease()</code>，可用于<code>Objective-C</code>对象与<code>Core Foundation</code>对象之间的相互变换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="ARC有效的情况下，属性的使用"><a href="#ARC有效的情况下，属性的使用" class="headerlink" title="ARC有效的情况下，属性的使用"></a>ARC有效的情况下，属性的使用</h5><ul>
<li>属性声明的属性与所有权修饰符的对应关系</li>
</ul>
<table>
<thead>
<tr>
<th>属性声明的属性</th>
<th>所有权修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained修饰符</td>
</tr>
<tr>
<td>copy</td>
<td>__strong修饰符(但是赋值的是被复制的对象)</td>
</tr>
<tr>
<td>retain</td>
<td>__strong修饰符</td>
</tr>
<tr>
<td>strong</td>
<td>__strong修饰符</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained修饰符</td>
</tr>
<tr>
<td>weak</td>
<td>__weak修饰符</td>
</tr>
</tbody>
</table>
<p>以上各种属性赋值给指定的属性中就相当于赋值给附加各属性对应的所有权修饰符的变量中。只有<code>copy</code>属性不是简单的赋值，它赋值的是通过<code>NSCoping</code>接口的<code>copyWithZone:</code>方法复制赋值源所生成的对象</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/30/GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/30/GCD/" class="post-title-link" itemprop="url">GCD</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-30 11:04:50" itemprop="dateCreated datePublished" datetime="2019-05-30T11:04:50+08:00">2019-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li><p><code>CPU</code>命令列</p>
<ul>
<li>通常情况下，程序的代码行基本上是按从上到下的顺序执行的。应用程序源代码通过编译器转换为<code>CPU</code>命令列。汇集<code>CPU</code>命令列和数据，应用程序安装到设备上，操作系统在用户的指示下启动应用程序。操作系统首先便将包含在应用程序中的<code>CPU</code>命令列配置到内存中，<code>CPU</code>从应用程序指定的地址开始，一个一个地执行<code>CPU</code>命令列。</li>
</ul>
</li>
<li><p>一个<code>CPU</code>执行的<code>CPU</code>命令列为一条无分叉路径，即为线程</p>
</li>
<li><p>多线程的执行，即多路径<code>CPU</code>命令列的执行，涉及到上下文切换，切换时每条路径的状态，会保存到各自路径专用的内存块中。路径状态，包括如<code>CPU</code>的寄存器等信息</p>
</li>
<li><p>由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像<code>1</code>个<code>CPU</code>核能够并列地执行多个线程一样。在具有多个<code>CPU</code>核的情况下，就不是“看上去像”了，而是真的提供了多个<code>CPU</code>核并行执行多个线程的技术</p>
</li>
<li><p>多线程编程下易发生的问题：</p>
<ul>
<li>数据竞争：多个线程更新相同的资源，会导致数据的不一致</li>
<li>死锁：停止等待事件的线程会导致多个线程相互持续等待</li>
<li>大量内存消耗：使用太多线程会消耗大量内存</li>
</ul>
</li>
<li><p>尽管多线程编程存在各种问题，但从保证应用程序的响应性能考虑，应该使用多线程编程</p>
</li>
</ul>
<h5 id="多线程编程在iOS中的应用"><a href="#多线程编程在iOS中的应用" class="headerlink" title="多线程编程在iOS中的应用"></a>多线程编程在<code>iOS</code>中的应用</h5><p>应用程序在启动时，通过最先执行的线程，即“主线程”，来描绘用户界面、处理触摸屏幕的事件等。如果在主线程中进行长时间的处理，如数据库访问或<code>AR</code>画像的识别，就会妨碍主线程的执行(产生了阻塞)。在<code>OS X</code>和<code>iOS</code>的应用程序中，会妨碍主线程中被称为<code>RunLoop</code>的主循环的执行，从而导致不能更新用户界面、应用程序的画面长时间停滞等问题(界面交互体现就是产生了卡顿)。为了解决上述卡顿的问题，需要将长时间进行处理的操作，不放在主线程中执行，而放在其他线程中执行。</p>
<p><strong>使用多线程编程，在执行长时间的处理时仍可保证用户界面的响应性能</strong></p>
<h5 id="GCD的引入给多线程编程带来的意义"><a href="#GCD的引入给多线程编程带来的意义" class="headerlink" title="GCD的引入给多线程编程带来的意义"></a><code>GCD</code>的引入给多线程编程带来的意义</h5><ul>
<li>多线程编程的实质<ul>
<li>使应用程序能并行的执行多路径(<strong>多个</strong>)<code>CPU</code>命令列(一个<code>CPU</code>命令列，即为一个<strong>线程</strong>)，并行的执行多个任务，并使多个线程间能相互通信(将耗时操作添加到非主线程中进行执行，待耗时操作处理完成后，将处理结果传回到主线程中执行对应的操作，这一过程便是线程间相互通信的体现)</li>
<li>线程间的相互通信，在涉及网络数据获取或耗时操作的过程中，一般会使用异步任务+并行队列进行数据获取或耗时操作处理，当获取到网络数据或耗时操作处理完成后，需要在主线程中刷新界面显示数据，此时就涉及到线程间的通信。通信方向：子线程到主线程</li>
</ul>
</li>
</ul>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子线程执行耗时操作，主线程刷新UI</span><br><span class="line"></span><br><span class="line">每个应用程序只有一个主线程，即只有一个主队列，所以将任务添加到主队列，就是回到主线程了</span><br></pre></td></tr></table></figure>
<ul>
<li><code>GCD</code>是<strong>异步执行任务</strong>的技术之一<ul>
<li><code>GCD</code>将应用程序中记述的线程管理用的代码在系统级中实现(即，在系统级中实现应用程序中线程管理的代码)。<strong>线程管理的代码在系统级实现</strong></li>
<li>通过<code>GCD</code>，开发者只需定义将要执行的任务并添加到适当的调度队列(<code>Dispatch Queue</code>)中，<code>GCD</code>就能生成必要的线程并计划执行任务(即，<code>GCD</code>能管理线程的生成(引入<code>GCD</code>后，线程的生成，不需要开发者参与管理，开发者只需将任务添加到<code>GCD</code>中，由<code>GCD</code>负责线程的管理，在多线程编程的过程中，开发者只需面向<code>GCD</code>编程开发即可)。任务是在线程上执行的)</li>
<li><code>GCD</code>中线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，对多线程的编程、线程管理是更有效率的，<code>GCD</code>的引入正是为了实现这一目的。<code>GCD</code>用简洁的记述方法，实现了极为复杂繁琐的多线程编程。通过<code>GCD</code>提供的系统级线程管理提高执行效率</li>
</ul>
</li>
</ul>
<h5 id="GCD的引入，对iOS多线程编程的影响"><a href="#GCD的引入，对iOS多线程编程的影响" class="headerlink" title="GCD的引入，对iOS多线程编程的影响"></a><code>GCD</code>的引入，对<code>iOS</code>多线程编程的影响</h5><ul>
<li><p>引入<code>GCD</code>之前</p>
<ul>
<li><code>Cocoa</code>框架提供了<code>NSObject</code>类的<code>performSelectorInBackground:withObject</code>实例方法和<code>performSelectorOnMainThread</code>实例方法等简单的多线程编程技术</li>
<li>除了使用<code>performSelector</code>系方法进行多线程编程，还可使用<code>NSThread</code>类进行多线程编程，但较之<code>performSelector</code>系方法，使用<code>NSThread</code>实现多线程编程较繁琐<ul>
<li><code>NSThread</code>简介<ul>
<li>是多线程编程的技术之一，是面向对象操作线程的技术，可直接操作线程对象</li>
<li>需要手动管理线程的生命周期</li>
<li>需要使用线程同步的方法(如：临界区对象)，解决数据竞争的问题。实现线程同步的过程中对数据的加锁会有一定的开销。线程同步对数据的加锁方式有：<code>NSLock/NSConditionLock/NSRecursiveLock/@synchronized</code></li>
<li>实例化线程需要手动启动<code>(-start)</code>才能运行</li>
<li>使用类方法创建线程：<code>+detachNewThreadWithBlock`</code>+detachNewThreadSelector:toTarget:withObject:`。创建后就可执行，不需要手动启动。类方法的操作对象是针对当前线程而言</li>
<li>可以设置线程的调度优先级，调度优先级取值范围为<code>0.0～1.0</code>，默认是<code>0.5</code>，值越大优先级越高</li>
</ul>
</li>
</ul>
</li>
<li>无论使用<code>NSObject</code>类的<code>performSelector</code>系方法，还是使用<code>NSThread</code>实现多线程编程，所需的源代码量较之使用<code>GCD</code>实现的方式繁琐不少</li>
</ul>
</li>
<li><p>引入<code>GCD</code>后</p>
<ul>
<li><code>GCD</code>将多线程编程的具体实现封装于<code>API</code>的实现中，通过操作<code>GCD</code>对外提供的<code>API</code>，使多线程编程易于实现。因此使用<code>GCD</code>大大简化了偏于复杂的多线程编程的源代码，同时要使用<code>GCD</code>实现多线程编程，需熟悉<code>GCD</code>对外提供的接口</li>
<li><code>GCD</code>搭配<code>block</code>使用，可以进一步简化应用程序源代码</li>
</ul>
</li>
<li><p>综上，<code>GCD</code>的引入，大大简化了<code>iOS</code>多线程编程的源代码，使<code>iOS</code>中的多线程编程便于实现和管理</p>
</li>
</ul>
<h3 id="GCD的API"><a href="#GCD的API" class="headerlink" title="GCD的API"></a><code>GCD</code>的<code>API</code></h3><h5 id="苹果官方对GCD的说明"><a href="#苹果官方对GCD的说明" class="headerlink" title="苹果官方对GCD的说明"></a>苹果官方对<code>GCD</code>的说明</h5><ul>
<li>开发者要做的只是<strong>定义想执行的任务(通常用block语法来定义)</strong>并追加(用<code>GCD</code>提供的<code>API</code>)到适当的<code>Dispatch Queue</code>中</li>
<li>上述说明的源代码表示如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">//想执行的任务(用block来定义)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">源代码使用Block语法“定义想执行的任务”，通过dispatch_async函数追加任务到赋值给变量queue的&quot;Dispatch Queue&quot;中</span><br></pre></td></tr></table></figure>
<ul>
<li>仅如上述源代码所示，就可使指定的<code>Block</code>在另一线程中执行</li>
</ul>
<h5 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a><code>Dispatch Queue</code></h5><ul>
<li>是执行处理任务的等待队列</li>
<li><code>Dispatch Queue</code>按照追加的顺序(先进先出<code>FIFO</code>)执行处理(任务)</li>
<li><code>dispatch_queue_t</code>是表示<code>Dispatch Queue</code>的类型</li>
<li>种类</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>特点</th>
<th>同时执行的处理个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>串行</td>
<td>Serial Dispatch Queue</td>
<td>等待现在执行中的处理结束</td>
<td>同时执行的处理数只能有1个</td>
</tr>
<tr>
<td>并行</td>
<td>Concurrent Dispatch Queue</td>
<td>不等待现在执行中的处理结束</td>
<td>可并行执行多个处理，并行处理数量取决于当前系统的状态</td>
</tr>
</tbody>
</table>
<ul>
<li><p>系统状态</p>
<ul>
<li>即<code>iOS</code>和<code>OS X</code>基于<code>Dispatch Queue</code>中的处理数(任务数)、<code>CPU</code>核数以及<code>CPU</code>负荷等当前系统的状态来决定<code>Concurrent Dispatch Queue</code>中并行执行的处理数。“并行执行”，就是使用多个线程同时执行多个处理</li>
</ul>
</li>
<li><p><code>Dispatch Queue</code>种类与线程的关系</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>线程数</th>
</tr>
</thead>
<tbody>
<tr>
<td>串行</td>
<td>Serial Dispatch Queue</td>
<td>使用一个线程</td>
</tr>
<tr>
<td>并行</td>
<td>Concurrent Dispatch Queue</td>
<td>使用多个线程</td>
</tr>
</tbody>
</table>
<ul>
<li><p><code>iOS</code>和<code>OS X</code>的核心</p>
<ul>
<li><code>XNU</code>内核决定应当使用的线程数，并只生成所需的线程执行处理。当处理结束，应当执行的处理数减少时，<code>XNU</code>内核会结束不再需要的线程</li>
<li><code>XNU</code>内核仅使用<code>Concurrent Dispatch Queue</code>便可完美地管理并行执行多个处理(任务)的线程</li>
</ul>
</li>
<li><p>获取<code>Dispatch Queue</code>的两种方法</p>
<ul>
<li>方法一：通过<code>GCD</code>的<code>API</code>生成<code>Dispatch Queue</code>，通过<code>dispatch_queue_create</code>函数可生成<code>Dispatch Queue</code><ul>
<li>使用<code>dispatch_queue_create</code>函数，将第二个参数指定为<code>NULL</code>，生成的是<code>Serial Dispatch Queue</code></li>
<li><code>使用dispatch_queue_create</code>函数，将第二个参数指定为<code>DISPATCH_QUEUE_CONCURRENT</code>，生成的是<code>Concurrent Dispatch Queue</code></li>
<li>注意<ol>
<li>使用<code>dispatch_queue_create</code>函数可生成任意多个<code>Dispatch Queue</code></li>
<li>多个<code>Serial Dispatch Queue</code>可并行执行</li>
<li>一旦生成<code>Serial Dispatch Queue</code>并追加处理，系统对于一个<code>Serial Dispatch Queue</code>就只生成并使用一个线程。如果过多使用多线程，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。因此因避免过多生成<code>Serial Dispatch Queue</code></li>
</ol>
</li>
<li><code>Serial Dispatch Queue</code>的用途<ul>
<li>可解决多线程编程问题中的<strong>数据竞争</strong>。如多个线程更新相同资源或在访问数据库/文件时，存在数据竞争的问题，可使用<code>Serial Dispatch Queue</code>来解决数据竞争的问题</li>
</ul>
</li>
</ul>
</li>
<li><p>方法二：获取系统标准提供的<code>Dispatch Queue</code>。这类<code>Dispatch Queue</code>不用特意生成，系统给我们提供的，有<code>Main Dispatch Queue</code>和<code>Global Dispatch Queue</code></p>
<ul>
<li><code>Main Dispatch Queue</code><ol>
<li>追加到<code>Main Dispatch Queue</code>的处理在主线程的<code>RunLoop</code>中执行</li>
<li><code>Main Dispatch Queue</code>是在主线程中执行的<code>Dispatch Queue</code>。因主线程只有<code>1</code>个，所以<code>Main Dispatch Queue</code>是<code>Serial Dispatch Queue</code></li>
</ol>
</li>
<li><code>Global Dispatch Queue</code><ol>
<li><code>Global Dispatch Queue</code>是所有应用程序都能够使用的<code>Concurrent Dispatch Queue</code></li>
<li>没有必要通过<code>dispatch_queue_create</code>函数逐个生成<code>Concurrent Dispatch Queue</code>，只要获取<code>Global Dispatch Queue</code>使用即可</li>
<li><code>Global Dispatch Queue</code>有<code>4</code>个执行优先级：高优先级、默认优先级、低优先级、后台优先级</li>
</ol>
</li>
<li>对于<code>Main Dispatch Queue</code>和<code>Global Dispatch Queue</code>执行<code>dispatch_retain</code>和<code>dispatch_release</code>函数不会引起任何变化，也不会有任何问题。这也是获取并使用<code>Global Dispatch Queue</code>比生成、使用、释放<code>Concurrent Dispatch Queue</code>更轻松的原因</li>
</ul>
</li>
<li><p>对于<code>Concurrent Dispatch Queue</code>来说，不管生成多少，由于<code>XNU</code>内核只使用有效管理的线程，因此不会发生<code>Serial Dispatch Queue</code>那样，因大量生成<code>Serial Dispatch Queue</code>而消耗大量内存，降低系统响应性能的情况</p>
</li>
<li>生成的<code>Dispatch Queue</code>必须由程序员负责释放，因<code>Dispatch Queue</code>并没有像<code>Block</code>那样具有作为<code>OC</code>对象来处理的技术</li>
<li>在<code>dispatch_async</code>函数中追加<code>Block</code>到<code>Concurrent Dispatch Queue</code>，<code>Block</code>内部会通过<code>dispatch_retain</code>和<code>dispatch_release</code>函数对<code>Dispatch Queue</code>持有和释放</li>
<li><code>Dispatch Queue</code>也像<code>OC</code>的引用计数式内存管理一样，需要通过<code>dispatch_retain</code>和<code>dispatch_release</code>函数的引用计数来管理内存</li>
</ul>
</li>
</ul>
<h5 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a><code>dispatch_set_target_queue</code></h5><ul>
<li>变更生成的<code>Dispatch Queue</code>的执行优先级要使用<code>dispatch_set_target_queue</code>函数</li>
<li>指定要变更执行优先级的<code>Dispatch Queue</code>为<code>dispatch_set_target_queue</code>函数的第一个参数，指定与要使用的执行优先级相同优先级的<code>Global Dispatch Queue</code>为第二个参数，即将第一个参数的执行优先级指定为与第二个参数相同的执行优先级，第二个参数为目标</li>
<li>注：<code>dispatch_set_target_queue</code>第一个参数如果指定系统提供的<code>Main Dispatch Queue</code>和<code>Global Dispatch Queue</code>则不知道会出现什么状况，因此第一个参数均不可指定<code>Main</code>和<code>Global</code>为参数</li>
<li>不仅可以变更<code>Dispatch Queue</code>的执行优先级，还可以作成<code>Dispatch Queue</code>的执行阶层。如，在多个<code>Serial Dispatch Queue</code>中用<code>dispatch_set_target_queue</code>函数指定目标为某一个<code>Serial Dispatch Queue</code>，那么原先本应并行执行的多个<code>Serial Dispatch Queue</code>，在目标<code>Serial Dispatch Queue</code>上只能同时执行一个处理</li>
</ul>
<h5 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a><code>dispatch_after</code></h5><ul>
<li>想在指定时间后执行处理的情况，可使用<code>dispatch_after</code>函数来实现</li>
<li>注<ul>
<li><code>dispatch_after</code>函数并不是在指定时间后执行处理，而只是在指定时间追加处理到<code>Dispatch Queue</code></li>
</ul>
</li>
<li>参数<ul>
<li>第一个参数<ul>
<li>指定时间用的<code>dispatch_time_t</code>类型的值</li>
<li>该值使用<code>dispatch_time</code>或<code>dispatch_walltime</code>函数生成<ul>
<li><code>dispatch_time</code><ol>
<li><code>dispatch_time</code>函数获取第一个参数值指定的时间，到第二个参数指定的毫微秒单位时间后的时间</li>
<li>数值和<code>NSEC_PER_SEC</code>的乘积得到单位为毫微秒的数值</li>
<li>使用<code>NSEC_PER_MSEC</code>则可以以毫秒为单位计算</li>
<li>通常用于计算相对时间</li>
</ol>
</li>
<li><code>dispatch_walltime</code><ol>
<li>由<code>POSIX</code>中使用的<code>struct timespec</code>类型的时间得到<code>dispatch_time_t</code>类型的值</li>
<li>用于计算绝对时间</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>第二个参数<ul>
<li>指定要追加处理的<code>Dispatch Queue</code> </li>
</ul>
</li>
<li>第三个参数<ul>
<li>指定记述要执行处理的<code>Block</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a><code>Dispatch Group</code></h5><ul>
<li><p>使用场景：在追加到<code>Dispatch Queue</code>中的多个处理全部结束后想执行结束处理</p>
<ul>
<li>针对上述场景，使用<code>Serial Dispatch Queue</code>时，只要将想执行的处理全部追加到该队列中，并在最后追加结束处理即可实现</li>
<li>但使用<code>Concurrent Dispatch Queue</code>时或同时使用多个<code>Dispatch Queue</code>时，使用<code>Dispatch Group</code>进行处理</li>
</ul>
</li>
<li><p>使用<code>Dispatch Group</code>的原因：无论向什么样的<code>Dispatch Queue</code>中追加处理，使用<code>Dispatch Group</code>都可监视这些处理执行的结束。一旦检测到所有处理执行结束，就可将结束的处理追加到<code>Dispatch Queue</code>中</p>
</li>
<li><p>在<code>Dispatch Group</code>中也可以使用<code>dispatch_group_wait</code>函数仅等待全部处理执行结束</p>
<ul>
<li>第二个参数值<ol>
<li><code>DISPATCH_TIME_FOREVER</code>，意味着永久等待。只要属于<code>Dispatch Group</code>的处理尚未执行结束，就会一直等待，中途不能取消</li>
<li><code>DISPATCH_TIME_NOW</code>，则不用任何等待即可判定属于<code>Dispatch Group</code>的处理是否执行结束</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a><code>dispatch_barrier_async</code></h5><ul>
<li>使用场景：在访问数据库或文件时，避免数据竞争，高效率地进行访问</li>
<li><code>dispatch_barrier_async</code>函数同<code>dispatch_queue_create</code>函数生成的<code>Concurrent Dispatch Queue</code>一起使用</li>
<li>控制流程：<code>dispatch_barrier_async</code>函数会等待追加到<code>Concurrent Dispatch Queue</code>上的并行执行的处理全部结束之后，再将指定的处理追加到该<code>Concurrent Dispatch Queue</code>中，然后在由<code>dispatch_barrier_async</code>函数追加的处理执行完毕后，<code>Concurrent Dispatch Queue</code>才恢复为一般的动作，追加到该<code>Concurrent Dispatch Queue</code>的处理又开始并行执行</li>
<li>使用<code>Concurrent Dispatch Queue</code>和<code>dispatch_barrier_async</code>函数可实现高效率的数据库访问和文件访问</li>
</ul>
<h5 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a><code>dispatch_sync</code></h5><ul>
<li><code>dispatch_async</code>函数的<code>async</code>意味着“非同步”<code>(asynchronous)</code>，就是将指定的<code>Block</code>“非同步”地追加到指定的<code>Dispatch Queue</code>中。<code>dispatch_async</code>函数不做任何等待</li>
<li><code>dispatch_sync</code>函数的<code>sync</code>意味着“同步”<code>(synchronous)</code>，就是将指定的<code>Block</code>“同步”追加到指定的<code>Dispatch Queue</code>中。在追加的<code>Block</code>执行结束之前，<code>dispatch_sync</code>函数会一直等待。“等待”意味着当前线程停止</li>
<li>使用<code>dispatch_sync</code>容易引起死锁问题，因此在使用同步等待处理执行的API时需谨慎</li>
</ul>
<h5 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a><code>dispatch_apply</code></h5><ul>
<li><code>dispatch_apply</code>函数是<code>dispatch_sync</code>函数和<code>Dispatch Group</code>的关联<code>API</code></li>
<li><code>dispatch_apply</code>函数功能：按指定的次数将指定的<code>Block</code>追加到指定的<code>Dispatch Queue</code>中，并等待全部处理执行结束</li>
<li><code>dispatch_apply</code>函数与<code>dispatch_sync</code>函数相同，会等待处理执行结束</li>
</ul>
<h5 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a><code>dispatch_suspend/dispatch_resume</code></h5><ul>
<li><code>dispatch_suspend</code>函数挂起指定的<code>Dispatch Queue</code></li>
<li><code>dispatch_resume</code>函数恢复指定的<code>Dispatch Queue</code></li>
<li><code>dispatch_suspend/dispatch_resume</code>函数对已经执行的处理没有影响。挂起后，追加到<code>Dispatch Queue</code>中但尚未执行的处理在此之后停止处理，而恢复则使得这些处理能够继续执行</li>
</ul>
<h5 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a><code>Dispatch Semaphore</code></h5><ul>
<li><code>Dispatch Semaphore</code>是持有计数的信号，该计数是多线程编程中的计数类型信号。从更细粒度上控制并行执行处理更新数据时，会产生数据不一致的情况，进行排他控制的处理</li>
<li>在<code>Dispatch Semaphore</code>中，使用计数来实现，计数为<code>0</code>时等待，计数为<code>1</code>或大于<code>1</code>时，减去<code>1</code>而不等待的功能</li>
<li><p>使用</p>
<ul>
<li>使用函数<code>dispatch_semaphore_create()</code>生成<code>Dispatch Semaphore</code></li>
<li>参数表示计数的初始值</li>
<li><code>dispatch_semaphore_wait</code>函数返回<code>0</code>时，可安全地执行需要进行排他控制的处理。该处理结束时通过<code>dispatch_semaphore_signal</code>函数将<code>Dispatch Semaphore</code>的计数值加<code>1</code></li>
</ul>
</li>
<li><p>在没有<code>Serial Dispatch Queue</code>和<code>dispatch_barrier_async</code>函数那么大粒度且一部分处理需要进行排他控制的情况下，<code>Dispatch Semaphore</code>可发挥作用。<code>Dispatch Semaphore</code>使用的粒度具体到并行执行中单一的线程上</p>
</li>
</ul>
<h5 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a><code>dispatch_once</code></h5><ul>
<li>dispatch_once函数是保证在应用程序执行中只执行一次指定处理的API</li>
<li>应用在单例模式中，单例对象的创建</li>
</ul>
<h5 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a><code>Dispatch I/O</code></h5><ul>
<li>在读取较大文件时，将文件分成合适的大小并使用<code>Global Dispatch Queue</code>并列读取，会使读取速度快不少。可以通过使用<code>Dispatch I/O</code>，提高文件读取速度</li>
<li>现今的输入/输出硬件已经可以做到一次使用多个线程更快地并列读取了。实现这一功能的是<code>Dispatch I/O</code>和<code>Dispatch Data</code></li>
</ul>
<h3 id="GCD实现"><a href="#GCD实现" class="headerlink" title="GCD实现"></a><code>GCD</code>实现</h3><h5 id="Dispatch-Queue-1"><a href="#Dispatch-Queue-1" class="headerlink" title="Dispatch Queue"></a><code>Dispatch Queue</code></h5><ul>
<li>实现<code>GCD</code>所用到的工具<ul>
<li>用于管理追加的<code>Block</code>的<code>C</code>语言层实现的<code>FIFO</code>队列</li>
<li><code>Atomic</code>函数中实现的用于排他控制的轻量级信号</li>
<li>用于管理线程的<code>C</code>语言层实现的一些容器</li>
</ul>
</li>
<li>线程管理中使用<code>GCD</code>的实质原因：应用程序中编写的线程管理用的代码要在系统级实现<ul>
<li>系统级，即<code>iOS</code>和<code>OS X</code>的核心<code>XNU</code>内核级上实现</li>
<li>在系统级上，保证了实现管理线程的<code>GCD</code>的性能</li>
</ul>
</li>
<li>使用<code>GCD</code>要比使用<code>pthreads</code>和<code>NSThread</code>这些一般的多线程编程<code>API</code>更好</li>
<li>用于实现<code>Dispatch Queue</code>而使用的软件组件</li>
</ul>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>提供技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>libdispatch</td>
<td>Dispatch Queue</td>
</tr>
<tr>
<td>Libc(pthreads)</td>
<td>pthread_workqueue</td>
</tr>
<tr>
<td>XNU内核</td>
<td>workqueue</td>
</tr>
</tbody>
</table>
<ul>
<li>使用的<code>GCD</code>的<code>API</code>全部为包含在<code>libdispatch</code>库中的<code>C</code>语言函数<ul>
<li><code>Dispatch Queue</code>通过结构体和链表，被实现为<code>FIFO</code>队列</li>
<li><code>FIFO</code>队列管理是通过<code>dispatch_async</code>等函数所追加的<code>Block</code></li>
<li><code>Block</code>并不是直接加入<code>FIFO</code>队列，而是先加入<code>Dispatch Continuation</code>这一<code>dispatch_continuation_t</code>类型结构体中，然后再加入<code>FIFO</code>队列。该<code>Dispatch Continuation</code>用于记忆<code>Block</code>所属的<code>Dispatch Group</code>和其他一些信息，即执行的上下文</li>
</ul>
</li>
</ul>
<h5 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a><code>Dispatch Source</code></h5><ul>
<li>Dispatch Source是BSD系内核惯有功能kqueue的包装。kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。其CPU负荷非常小，尽量不占用资源。kqueue可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种</li>
<li>Dispatch Source可处理以下事件</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td>变量增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td>变量 OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td>MACH端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td>MACH端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td>检测到与进程相关的事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td>可读取文件映像</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td>接收信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td>定时器</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td>文件系统有变更</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td>可写入文件映像</td>
</tr>
</tbody>
</table>
<ul>
<li><p>事件发生时，在指定的<code>Dispatch Queue</code>中可执行事件的处理</p>
</li>
<li><p>实际上<code>Dispatch Queue</code>没有“取消”这一概念。一旦将处理追加到<code>Dispatch Queue</code>中，就没有方法可将该处理去除，也没有方法可在执行中取消该处理</p>
</li>
<li><code>Dispatch Source</code>与<code>Dispatch Queue</code>不同，是可以取消的。而且取消时必须执行的处理可指定为回调用的<code>Block</code>形式。因此使用<code>Dispatch Source</code>实现<code>XNU</code>内核中发生的事件处理要比直接使用<code>kqueue</code>实现更为简单</li>
</ul>
<h3 id="GCD中各种队列代码的示例"><a href="#GCD中各种队列代码的示例" class="headerlink" title="GCD中各种队列代码的示例"></a><code>GCD</code>中各种队列代码的示例</h3><ul>
<li>异步函数+并发队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">//异步函数</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">//要执行任务的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>同步函数+并发队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//并发队列 - 通过全局调度队列获取并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">//同步函数</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">//要执行任务的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>异步函数+串行队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">//异步函数</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">//要执行任务的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>同步函数+串行队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">//同步函数</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">//要执行任务的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>异步函数+主队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//主队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">//异步函数</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">//要执行任务的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>同步函数+主队列 - <strong>你等我，我等你，最终结果是不执行了</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//主队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">//同步函数</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">//要执行任务的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意：使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列</p>
</li>
<li><p>总结</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>全局并发队列</th>
<th>手动创建串行队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步(sync)</td>
<td>没有开启新线程，串行执行任务</td>
<td>没有开启新线程，串行执行任务</td>
<td>没有开启新线程，串行执行任务</td>
</tr>
<tr>
<td>异步(async)</td>
<td>有开启新线程，并发执行任务</td>
<td>有开启新线程，串行执行任务</td>
<td>没有开启新线程，串行执行任务</td>
</tr>
</tbody>
</table>
<h3 id="GCD的实际应用"><a href="#GCD的实际应用" class="headerlink" title="GCD的实际应用"></a><code>GCD</code>的实际应用</h3><h5 id="温习"><a href="#温习" class="headerlink" title="温习"></a>温习</h5><ul>
<li>同步/异步 (侧重描述能不能开启新的线程)<ul>
<li>同步不开线程，对应函数<code>dispatch_sync</code> (在当前线程中执行任务，不具备开启新线程的能力)</li>
<li>异步，除了主队列，都开线程，开多少条由队列的类型来决定，对应函数<code>dispatch_async</code> (在新的线程中执行任务，具备开启新线程的能力)</li>
</ul>
</li>
<li>并发/串行 (侧重描述任务的执行方式)<ul>
<li>并发，多个任务并发(同时)执行</li>
<li>串行，一个任务执行完毕后，再执行下一个任务</li>
</ul>
</li>
<li>全局队列/主队列 <ul>
<li>全局队列，同步不开线程，异步开N条线程</li>
<li>主队列，同步会卡死，异步不开线程(因它有主线程)</li>
</ul>
</li>
<li><code>GCD</code>是苹果公司为多核的并行运算提出的解决方案<ul>
<li>这一方案会自动利用更多的<code>CPU</code>内核</li>
<li>会自动管理线程的生命周期(创建线程、调度任务、销毁线程)</li>
</ul>
</li>
</ul>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>异步下载图片</li>
<li><p>线程安全-设置依赖关系</p>
<ul>
<li>如，异步下载<code>20</code>张图片写入一个数组中，为了保证效率所以数组为非线程安全的，如何解决多线程同时访问的问题。<ul>
<li>解决方法：通过<code>GCD</code>的阻塞(<code>dispatch_barrier_async</code>)和异步</li>
<li>注：如使用了<code>dispatch_barrier_async</code>，须用创建的并发队列，而不能用全局队列</li>
</ul>
</li>
<li>如，想在dispatch_queue中所有的任务执行完成后再执行某种操作<ul>
<li>解决方法<ol>
<li>串行队列中，可以把该操作放到最后一个任务执行完成后继续</li>
<li>并行队列中，使用<code>dispatch_group</code>进行操作(Global Dispatch Queue是并行队列，可以通过dispatch_get_global_queue(0,0)获得到)</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单例(使用<code>dispatch_once</code>)</p>
</li>
<li>延迟执行(使用<code>dispatch_after</code>)</li>
<li><p>其他</p>
<ul>
<li><code>dispatch_suspend</code>函数只能暂停新追加未执行的<code>block</code>，已经处于执行中的<code>block</code>是无法暂停的，实质是将对应的<code>dispatch queue</code>挂起，从而达到暂停的效果</li>
</ul>
</li>
<li><p>任务之间不太互相依赖，而需要更高的并发能力，<code>GCD</code>更有优势</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/Swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/27/Swift/" class="post-title-link" itemprop="url">Swift</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-27 11:08:36" itemprop="dateCreated datePublished" datetime="2019-05-27T11:08:36+08:00">2019-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Swift</code> 是支持多编程范式和编译式的语言</p>
<p><code>Swift</code> 的特点：</p>
<ul>
<li>结合<code>C</code>和<code>OC</code>的优点</li>
<li>和<code>OC</code>使用相同的运行环境</li>
<li>用于开发<code>OS X</code>和<code>iOS</code>应用程序</li>
<li>将<code>OC</code>中的<code>.h</code>和<code>.m</code>文件合并成了一个文件<code>.swift</code>文件</li>
<li>有类型检查的能力，即可以根据值推出变量的类型 - “类型意识强”</li>
</ul>
<p>学习<code>swift</code>时，可利用利器<code>Playground</code>，因其能实时显示结果</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编程范式：编程的模式、方法，编程风格。每种语言根据其特性，有对应的</span><br><span class="line">编程模式、方法，有对应的技术禁止和技术允许。</span><br><span class="line"></span><br><span class="line">一种语言，因其语言所具有的特性，可有多种编程范型（编程模式）。如</span><br><span class="line"> c++ 可有过程化编程、面向对象编程、泛型编程。范型元素，即模式元素。</span><br></pre></td></tr></table></figure>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li>使用<code>import</code>语句引入任何<code>OC</code>框架（或<code>C</code>库）</li>
<li>程序由多种标记组成，标记包括单词、标识符、常量、字符串、符号</li>
<li><p>注释</p>
<ol>
<li>单行注释：<code>//注释内容</code></li>
<li>多行注释：<code>/*注释内容*/</code></li>
</ol>
</li>
<li><p>分号</p>
<ol>
<li>不要求在每行语句的结尾使用分号(;)</li>
<li>在同一行书写多条语句时，必须用分号隔开，最后一条语句可不用分号结尾</li>
</ol>
</li>
<li><p>标识符</p>
<ul>
<li>是给变量、常量、方法、函数、枚举、结构体、类、协议等指定的名字</li>
<li>命名规则<ol>
<li>区分大小写</li>
<li>首字符可以以下划线(_)或者字母开始，但不能是数字</li>
<li>标识符中其他字符可以是下划线(_)、字母或数字</li>
<li>如果一定要使用关键字作为标识符，可以在关键字前后添加重音符号(‘)。注，通常不用关键字作为标识符</li>
</ol>
</li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li>是类似于标识符的保留字符序列</li>
<li>关键字是对编译器具有特殊意义的预定义保留标识符</li>
<li>常见的关键字<ol>
<li>与声明有关</li>
<li>与语句有关，如条件/判断/循环等语句</li>
<li>表达式和类型</li>
<li>在特定上下文中使用的关键字</li>
</ol>
</li>
</ul>
</li>
<li><p>空格</p>
<ul>
<li>对空格的使用有一定的要求，但不像<code>Python</code>对缩进的要求那么严格</li>
<li>运算符不能直接跟在变量或常量的后面</li>
<li>运算表达式中空格有断句的作用，在这种情况下使用分号<code>(;)</code>来表示一句完整的运算表达式</li>
</ul>
</li>
<li><p>打印输出</p>
<ul>
<li>使用<code>print</code>函数打印输出</li>
</ul>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>有符号浮点数类型</p>
<ul>
<li><p><code>Double</code></p>
<ol>
<li><code>64</code>位浮点数，需要存储很大或很高精度的浮点数时使用此类型</li>
<li>精确度高，至少有<code>15</code>位数字</li>
</ol>
</li>
<li><p><code>Float</code></p>
<ol>
<li><code>32</code>位浮点数，对精度要求不高时使用此类型</li>
<li>最少只有<code>6</code>位数字</li>
</ol>
</li>
<li><p>当使用浮点数时，<code>swift</code>默认为<code>Double</code>类型</p>
</li>
</ul>
</li>
<li><p>布尔值，<code>true/false</code></p>
</li>
<li><p>字符串，字符的序列集合</p>
</li>
<li><p>可选类型<code>(Optional)</code>，使用可选类型来处理值可能缺失的情况。可选类型表示有值或没有值</p>
</li>
<li><p>类型别名</p>
<ul>
<li>对当前的类型定义了另一个名字，通过使用<code>typealias</code>关键字来定义</li>
<li>语法格式：<code>typealias newname = type</code></li>
</ul>
</li>
<li><p>类型安全</p>
<ul>
<li><code>swift</code>是一种类型安全<code>(type safe)</code>的语言</li>
<li>在编译时进行类型检查<code>(type checks)</code>，在这期间把不匹配的类型标记为错误</li>
</ul>
</li>
<li><p>类型推断</p>
<ul>
<li>在没有显示指定类型时，<code>swift</code>会使用类型推断<code>(type inference)</code>来选择合适的类型</li>
<li><code>OC</code>中声明变量时需要指明类型</li>
<li>当推断浮点数的类型时，<code>swift</code>总是会选择<code>Double</code>而不是<code>Float</code></li>
<li>如果表达式中同时出现了整数和浮点数，会被推断为<code>Double</code>类型</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li>变量类型不同时，若要进行相互赋值时，需要进行显示转换，将数据类型统一为其中的一种类型</li>
</ul>
</li>
<li><p>整数</p>
<ul>
<li>可正可负的整数，称为有符号整数</li>
<li>只能为正的整数，称为无符号整数</li>
</ul>
</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul>
<li>变量是占位符，用于引用计算机内存地址</li>
<li>类型决定了变量占用内存的大小</li>
<li>变量声明<ul>
<li>告诉编译器在内存中的哪个位置上为变量创建多大的存储空间</li>
<li>在使用前，用关键字<code>var</code>声明它</li>
</ul>
</li>
<li>变量命名，规则见“基本语法/标识符/命名规则”</li>
<li>变量输出<ul>
<li>变量和常量可以使用<code>print</code>函数来输出</li>
<li>在字符串中可以使用括号与反斜线来插入变量</li>
</ul>
</li>
</ul>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><ul>
<li>使用关键字<code>let</code>来声明</li>
<li>类型标注<ul>
<li>说明常量或变量中要存储的值的类型</li>
<li>添加类型标注，需要在常量或变量名后面加上一个冒号和空格，然后加上类型名称，如：<code>let/var variablename: Type</code></li>
</ul>
</li>
<li>变量命名，规则见“基本语法/标识符/命名规则”</li>
<li>常量需要的开销比变量小</li>
<li>常量的值，在编译的时候可以不立即指定，但是只能给它赋值一次</li>
</ul>
<h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><ul>
<li><p>整型字面量</p>
<ul>
<li>二进制前缀<code>0b</code></li>
<li>八进制前缀<code>0o</code></li>
<li>十六进制前缀<code>0x</code></li>
</ul>
</li>
<li><p>浮点型字面量</p>
<ul>
<li>用指数表示的小数<ol>
<li>十进制表示，指数部分由大写或小写字母<code>e</code>为前缀后跟十进制数字串组成，这串数字表示<code>e</code>之前的数量乘以<code>10</code>的几次方，如：<code>1.25e2表示1.25*10^2也就是125.0</code></li>
<li>十六进制表示，指数部分由大写或小写字母<code>p</code>为前缀后跟十进制数字串组成，这串数字表示<code>p</code>之前的数量乘以<code>2</code>的几次方，如：<code>0xFp2表示15*2^2也就是60</code></li>
</ol>
</li>
</ul>
</li>
<li><p>布尔型字面量</p>
<ul>
<li><code>true 表示真</code></li>
<li><code>false 表示假</code></li>
<li><code>nil 表示没有值</code></li>
</ul>
</li>
</ul>
<h5 id="可选类型-Optionals"><a href="#可选类型-Optionals" class="headerlink" title="可选类型(Optionals)"></a>可选类型<code>(Optionals)</code></h5><ul>
<li>用于处理值缺失的情况</li>
<li><code>swift</code>定义后缀<code>?</code>作为命名为可选类型<code>(Optional)</code>的缩写</li>
<li><code>var optionalInteger: Int? 等价于 var optionalInteger: Optional&lt;Int&gt;</code>，注：类型和<code>?</code>之间没有空格</li>
<li>可选类型是一个含有两种情况的枚举，<code>None</code>和<code>Some(T)</code></li>
<li>任何类型都可以明确声明为可选类型</li>
<li><p>可以使用后缀操作符<code>!</code>来访问可选类型的实例变量值</p>
<ul>
<li>使用操作符<code>!</code>去获取值为<code>nil</code>的可选变量会有运行时错误</li>
<li>可以用可选链接和可选绑定选择性执行可选表达式上的操作，这种情况下，如果值为<code>nil</code>，任何操作都不会执行，也不会有运行报错</li>
</ul>
</li>
<li><p>可选类型类似于<code>OC</code>中指针的<code>nil</code>值，但是<code>nil</code>只对类<code>(class)</code>有用，而可选类型对所有类型都可用，并且更安全</p>
</li>
<li><p>可选值的强制解析</p>
<ul>
<li>在确定可选类型确实包含值之后，可在可选的名字后面加一个感叹号<code>(!)</code>来获取值</li>
<li>使用<code>!</code>来获取一个不存在的可选值会导致运行时错误，因此，使用<code>!</code>来强制解析值之前，一定要确定可选包含一个非<code>nil</code>的值</li>
</ul>
</li>
<li><p>自动解析，在声明可选变量时使用<code>!</code>替换<code>?</code>，这样可选变量在使用时就不需要再加<code>!</code>来获取值，它会自动解析</p>
</li>
<li>可选绑定，用来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或变量</li>
</ul>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><ul>
<li><p>算术运算符</p>
<ul>
<li>除号<code>(/)</code></li>
<li>求余<code>(%)</code></li>
<li><code>swift3</code>中已经取消了<code>++</code>、<code>--</code>，对应的操作符为，<code>++</code>对应<code>+=</code>，<code>--</code>对应<code>-=</code></li>
</ul>
</li>
<li><p>比较运算符</p>
</li>
<li>逻辑运算符</li>
<li><p>位运算符</p>
<ul>
<li>用来对二进制位进行操作</li>
<li>取反<code>(~)</code>，对操作数的每一位取反</li>
<li>按位与与<code>(&amp;)</code>，每个位设为<code>1</code>的条件是两个输入数的同一位相同且为<code>1</code>时，就设为<code>1</code>，反之则为<code>0</code></li>
<li>按位与或<code>(|)</code>，每个位设为<code>1</code>的条件是只要两个输入数的一位中有一个为<code>1</code>时，就设为<code>1</code></li>
<li>按位异或<code>(^)</code>，每个位设为<code>1</code>的条件是两个输入数的同一位不同，如果相同就设为<code>0</code></li>
<li>按位左移<code>(&lt;&lt;)</code>，移动指定位数，空位用<code>0</code>填充</li>
<li>按位右移<code>(&gt;&gt;)</code>，移动指定位数，空位用<code>0</code>填充</li>
</ul>
</li>
<li><p>赋值运算符</p>
</li>
<li><p>区间运算符</p>
<ul>
<li>闭区间运算符<code>((a...b))</code>，在迭代一个区间的所有值时是非常有用的，如在<code>for-in</code>循环中</li>
<li>半开区间运算符<code>((a...)</code></li>
</ul>
</li>
<li><p>其他运算符</p>
<ul>
<li>一元运算符。如<code>!</code>，在<code>swift</code>中用在<code>Optional</code>类型取值</li>
<li>二元运算符</li>
<li>三元运算符。如，<code>a ? b : c</code></li>
</ul>
</li>
<li><p>运算符优先级</p>
<ul>
<li>指针最优，单目运算优于双目运算</li>
<li>先乘除(模)，后加减</li>
<li>先算术，后移位，最后位运算。如，<code>1 &lt;&lt; 3 + 2 &amp; 7 等价于 (1 &lt;&lt; (3 + 2)) &amp; 7</code></li>
<li>逻辑运算最后计算</li>
</ul>
</li>
</ul>
<h5 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h5><ul>
<li><code>continue</code>语句，告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代</li>
<li><code>break</code>语句，中断当前循环</li>
<li><code>fallthrough</code>语句，如果在一个<code>case</code>执行完后，想要继续执行下面的<code>case</code>，需要<code>fallthrough</code>(贯穿)关键字</li>
</ul>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul>
<li>可以使用空的字符串字面量赋值给变量或初始化一个<code>String</code>类的实例来初始化一个空的字符串</li>
<li>使用字符串属性<code>isEmpty</code>来判断字符串是否为空</li>
<li>字符串中插入值，可以在其中包含常量、变量、字面量或表达式，插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中，字符串插值是一种构建新字符串的方式</li>
<li>字符串可以通过<code>+</code>号来连接</li>
<li>字符串长度使用<code>String.count</code>属性来计算</li>
<li>字符串比较，使用<code>==</code>来比较两个字符串是否相等</li>
<li><code>Unicode</code>是一个国际标准，用于文本的编码，<code>Swift</code>的<code>String</code>类型是基于<code>Unicode</code>建立的</li>
<li>常用函数<ul>
<li><code>isEmpty</code> 判空</li>
<li><code>hasPrefix</code> 检查是否拥有指定前缀</li>
<li><code>hasSuffix</code> 检查是否拥有指定后缀</li>
<li><code>Int(String)</code> 转换字符串数字为整型</li>
<li><code>String.count</code> 计算字符串长度</li>
<li><code>+</code> 连接两个字符串，并返回一个新的字符串</li>
<li><code>==</code> 判断两个字符串是否相等</li>
<li><code>&lt;</code> 比较两个字符串，对两个字符串的字母逐一比较</li>
<li><code>utf8、utf16、unicodeScalars、+=、!=</code></li>
</ul>
</li>
</ul>
<h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><ul>
<li><code>swift</code>的字符是一个单一的字符字符串字面量，类型为<code>Character</code></li>
<li>不能在<code>Character</code>类型中存储更多的字符，如：<code>let/var char: Character = &quot;ABC&quot;</code>，这样会报错，这种情况下<code>&quot;ABC&quot;</code>被当作<code>String</code>类型</li>
<li>不能创建空的<code>Character</code>类型变量或常量，这种情况下，<code>&quot;&quot;</code>被当作<code>String</code>类型</li>
<li>可以对字符串进行字符遍历，使用<code>for-in</code>遍历字符串中的<code>character</code>属性</li>
<li>可以对字符串进行字符连接，使用<code>String</code>的<code>append()</code>方法来实现</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul>
<li>数组是有序列表，同一类型的多个值</li>
<li>相同的值可以多次出现在一个数组的不同位置中</li>
<li><code>Swift</code>数组会强制检测元素的类型，如类型不同则会报错</li>
<li>常量数组的大小和内容都不可以修改</li>
<li>数组的索引从<code>0</code>开始</li>
<li><p>初始化方式构建的数组中，每个元素的值都是指定的初始值</p>
<ul>
<li>初始化方式构建数组的语法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var someArray = [SomeType](repeating: InitialValue, </span><br><span class="line">count: NumberOfElements)//InitialValue是初始值，</span><br><span class="line">NumberOfElements是数组大小</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可以使用<code>append()</code>方法或赋值运算符<code>+=</code>在数组末尾添加元素</p>
</li>
<li><p>遍历数组</p>
<ul>
<li>使用<code>for-in</code>循环来遍历数组中的数据项</li>
<li>如需要每个数据项的值和索引值，可以使用<code>String</code>的<code>enumerate()</code>方法来进行数组遍历</li>
</ul>
</li>
<li><p>可以使用加法操作符<code>+</code>来合并两种已存在的相同类型的数组</p>
</li>
<li>使用<code>count</code>属性，计算数组元素个数</li>
<li>使用<code>isEmpty</code>属性，来判断数组是否为空</li>
</ul>
<h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><ul>
<li><code>swift</code>字典会强制检测元素的类型</li>
<li><code>swift</code>字典的<code>key</code>没有类型限制可以是整型或字符串，但必须是唯一的</li>
<li>常量字典的大小和内容都不可以修改</li>
<li>使用<code>updateValue(forKey:)</code>增加或更新字典的内容。如果<code>key</code>不存在，则添加值，如果<code>key</code>存在则修改<code>key</code>对应的值，使用<code>updateValue(forKey:)</code>时，会返回旧值</li>
<li>使用<code>removeValue(forKey:)</code>移除<code>key-value</code>对，如果<code>key</code>存在，该方法返回移除的值，如果不存在返回<code>nil</code>。可以通过指定键的值为<code>nil</code>来移除<code>key-value</code>对</li>
<li>使用<code>enumerate()</code>方法遍历字典时，获取的<code>value</code>是对应的<code>key-value</code>对</li>
<li>可以对字典的键和值，分别取对应的元素构成的数组</li>
<li>使用<code>count</code>属性来获知字典有多少个键值对</li>
<li>使用<code>isEmpty</code>属性来对字典进行判空</li>
</ul>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul>
<li>函数是用来完成特定任务的独立代码块</li>
<li><p>函数的声明和定义</p>
<ul>
<li>声明，告诉编译器函数的名字、返回类型及参数</li>
<li>定义，提供了函数的实体</li>
</ul>
</li>
<li><p><code>swift</code>函数包含了参数类型及返回值类型</p>
</li>
<li>使用关键字<code>func</code>来定义函数</li>
<li>函数的实参传递的顺序必须与形参列表相同</li>
<li><code>-&gt;</code>后定义函数的返回值类型</li>
<li><p>元组作为函数返回值</p>
<ul>
<li>元组与数组类似，不同的是，元组中的元素可以是任意类型，使用的是圆括号</li>
<li>可以用元组<code>(tuple)</code>类型让多个值作为一个复合值从函数中返回</li>
</ul>
</li>
<li><p>可以在局部参数名前指定外部参数名，中间以空格分隔，外部参数名用于在函数调用时传递给函数的参数。注，如提供了外部参数名，那么函数在被调用时，必须使用外部参数名</p>
</li>
<li><p>可变参数，可变参数通过在变量类型名后面加入<code>(...)</code>的方式来定义，如<code>func vari&lt;N&gt;(members: N...){}</code></p>
</li>
<li><p>一般默认在函数中定义的参数都是常量参数，即参数只能查询使用，不能改变它的值。若想要改变参数的值，可以在参数定义前加<code>inout</code>关键字，这样就可以改变这个参数的值了</p>
</li>
<li><p>一般默认的参数传递都是传值调用的，而不是传引用。所以传入的参数在函数内改变，并不影响原来的那个参数，传入的只是这个参数的副本。当传入的参数作为输入输出参数时，需要在参数名前加<code>&amp;</code>符，表示这个值可以被函数修改。如，函数调用的时候：<code>swapTwoInts(&amp;x, &amp;y)</code></p>
</li>
<li><p>每个函数都有特定的函数类型，由函数的参数类型和返回类型组成</p>
</li>
</ul>
<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><ul>
<li>闭包，是自包含的功能代码块，可以在代码中使用或者用来作为参数传值</li>
<li>函数和闭包都是引用类型</li>
</ul>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><ul>
<li>枚举是一组有共同特性的数据的集合</li>
</ul>
<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><ul>
<li>结构体是一种构造体</li>
<li>可以为结构体定义属性(常量、变量)和添加方法，从而扩展结构体的功能</li>
<li>结构体总是通过被复制的方式在代码中传递，因此它的值是不可修改的</li>
<li>通过关键字<code>struct</code>来定义结构体</li>
<li>通过结构体名来访问结构体成员</li>
<li>结构体实例化使用<code>let</code>关键字</li>
<li>结构体实例总是通过值传递来定义你的自定义数据类型</li>
<li><p>存在以下条件时，考虑构建结构体</p>
<ul>
<li>结构体的主要目的是用来封装少量相关简单数据值</li>
<li>有理由预计一个结构体实例在赋值或传递时，封装的数据将会被拷贝而不是被引用</li>
<li>任何在结构体中存储的值类型属性，也将会被拷贝，而不是被引用</li>
<li>结构体不需要去继承另一个已存在类型的属性或行为</li>
</ul>
</li>
<li><p>结构体实例是通过值传递而不是通过引用传递</p>
</li>
<li>结构体内使用成员属性时，使用<code>self</code>关键字</li>
</ul>
<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><ul>
<li>类是一种构造体</li>
<li>可以为类定义属性(常量、变量)和方法</li>
<li><code>swift</code>的类不需要为自定义类去创建独立的接口(<code>.h</code>文件)和实现文件(<code>.m</code>文件)</li>
<li><p><code>swift</code>中创建类，在一个单一文件中定义一个类，系统会自动生成面向其他代码的外部接口</p>
</li>
<li><p>类和结构体的对比：</p>
<ul>
<li><p>共同点</p>
<ol>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义附属脚本用于访问值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>符合协议以对某类提供标准功能</li>
</ol>
<ul>
<li>类特有的<ol>
<li>继承，允许一个类继承另一个类的特征</li>
<li>类型转换，允许在运行时检查和解释一个类实例的类型</li>
<li>解构器，允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数，允许对一个类的多次引用</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>类的属性通过<code>“.”</code>来访问，格式：<code>实例化类名.属性名</code></p>
</li>
<li>恒等运算符<ul>
<li>因类是引用类型，有可能有多个常量或变量同时引用某一个类实例，为了能够判定两个常量或变量是否引用同一个类实例，<code>swift</code>提供了两个恒等运算符：<code>===</code>(判断是否引用相同的类实例)、<code>!==</code>(判断是否引用不相同的类实例)</li>
</ul>
</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p>属性将值跟特定的类、结构体或枚举关联</p>
</li>
<li><p>存储属性、计算属性</p>
<ul>
<li>存储属性<ol>
<li>存储常量或变量作为实例的一部分，用于类和结构体</li>
<li>一个存储属性就是存储在特定类或结构体的实例里的一个常量(用<code>let</code>定义)或变量(用<code>var</code>定义)</li>
<li>可以在定义存储属性的时候指定默认值</li>
<li>可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值</li>
<li>常量属性在构造过程完成之前必须要有初始值</li>
</ol>
</li>
<li>计算属性<ol>
<li>计算一个值，用于类、结构体和枚举</li>
<li>计算属性不直接存储值，而是提供一个<code>getter</code>来获取值，一个可选的<code>setter</code>来间接设置其他属性或变量的值。如果计算属性的<code>setter</code>没有定义表示新值的参数名，则可以使用默认名称<code>newValue</code></li>
<li>只读计算属性，只有<code>getter</code>没有<code>setter</code>的计算属性，只读计算属性总是返回一个值，可以通过点(<code>.</code>)运算符访问，但不能设置新的值</li>
</ol>
</li>
</ul>
</li>
<li><p>可以定义属性观察器来监控属性的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己写的存储属性上，也可以添加到从父类继承的属性上</p>
</li>
<li><p>延迟存储属性</p>
<ul>
<li>当第一次被调用的时候才会计算其初始值的属性</li>
<li>在属性声明前使用<code>lazy</code>来标示一个延迟存储属性</li>
<li>延迟存储属性，必须声明为变量(使用<code>var</code>关键字)</li>
<li>使用场景：延迟对象的创建、当属性的值依赖于其他未知类</li>
</ul>
</li>
<li><p>属性观察器</p>
<ul>
<li><code>willSet、didSet</code></li>
<li>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器</li>
<li>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重载属性的方式为继承的属性(包括存储属性和计算属性)添加属性观察器</li>
<li><code>willSet</code>和<code>didSet</code>观察器在属性初始化过程中不会被调用</li>
</ul>
</li>
<li><p>类型属性，使用关键字<code>static</code>来定义值类型的类型属性，用关键字<code>class</code>来为类定义类型属性</p>
</li>
</ul>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul>
<li><code>swift</code>方法是与某些特定类型相关联的函数</li>
<li><p>在<code>OC</code>中，类是唯一能定义方法的类型。在<code>swift</code>中，不仅能选择是否要定义一个类/结构体/枚举，还能灵活的在创建的类型(类/结构体/枚举)上定义方法</p>
</li>
<li><p>实例方法</p>
<ul>
<li>是属于某个特定类、结构体或枚举类型实例的方法</li>
<li>可以访问和修改实例属性，提供与实例目的相关的功能</li>
<li>不能脱离于现存的实例而被调用</li>
</ul>
</li>
<li><p><code>swift</code>函数参数可以同时有一个局部名称(在函数体内部使用)和一个外部名称(在调用函数时使用)</p>
</li>
<li><p>常用规则</p>
<ul>
<li>需要参数时，函数名末尾常用一个介词(with、for、by)指向方法的第一个参数</li>
</ul>
</li>
<li><p><code>self</code>属性</p>
<ul>
<li>类型的每一个实例都有一个隐含属性叫做<code>self</code>，<code>self</code>完全等同于该实例本身</li>
<li>可以在一个实例的实例方法中使用这个隐含的<code>self</code>属性来引用当前实例</li>
</ul>
</li>
<li><p><code>swift</code>语言中结构体和枚举是值类型。一般情况下，值类型的属性不能在它的实例方法中被修改，但可以通过选择变异(关键字为<code>mutating</code>)这个方法进行值类型的修改</p>
</li>
<li><p>可变方法能够赋给隐含属性<code>self</code>一个全新的实例</p>
</li>
<li>类型方法<ul>
<li>声明结构体和枚举的类型方法，在方法的<code>func</code>关键字之前加上关键字<code>static</code></li>
<li>类可能会用关键字<code>class</code>来允许子类重写父类的实现方法</li>
</ul>
</li>
</ul>
<h5 id="下标脚本"><a href="#下标脚本" class="headerlink" title="下标脚本"></a>下标脚本</h5><ul>
<li>可以定义在类、结构体和枚举这些目标中</li>
<li>是访问对象、集合或序列的快捷方式，不需要再调用实例的特定的赋值和访问方法</li>
<li>定义下标脚本使用subscript关键字，显示声明入参和返回类型</li>
<li>下标脚本允许任意数量的入参索引，并且每个入参类型也没有限制</li>
<li>下标脚本的返回值也可以是任何类型</li>
<li>下标脚本可以使用变量参数和可变参数</li>
<li>下标脚本的重载<ul>
<li>一个类或结构体可以根据自身需要提供多个下标脚本实现，在定义下标脚本时通过传入参数的类型进行区分，使用下标脚本时会自动匹配合适的下标脚本实现运行</li>
</ul>
</li>
</ul>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul>
<li>类可以调用和访问超类的方法、属性和下标脚本，并且可以重写它们</li>
<li><p>重写属性</p>
<ul>
<li>子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。所以在重写一个属性时，必须将它的名字和类型都写出来</li>
<li>注意<ol>
<li>如果在重写属性中提供了<code>setter</code>，那么也一定要提供<code>getter</code></li>
<li>如果不想在重写版本中的<code>getter</code>里修改继承来的属性值，可以直接通过<code>super.someProperty</code>来返回继承来的值，其中<code>someProperty</code>是要重写的属性的名字</li>
<li>可以使用<code>final</code>关键字防止被重写</li>
</ol>
</li>
</ul>
</li>
<li><p>在<code>class</code>前添加<code>final</code>关键字，这样的类是不可被继承的</p>
</li>
</ul>
<h5 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h5><ul>
<li>构造过程是为了使用某个类、结构体或枚举类型的实例而进行的准备过程</li>
<li>这个过程包含了为实例中的每个属性设置初始值和为实例执行必要的准备和初始化任务</li>
<li><code>swift</code>构造函数使用<code>init()</code>方法</li>
<li>类和结构体在实例创建时，必须为所有存储型属性设置合适的初始值</li>
<li>可以在构造器中为存储属性设置初始值，同样，也可以在属性声明时为其设置默认值</li>
<li>不同参数构造器的调用，主要通过构造器中的参数名和类型来确定需要调用的构造器</li>
<li>如果在定义构造器时没有提供参数的外部名字，<code>swift</code>会为每个构造器的参数自动生成一个跟内部名字相同的外部名</li>
<li>如不希望为构造器的某个参数提供外部名字，可以使用下划线<code>&quot;_&quot;</code>来显示描述它的外部名</li>
<li><p>可选类型</p>
<ul>
<li>如定制的类型包含一个逻辑上允许取值为空的存储型属性，需要将它定义为可选类型<code>optional type</code>(可选属性类型)</li>
<li>当存储属性声明为可选时，将自动初始化为空<code>nil</code></li>
</ul>
</li>
<li><p>构造过程中修改常量属性</p>
<ul>
<li>只要在构造过程结束前常量的值能确定，可以在构造过程中的任意时间点修改常量属性的值</li>
<li>对某个类实例来说，它的常量属性只能在定义它的类的构造过程中修改，不能在子类中修改</li>
</ul>
</li>
<li><p>结构体的逐一成员构造器</p>
<ul>
<li>如果结构体对所有存储型属性提供了默认值，且自身没有提供定制的构造器，它们能自动获得一个逐一成员构造器</li>
<li>在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值</li>
</ul>
</li>
<li><p>值类型的构造器代理</p>
<ul>
<li>构造器可以通过调用其他构造器来完成实例的部分构造过程，这一过程称为构造器代理，它能减少多个构造器间的代码重复</li>
<li>构造器代理的规则<ol>
<li>值类型，不支持继承</li>
<li>类类型，可以继承自其他类</li>
</ol>
</li>
</ul>
</li>
<li><p>构造器的继承和重载</p>
<ul>
<li>子类不会默认继承父类的构造器</li>
<li>父类的构造器仅在确定和安全的情况下被继承</li>
<li>重写一个父类指定构造器时，需要写<code>override</code>修饰符</li>
</ul>
</li>
<li><p>可失败构造器</p>
<ul>
<li>如果一个类、结构体或枚举类型的对象，在构造自身的过程中有可能失败，则为其定义一个可失败构造器</li>
<li>变量初始化失败可能的原因有：<ol>
<li>传入无效的参数值</li>
<li>缺少某种所需的外部资源</li>
<li>没有满足特定条件</li>
</ol>
</li>
<li>可用一个非可失败构造器覆盖一个可失败构造器，但反过来却行不通</li>
<li>一个非可失败的构造器永远也不能代理调用一个可失败构造器</li>
<li>语法：在<code>init</code>关键字后面添加问号<code>(init?)</code></li>
</ul>
</li>
</ul>
<h5 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h5><ul>
<li>在一个类的实例被释放之前，析构函数被立即调用</li>
<li>用关键字deinit来标示析构函数</li>
<li>析构函数只适用于类型</li>
<li>在类的定义中，每个类最多只能有一个析构函数</li>
<li>释放资源<ul>
<li><code>swift</code>会自动释放不再需要的实例以释放资源</li>
<li><code>swift</code>通过自动引用计数<code>(ARC)</code>处理实例的内存管理</li>
</ul>
</li>
</ul>
<h5 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h5><ul>
<li>可选链是一种可以请求和调用属性、方法和子脚本的过程，用于请求或调用的目标可能为<code>nil</code></li>
<li><p>返回值</p>
<ul>
<li>如果目标有值，调用就会成功，返回该值</li>
<li>如果目标为<code>nil</code>，调用将返回<code>nil</code></li>
</ul>
</li>
<li><p>多次请求或调用可以被链接成一个链，如果任意一个节点为<code>nil</code>将导致整条链失效</p>
</li>
<li>通过在属性、方法或下标脚本的可选值后面放一个问号(?)，即可定义一个可选链</li>
<li>可以使用可选链来尝试从下标脚本获取值并检查下标脚本的调用是否成功，不能通过可选链来设置下标脚本</li>
</ul>
<h5 id="自动引用计数-ARC"><a href="#自动引用计数-ARC" class="headerlink" title="自动引用计数(ARC)"></a>自动引用计数<code>(ARC)</code></h5><ul>
<li><code>swift</code>使用自动引用计数<code>(ARC)</code>这一机制来跟踪和管理应用程序的内存</li>
<li>为了确保使用中的实例不会被销毁，<code>ARC</code>会跟踪和计算每一个实例正在被多少属性、常量或变量所引用</li>
<li>实例赋值给属性、常量或变量，它们都会创建此实例的强引用，只要强引用还在，实例是不允许被销毁的</li>
<li><p>解决实例之间的循环强引用</p>
<ul>
<li>弱引用<ol>
<li>对于生命周期中会变为<code>nil</code>的实例使用弱引用</li>
<li>使用<code>weak</code>关键字进行标示，通常与<code>var</code>搭配使用</li>
</ol>
</li>
<li>无主引用<ol>
<li>对于初始化赋值后再也不会被赋值为<code>nil</code>的实例，使用无主引用</li>
<li>使用<code>unowned</code>关键字进行标示，通常与<code>let</code>搭配使用</li>
</ol>
</li>
<li>弱引用和无主引用允许循环引用中的一个实例用另外一个实例而不保持强引用</li>
</ul>
</li>
<li><p>闭包引起的循环强引用</p>
<ul>
<li>会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。如闭包体中访问了实例的某个属性，或者调用了某个方法，这两种情况都导致了闭包“捕获”<code>self</code>，从而产生了循环强引用</li>
<li><p>解决闭包引起的循环强引用</p>
<ul>
<li>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用</li>
<li><p>方法：</p>
<ol>
<li>当闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用</li>
<li>当捕获引用有时可能会是<code>nil</code>时，将闭包内的捕获定义为弱引用</li>
<li>如果捕获的引用绝对不会置为<code>nil</code>，应该用无主引用</li>
<li><p>闭包中无主引用的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [unowned self] in</span><br><span class="line">  // todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul>
<li>作用<ul>
<li>可以判断实例的类型</li>
<li>可用于检测实例类型是否属于父类或者子类的实例</li>
<li>可用来检查一个类是否实现了某个协议</li>
</ul>
</li>
<li>使用 <code>is</code> 和 <code>as</code> 操作符实现<ul>
<li><code>is</code> 用于检测值的类型</li>
<li><code>as</code> 用于转换类型</li>
</ul>
</li>
<li><p>向下转型</p>
<ul>
<li>用类型转换操作符：<code>as?</code> 或 <code>as!</code></li>
<li>不确定向下转型是否成功时，用类型转换的条件形式<code>(as?)</code>。条件形式的类型转换总是返回一个可选值，若不成功，可选值将是<code>nil</code></li>
<li>确定向下转型成功时，使用强制形式(as!)。如转型不成功，会触发一个运行时错误</li>
</ul>
</li>
<li><p>不确定类型</p>
<ul>
<li><code>AnyObject</code>，代表任何<code>class</code>类型的实例</li>
<li><code>Any</code>，表示任何类型，包括方法类型</li>
</ul>
</li>
<li><p>在一个<code>switch</code>语句的<code>case</code>中使用强制形式的类型转换操作符(<code>as</code>，而不是<code>as?</code>)来检查和转换到一个明确的类型</p>
</li>
</ul>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><ul>
<li>向一个已有的类、结构体或枚举类型添加新功能</li>
<li>可以对一个类型添加新的功能，但是不能重写已有的功能</li>
<li><p>应用场景</p>
<ul>
<li>添加计算型属性和计算型静态属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>
</li>
<li><p>语法，使用关键字 <code>extension</code></p>
</li>
<li>一个扩展可以扩展一个已有类型，使其能够适配一个或多个协议</li>
<li>扩展可以向类中添加新的便利构造器<code>init()</code>，但是不能向类中添加新的指定构造器或析构函数</li>
<li>结构体和枚举类型中修改<code>self</code>或其属性的方法必须将该实例方法标注为<code>mutating</code></li>
</ul>
<h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><ul>
<li>协议规定了用来实现某一特定功能所必需的方法和属性</li>
<li>类、结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能</li>
<li>如果类在遵循协议的同时拥有父类，应该将父类名放在协议名之前，以逗号分隔</li>
<li>对属性的规定<ul>
<li>协议用于指定特定的实例属性或类属性，而不用指定是存储属性或计算属性，必须指明是只读的还是可读可写的</li>
<li>协议中通常用<code>var</code>来声明变量属性，在类型声明后加上<code>{set get}</code>来表示属性是可读可写的，只读属性则用<code>{get}</code>来表示</li>
</ul>
</li>
<li>协议可以要求它的遵循者实现指定的构造器</li>
<li>尽管协议本身并不实现任何功能，但是协议可以被当作类型来使用<ul>
<li>使用场景<ol>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ol>
</li>
</ul>
</li>
<li>扩展可以为已存在的类型添加属性、方法、下标脚本、协议等成员</li>
<li>检验协议的一致性<ul>
<li>可以使用<code>is</code>和<code>as</code>操作符来检查是否遵循某一协议或强制转化为某一类型</li>
<li><code>is</code>操作符用来检查实例是否遵循了某个协议</li>
<li><code>as?</code>返回一个可选值，当实例遵循协议时，返回该协议类型，否则返回<code>nil</code></li>
<li><code>as</code>用以强制向下转型，如果强转失败，会引起运行时错误</li>
</ul>
</li>
</ul>
<h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><ul>
<li><code>swift</code>标准库是通过泛型代码构建出来的</li>
<li><code>swift</code>的数组和字典类型都是泛型集</li>
<li>泛型使用了占位类型名(通常用字母<code>T</code>来表示)来代替实际类型名</li>
<li>函数名后面跟着占位类型名<code>(T)</code>，并用尖括号括起来<code>&lt;T&gt;</code>。尖括号告诉<code>swift</code>那个<code>T</code>是函数定义内的一个占位类型名，因此<code>swift</code>不会去查找名为<code>T</code>的实际类型</li>
<li>类型约束能够确保类型符合泛型函数或类的定义约束</li>
<li>可以在参数列表中通过<code>where</code>语句定义参数的约束</li>
</ul>
<h5 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h5><ul>
<li>访问控制可以限定其他源文件或模块中代码对你代码的访问级别</li>
<li>访问控制基于模块与源文件</li>
<li>访问级别<ul>
<li><code>public</code> - 模块级别，别人能访问、自己能访问，最高级访问级别</li>
<li><code>internal</code> - 模块级别，别人不能访问、自己能访问</li>
<li><code>fileprivate</code> - 文件级别，文件内私有，只能在当前源文件中使用</li>
<li><code>private</code> - 类级别，只能在类中访问，只在作用域内有效，离开作用域就无法访问，最低级访问级别</li>
</ul>
</li>
<li>除非有特殊说明，否则实体都使用默认的访问级别<code>internal</code></li>
<li>函数的访问级别需要根据该函数的参数类型和返回类型的访问级别得出</li>
<li>如一个类型内有不同访问级别的成员，根据元组访问级别的原则，得出该类型的访问级别<ul>
<li>元组访问级别的原则，元组的访问级别与元组中访问级别最低的类型一致</li>
</ul>
</li>
<li>枚举中成员的访问级别继承自该枚举，不能为枚举中的成员单独声明不同的访问级别</li>
<li>子类的访问级别不得高于父类的访问级别</li>
<li>常量、变量、属性不能拥有比它们的类型更高的访问级别</li>
<li>下标也不能拥有比索引类型或返回类型更高的访问级别</li>
<li>常量、变量、属性、下标索引的<code>getter</code>和<code>setter</code>的访问级别继承自它们所属成员的访问级别，<code>setter</code>的访问级别可以低于对应的<code>getter</code>的访问级别，这样就可以控制变量、属性或下标索引的读写权限</li>
</ul>
<h3 id="常见知识点总结"><a href="#常见知识点总结" class="headerlink" title="常见知识点总结"></a>常见知识点总结</h3><ul>
<li><code>swift</code>中的头文件是全局共享的</li>
<li>声明为<code>Optional</code>的变量/常量不能直接参与运算，必须解包后才能参与运算</li>
<li>可对一个可选类型使用后缀操作符<code>!</code>来强制拆包访问这个值<ul>
<li>注：使用<code>!</code>来获取一个不存在的可选值会导致<code>crash</code>，因此在使用<code>!</code>强制展开之前必须确保可选项中包含一个非<code>nil</code>的值</li>
</ul>
</li>
<li><p>可以使用可选项绑定来判断可选项是否包含值，如果包含就把值赋给一个临时常量/变量</p>
<ul>
<li>可选项绑定，将可选项赋值给一个常量，然后判断常量的值是否为<code>nil</code>来进行处理 </li>
<li>语法：<code>if let/var newValue = 待解包的可选项值 {}</code></li>
</ul>
</li>
<li><p>隐式展开可选项</p>
<ul>
<li>背景<ul>
<li>有时在一些程序结构中可选项一旦被设定值之后，就会一直拥有值。这种情况下不必每次访问的时候都进行展开，因为它可以安全的确认每次访问的时候都有一个值</li>
</ul>
</li>
<li>声明方式<ul>
<li>通过在类型后面添加一个叹号<code>(!)</code>而非问号<code>(?)</code>来声明一个隐式展开可选项</li>
</ul>
</li>
</ul>
</li>
<li><p>合并空值运算符</p>
<ul>
<li><code>??</code></li>
<li>语法：<code>a ?? b</code>，理解：如果可选项<code>a</code>有值则展开，如果没有值，是<code>nil</code>，则返回默认值<code>b</code>。表达式<code>a</code>必须是一个可选类型，表达式<code>b</code>必须与<code>a</code>的存储类型相同</li>
<li>合并空值运算符是如下代码的缩写：<code>a != nil ? a! : b</code></li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li><code>as</code><ol>
<li>向上转型，从派生类转换为基类</li>
<li>数值类型转换，消除二义性。如：<code>let num1 = 42 as CGFloat</code></li>
<li><code>switch</code>语句中进行模式匹配</li>
</ol>
</li>
<li><code>as!</code>，向下转型，是强制类型转换，如果转换失败会报<code>runtime</code>运行错误</li>
<li><code>as?</code>，向下转型，但<code>as?</code>如果转换不成功时会返回一个<code>nil</code>对象，成功时返回可选类型值<code>(Optional)</code>，需要拆包使用</li>
<li>在确保会转换成功时使用<code>as!</code>，否则使用<code>as?</code></li>
</ul>
</li>
<li><p>代码逻辑组织说明</p>
<ul>
<li><code>MARK</code><ul>
<li>有分隔线 <code>//MARK: - 说明文字</code></li>
<li>无分隔线 <code>//MARK: 说明文字</code></li>
<li>注：<code>MARK</code>要大写，<code>MARK</code>后有冒号<code>(:)</code></li>
</ul>
</li>
<li><code>TODO</code><ul>
<li>标记提醒</li>
<li>用法，<code>//TODO:需要提醒的文字</code></li>
</ul>
</li>
<li><code>FIXME</code><ul>
<li><code>bug</code>待修改提示</li>
<li>用法，<code>//FIXME:需要修改bug的相关说明</code></li>
</ul>
</li>
</ul>
</li>
<li><p>类型比较</p>
<ul>
<li><code>is</code> 判断对象的类型是否一致</li>
<li><code>===</code> 判断对象所引用的内存地址是否相同</li>
</ul>
</li>
<li>字符串<ul>
<li><code>==</code> 判断内容是否相等</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/07/Objective-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/07/Objective-C/" class="post-title-link" itemprop="url">Objective-C</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-07 22:02:55" itemprop="dateCreated datePublished" datetime="2019-03-07T22:02:55+08:00">2019-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="Objective-C-与-Cocoa"><a href="#Objective-C-与-Cocoa" class="headerlink" title="Objective-C 与 Cocoa"></a><code>Objective-C</code> 与 <code>Cocoa</code></h5><p><code>Cocoa</code>是<code>Cocoa</code>和<code>Cocoa Touch</code>的统称。<code>Cocoa</code>是使用<code>Objective-C</code>语言开发的功能强大的用户界面工具包，里面分别包含了<code>OS X</code>和<code>iOS</code>系统的所有用户界面元素和其他所有相关内容。在开发环境<code>Xcode</code>下，使用<code>Objective-C</code>操作工具包<code>Cocoa</code>来开发应用程序。苹果为开发<code>OS X</code>和<code>iOS</code>平台上的应用程序，提供了针对<code>OS X</code>系统的<code>Cocoa</code>工具包和针对<code>iOS</code>系统的<code>Cocoa Touch</code>工具包。</p>
<h5 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a><code>.m</code>文件</h5><p><code>Xcode</code>通过<code>.m</code>扩展名来表示文件使用的是<code>Objective-C</code>代码，应由<code>Objective-C</code>编译器处理，扩展名<code>.m</code>代表<code>message</code>，指的是<code>Objective-C</code>的消息传递特性。在<code>Xcode</code>中，编译工作默认由<code>LLVM</code>处理，这个编译器能够理解<code>C</code>语言的全部3个变体。<code>C</code>编译器处理<code>.c</code>文件，<code>C++</code>编译器处理<code>.cpp</code>文件。<strong>Objective-C本质上就是C语言。</strong></p>
<h5 id="import语句"><a href="#import语句" class="headerlink" title="#import语句"></a><code>#import</code>语句</h5><p><code>Objective-C</code>使用头文件来包含结构体、符号常量和函数原型等元素的声明。在<code>Objective-C</code>语言中用<code>#import</code>语句来通知编译器查询头文件中相应的定义代码。<code>#import</code>是由<code>Xcode</code>使用的编译器<code>LLVM</code>提供的。<code>#import</code>可保证头文件只被包含一次，无论此命令在该文件中出现了多少次。</p>
<p>在<code>C</code>语言中，通常使用基于<code>#ifdef</code>命令的方案来避免一个文件包含另一个文件而后者又包含前者的情况。在<code>Objective-C</code>中，使用<code>#import</code>命令来实现这个功能。</p>
<h5 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h5><p><strong>框架</strong>是一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。苹果将<code>Cocoa</code>、<code>Carbon</code>、<code>QuickTime</code>和<code>OpenGL</code>等技术作为框架集来提供。<code>Cocoa</code>的组成部分有<code>Foundation</code>和<code>Application Kit(AppKit)</code>框架。<strong><code>Foundation</code>框架处理的是用户界面之下的那些层<code>(Layer)</code>的特性，如数据结构和通信机制。</strong>每个框架都是一个重要的技术集合，通常包含数十个甚至上百个头文件。每个框架都有一个主头文件，它包含了框架内所有的头文件。通过在主头文件中使用<code>#import</code>，就可以访问框架内的所有功能。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foundation框架的头文件占用了近1MB的磁盘存储空间，Xcode使用预编</span><br><span class="line">译头文件(一种经过压缩的、摘要形式的头文件)来加快读取速度，通过</span><br><span class="line">#import导入这种文件时，加载速度会非常快。</span><br></pre></td></tr></table></figure>
<h5 id="布尔类型-BOOL"><a href="#布尔类型-BOOL" class="headerlink" title="布尔类型(BOOL)"></a>布尔类型<code>(BOOL)</code></h5><p><code>Objective-C</code>中的<code>BOOL</code>实际上是一种对带符号的字符类型<code>(signed char)</code>的类型定义<code>(typedef)</code>，它使用<code>8</code>位的存储空间。通过<code>#define</code>指令把<code>YES</code>定义为<code>1</code>，<code>NO</code>定义为<code>0</code>。<code>Objective-C</code>并不会将<code>BOOL</code>作为仅能保存<code>YES</code>或<code>NO</code>值的真正布尔类型来处理。编译器仍将<code>BOOL</code>认作<code>8</code>位二进制数，<code>YES</code>和<code>NO</code>值只是在习惯上的一种理解。这样会引发一个小问题：如果不小心将一个大于<code>1字节</code>的整型值(如<code>short</code>或<code>int</code>)赋给一个<code>BOOL</code>变量，那么只有低位字节会用作<code>BOOL</code>值。如果该低位字节刚好为<code>0</code>(如<code>8960</code>，写成十六进制为<code>0x2300</code>)，<code>BOOL</code>值将会被认作是<code>0</code>，即<code>NO</code>值。</p>
<hr>
<h5 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程<code>(OOP)</code></h5><p>面向对象编程<code>(Object-Oriented Programming)</code>，即<code>OOP</code>。<code>OOP</code>是一种编程架构，可构建由多个对象组成的软件。<code>Cocoa</code>基于<code>OOP</code>概念，<code>Objective-C</code>是面向对象的语言。</p>
<h5 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h5><p>在代码中<strong>通过指针间接获取某个值</strong>，而不是直接获取。是使用数据、实现功能的一种方式。如变量与间接，就是通过间接的方式去使用变量，避免魔鬼数字的产生；文件名与间接，就是通过文件名去查询文件内容，避免查询的内容改变时需要谨慎大量的修改代码，使用间接方式此时只需要替换文件内容，而无须修改代码。</p>
<p>间接是<code>OOP</code>的核心，<code>OOP</code>使用间接来获取数据，如使用变量、文件和参数。<code>OOP</code>真正的革命性在于它使用间接来调用代码，不是直接调用某个函数，而是间接调用，通过指针来体现。</p>
<h5 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h5><p>过程式编程建立在函数之上，数据为函数服务，而面向对象编程则以程序的数据为中心，函数为数据服务。在<code>OOP</code>中，不再重点关注程序中的函数，而是专注于数据。在<code>OOP</code>中，数据通过间接方式引用代码，代码可以对数据进行操作。</p>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a><code>id</code></h5><p><code>id</code>是一种泛型，可以用来引用任何类型的对象。对象是一种包含代码的<code>struct</code>结构体，因此<code>id</code>实际上是一个指向结构体的指针。</p>
<h5 id="方括号"><a href="#方括号" class="headerlink" title="方括号([])"></a>方括号<code>([])</code></h5><p><code>Objective-C</code>中调用方法时方括号的功能：用于通知某个对象该去做什么，方括号里的第一项是对象，其余部分是需要对象执行的操作。<code>Objective-C</code>中通知对象执行某种操作称为发送消息(亦称调用方法)。向对象发送消息后，如何调用所需的代码，需要叫做类的幕后帮手来协助完成。对象含有一个指向其类的指针(类是一种能够实例化成对象的结构体)。类含有一个指针指向类所能实现功能的代码(方法列表)。</p>
<p>发送消息过程中如何调用对象中适当函数的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对象是消息的目标，查询消息的目标对象属于哪个类。</span><br><span class="line">2.在类中查找其代码块，获取函数的地址。</span><br><span class="line">3.执行函数。</span><br></pre></td></tr></table></figure>
<p>方法调用过程中体现了间接操作的使用，该过程中最终确定调用的函数和实现的功能，由<code>Objective-C</code>在幕后(运行时)决定，它(运行时)将查询对象属于哪个类。类对象的优势：如果在运行时改变某个类，则该类的所有对象会自动继承这些变化。</p>
<h5 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">类：是一种表示对象类型的结构体。</span><br><span class="line">对象：是一种包含值和指向其类的隐藏指针的结构体，它能够通过函数指针查找与之相关的代码。</span><br><span class="line">消息：是对象可以执行的操作，用于通知对象去做什么。对象接收消息后，将查询相应的类，以便找到正确的代码来运行。 </span><br><span class="line">方法：是为响应消息而运行的代码。</span><br><span class="line">方法调度：是Objective-C使用的一种机制(方法调度机制)，用于推测执行什么方法以响应某个特定的消息。</span><br><span class="line">接口：是类为对象提供的特性描述。(接口不提供实现代码的细节信息)</span><br><span class="line">实现：是使接口能正常工作的代码。</span><br><span class="line"></span><br><span class="line">实例变量：由于对象的局部变量只在对象的实例中有效，因此称它们为实例变量，通常简写为ivar。</span><br></pre></td></tr></table></figure>
<h5 id="interface和-implementation"><a href="#interface和-implementation" class="headerlink" title="@interface和@implementation"></a><code>@interface</code>和<code>@implementation</code></h5><p><code>@interface</code>和<code>@implementation</code>都是编译器指令。</p>
<p>创建某个特定类的对象之前，<code>Objective-C</code>编译器需要一些有关该类的信息，尤其是对象的数据成员(即对象的<code>C</code>语言类型结构体应该是什么样子)及其提供的功能，使用<code>@interface</code>指令把这些信息传递给编译器。</p>
<p><code>@implementation</code>表明将为某个类提供代码，实现在<code>@interface</code>文件中所声明的方法的定义。也可以定义在<code>@interface</code>文件中没声明过的方法，此时该方法为仅能在当前类中所使用的私有方法。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objective-C中不存在真正的私有方法，也无法把某个方法标识为私有方法，从而禁止其他代码调用它。这是Objective-C动态本质的副作用。</span><br></pre></td></tr></table></figure>
<h5 id="self"><a href="#self" class="headerlink" title="self"></a><code>self</code></h5><p>在<code>Objective-C</code>中调用方法时，一个名为<code>self</code>的秘密隐藏参数将被传递给接收对象，而这个参数引用的就是该接收对象(对象自身)。使用self参数后，方法可以查找并操作对象的数据。方法的实现和对象数据的模板是由对象的类定义的。<code>self</code>的传递过程是秘密和自动的。<code>Objective-C</code>运行时<code>(runtime)</code>可以将不同的对象当成隐藏的<code>self</code>参数传递，所以那些对象的实例变量发生更改时，运行时也可进行相应的更改。</p>
<h5 id="建立类之间的关系"><a href="#建立类之间的关系" class="headerlink" title="建立类之间的关系"></a>建立类之间的关系</h5><p>建立类之间的关系有：继承、复合。</p>
<p>继承是在两个类之间建立关系的一种方式，它可以避免许多重复的代码。</p>
<p>使用复合可组合多个对象，让它们分工协作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">继承的类之间建立的关系为“is a”(是一个)，如果可以说“X是一个Y”，那就可以使用继承。</span><br><span class="line">复合的类之间建立的关系为“has a”(有一个)，如果可以说“X有一个Y”，那就可以使用复合。</span><br></pre></td></tr></table></figure>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>某些编程语言(如<code>C++</code>)具有多继承，也就是一个类可以直接从两个或多个类继承而来。<strong>但<code>Objective-C</code>不支持多继承。</strong>在<code>Objective-C</code>中可以通过类别<code>(category)</code>和协议<code>(protocol)</code>来达到多继承的效果。</p>
<p>如果想改变方法的实现，需要重写<code>(override)</code>继承的方法。代码运行时，<code>Objective-C</code>会确保调用的是重写过的方法。</p>
<p>基于继承，可以实现多态性。多态性：使用更具体种类的对象来代替一般类型，这种能力被称为多态性。</p>
<p>继承可以让我们在需要超类的地方使用子类。</p>
<p>与实例方法一样，继承对类方法也同样适用。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重写方法时，调用超类方法总是一个明智之举，这样可以实现更多的功能，调用继承的方法可以确保获得方法实现的所有特性。</span><br></pre></td></tr></table></figure>
<h5 id="方法调度"><a href="#方法调度" class="headerlink" title="方法调度"></a>方法调度</h5><p>当代码发送消息时，<code>Objective-C</code>的方法调度机制将在当前的类中搜索相应的方法。如果无法在接收消息的对象的类文件中找到相应的方法，它就会在该对象的超类中进行查找。必要时它将会在继承链的每一个类中重复地执行上述操作。如果在最顶层的<code>NSObject</code>类中也没有找到该方法，则会出现一个运行时错误，同时还会出现一个编译时<code>(compile-time)</code>警告信息。</p>
<h5 id="实例变量和isa"><a href="#实例变量和isa" class="headerlink" title="实例变量和isa"></a>实例变量和<code>isa</code></h5><p>在创建一个新类时，，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。</p>
<p><code>NSObject</code>类声明了一个名为<code>isa</code>的实例变量，该变量保存一个指向对象当前类的指针。因为继承在子类和超类之间建立了一种<code>“is a”</code>(是一个)的关系，所以<code>NSObject</code>的实例变量叫做<code>isa</code>。</p>
<p>每个方法调用都获得了一个名为<code>self</code>的隐藏参数，它是一个指向接收消息的对象的指针。这些方法通过<code>self</code>参数来寻找它们需要用到的实例变量。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编译器使用“基地址加偏移”的机制实现奇妙的功能。有了对象基地址，即第</span><br><span class="line">一个实例变量的首个字节在内存中的位置，再在该地址上加上偏移地址，编</span><br><span class="line">译器就可以查找其他实例变量的位置。</span><br></pre></td></tr></table></figure>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a><code>super</code></h5><p>为了调用继承的方法在父类中的实现，需要使用<code>super</code>作为方法调用的目标。<code>super</code>既不是参数也不是实例变量，而是由<code>Objective-C</code>编译器提供的一种功能。当向<code>super</code>发送消息时，实际上是在请求<code>Objective-C</code>向该类的超类发送消息。如果超类中没有定义该消息，<code>Objective-C</code>会继续在继承链上一级中查找。</p>
<h5 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h5><p>在<code>Objective-C</code>中，复合是通过包含作为实例变量的对象指针实现的。只有对象间的组合才能叫做复合。</p>
<h5 id="new"><a href="#new" class="headerlink" title="new"></a><code>new</code></h5><p>使用<code>new</code>创建新对象时，系统其实在后台执行了两个步骤：第一步，为对象分配内存，即对象获得一个用来存放实例变量的内存块；第二步，自动调用<code>init</code>方法，使该对象进入可用状态。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了让超类将所有需要的初始化工作一次性完成，需要调用[super init]。init方法返回的值就是被初始化的对象。将[super init]返回的结果赋给self是Objective-C的惯例。这么做是为了防止超类在初始化过程中返回的对象与一开始创建的不一致。</span><br></pre></td></tr></table></figure>
<h5 id="存取方法：setter和getter"><a href="#存取方法：setter和getter" class="headerlink" title="存取方法：setter和getter"></a>存取方法：<code>setter</code>和<code>getter</code></h5><p>存取方法<code>(accessor)</code>是用来读取或改变某个对象属性的方法。<code>setter</code>方法为对象中的变量赋值；<code>getter</code>方法为代码提供了通过对象自身访问对象属性的方式。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果要对对象中的属性进行操作，应该尽量使用对象提供的存取方法，绝对不能直接改变对象里面的值。直接改变对象里面属性值的操作语法：对象-&gt;对象属性值。</span><br></pre></td></tr></table></figure>
<p>对于存取方法，<code>Cocoa</code>有自己的命名惯例。<code>setter</code>方法根据它所更改的属性的名称来命名，并加上前缀<code>set</code>，如：<code>setFont:</code>。<code>getter</code>方法则是以其返回的属性名称命名，如：<code>font</code>。</p>
<p>在<code>Objective-C</code>中所有对象间的交互都是通过指针实现的。</p>
<hr>
<h5 id="源代码结构"><a href="#源代码结构" class="headerlink" title="源代码结构"></a>源代码结构</h5><p><code>Objective-C</code>类的源代码分为，接口和实现两部分。</p>
<p>类的<code>@interface</code>指令、公共<code>struct</code>定义、<code>enum</code>变量、<code>#defines</code>和<code>extern</code>全局变量等存放在接口部分的文件中(<code>.h</code>文件，即头文件)。</p>
<p>类的<code>@implementation</code>指令、全局变量的定义、私有<code>struct</code>等类的实现内容都放在实现文件中(<code>.m</code>文件，实现文件)。</p>
<p>导入头文件有两种方法：使用引号或者尖括号。带尖括号的语句用于导入系统头文件，而带引号的语句则说明导入的是项目本地的头文件。系统头文件对于项目来说是只读的；可对项目头文件进行编辑。</p>
<p>类的使用者可以通过<code>#import</code>命令导入头文件来获得该类的功能。</p>
<h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>导入头文件使头文件和源文件之间建立了紧密的依赖关系。如果头文件有任何变化，那么所有依赖它的文件都得重新编译。这会在需要编译的文件中引发一连串的变化。文件导入(依赖关系)过于混乱会延长编译时间，也会导致不必要的重复编译，巧妙地使用<code>@class</code>指令，可以减少必须导入的头文件的数量，从而可以缩短编译时间。</p>
<p>导致依赖关系问题的原因是<code>Objective-C</code>编译器需要某些信息才能够工作。有时编译器需要知道类的全部信息，例如类的实例变量配置、类所继承的所有类等，而有的时候，编译器只需要知道类名即可，不需要了解整个类的定义。</p>
<hr>
<h5 id="Xcode操作"><a href="#Xcode操作" class="headerlink" title="Xcode操作"></a><code>Xcode</code>操作</h5><p>常用快捷键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">导航器面板：Command + 1~7切换视图。</span><br><span class="line">导航器面板的显隐：Command + 0。</span><br><span class="line">代码缩进处理：选中文本 + Control + I。</span><br><span class="line">左右移动代码：Command + ]右移代码；Command + [左移代码。</span><br><span class="line">缩进设置：Xcode -&gt; Preferences -&gt; Text Editing -&gt; Indentation。</span><br><span class="line">自动补全列表的操作：显隐：esc；翻页：Control + .向后翻页，Shift + Control + .向前翻页。</span><br><span class="line">方法占位符的选择：按tab键。</span><br><span class="line">替换项目中指定的类名：选中指定类，右键 -&gt; Refactor -&gt; Rename。</span><br><span class="line">快速打开某个文件：Command + Shift + O。</span><br><span class="line">辅助窗口：option + command + return (用于显示一个类的两个文件&lt;头文件.h和实现文件.m&gt;)。</span><br><span class="line">折叠代码的操作可看：Editor -&gt; Code Folding。</span><br><span class="line">查看类的说明文档：option + 在类上轻点鼠标。</span><br><span class="line">可通过快速帮助查看类信息：检查器的第二个选项即是该功能，切换光标指向即可改变快速帮助的内容。</span><br><span class="line">查看类的结构：Control + 6。</span><br></pre></td></tr></table></figure>
<p>调试快捷键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">激活/禁用断点：Command + Y。</span><br><span class="line">继续运行：Command + Control + Y。</span><br><span class="line">跳过：F6。</span><br><span class="line">跳入：F7。</span><br><span class="line">跳出：F8。</span><br></pre></td></tr></table></figure>
<p>操作光标的快捷键：</p>
<p><strong>不局限于在<code>Xcode</code>上使用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Control-F：光标前移(Forward)。</span><br><span class="line">Control-B：光标后退(Backward)。</span><br><span class="line">Control-P：光标移动到上一行(Previous)。</span><br><span class="line">Control-N：光标移动到下一行(Next)。</span><br><span class="line">Control-A：光标移动到行首位置。</span><br><span class="line">Control-E：光标移动到行尾位置(End)。</span><br><span class="line">Control-T：交换光标两边的字符(Transpose)。</span><br><span class="line">Control-D：删除光标右边的字符(Delete)。</span><br><span class="line">Control-K：将当前行光标以后的所有字符全部删除(Kill)。</span><br><span class="line">Control-L：将光标置于窗口正中央。</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a><code>Foundation</code></h5><p><code>Foundation</code>框架是以另一个框架<code>CoreFoundation</code>为基础创建的。<code>CoreFoundation</code>框架是用纯C语言写的。</p>
<h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><p><code>Objective-C</code>运行时生成一个类的时候，会创建一个代表该类的类对象<code>(class object)</code>。类对象包含了指向超类、类名和类方法列表的指针，还包含一个<code>long</code>类型的数据，为新创建的实例对象指定大小(以字节为单位)。如果在声明方法时添加了加号<code>(+)</code>，就是把这个方法定义为类方法<code>(class method)</code>。这个方法属于类对象(而不是类的实例对象)，通常用于创建新的实例。称这种用来创建新对象的类方法为工厂方法<code>(factory method)</code>。</p>
<p>通常所创建的大部分方法都是实例方法，用减号<code>(-)</code>作为前缀来进行声明。</p>
<h5 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a><code>NSArray</code></h5><p><code>NSArray</code>类的两个限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.它只能存储Objective-C对象，而不能存储原始的C语言基础数据类型，</span><br><span class="line">如int、float enum struct NSArray中的随机指针。</span><br><span class="line">2.不能在NSArray中存储nil。因为在数组列表结尾添加nil代表列表结</span><br><span class="line">束，这就是不能在数组中存储nil的原因一个原因。另一个原因是在数组通</span><br><span class="line">过枚举器来遍历数组元素时，是通过nextObject返回的值是否为nil值，</span><br><span class="line">来判断循环是否结束。</span><br></pre></td></tr></table></figure>
<p><code>NSArray</code>中的对象是从零开始编制索引的，这与<code>C</code>数组的规范一样。删除对象之后，数组中并没有留下漏洞，位于被删除对象后面的数组元素都被前移来填补空缺了。</p>
<p>遍历数组的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.通过索引；</span><br><span class="line">2.使用NSEnumerator(枚举器)；</span><br><span class="line">3.使用快速枚举(for in语法)；</span><br><span class="line">4.代码块方法(block，通过代码块可以让循环操作并发执行)。</span><br></pre></td></tr></table></figure>
<p>上述方法的使用场景：通常使用快速枚举或代码块，因为它们简洁快速。在需要通过索引访问数组时使用索引访问。枚举器在<code>Objective-C 2.0</code>中，会自动将枚举器的循环转换成快速枚举。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言将字符串作为简单的字符数组进行处理，并且在数组最后添加尾部的零字节作为结束标志。</span><br></pre></td></tr></table></figure>
<h5 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a><code>NSValue</code></h5><p><code>NSNumber</code>实际上是<code>NSValue</code>的子类，<code>NSValue</code>可以封装任意值。<br><code>valueWithBytes: objCType:</code><br>传递的参数是要封装的数值的地址(使用操作符<code>&amp;</code>)。可提供一个用来描述这个数据类型的字符串(通常用来说明数值的类型和大小)，不用自己写代码来生成这个字符串，<code>@encode</code>编译器指令可以接收数据类型的名称并生成合适的字符串(<code>@encode</code>指令，它用于需要描述C语言基础类型的方法)。<br>可以使用<code>NSValue</code>将任意值放入<code>NSArray</code>或<code>NSDictionary</code>中。</p>
<h5 id="NSNull"><a href="#NSNull" class="headerlink" title="NSNull"></a><code>NSNull</code></h5><p><code>[NSNull null]</code>总是返回一样的数值，因此可以使用运算符<code>==</code>将该值与其他值进行比较。</p>
<hr>
<h5 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h5><p>对象的生命周期包括诞生(通过<code>alloc</code>或<code>new</code>方法实现)、生存(接收消息并执行操作)、交友(通过复合以及向方法传递参数)以及最终死去(被释放掉)。当生命周期结束时，它们的原材料(内存)将被回收以供新的对象使用。</p>
<p><strong>引用计数</strong>，是一种用来判断管理对象生命周期是否结束的技术。每个对象都有一个与之相关联的整数，被称作对象的引用计数器。当某段代码需要访问一个对象时，该代码就将该对象的引用计数器值加<code>1</code>。当这段代码结束对象访问时，将对象的引用计数器减<code>1</code>，表示它不再访问该对象。当引用计数器的值为<code>0</code>时，表示不再有代码访问该对象了，因此它将被销毁，其占用的内存被系统回收以便重用。</p>
<p>当使用<code>alloc</code>、<code>new</code>方法或者通过<code>copy</code>消息创建一个对象时，对象的引用计数器值被设置为<code>1</code>。要增加对象的引用计数器的值，可以给对象发送一条<code>retain</code>消息。要减少引用计数器的值的话，可以给对象发送一条<code>release</code>消息。</p>
<p>当一个对象因其引用计数器归<code>0</code>而即将被销毁时，<code>Objective-C</code>会自动向对象发送一条<code>dealloc</code>消息。可在对象中重写<code>dealloc</code>方法，这样就能释放掉已经分配的全部相关资源。一定不要直接调用<code>dealloc</code>方法，<code>Objective-C</code>会在需要销毁对象时自动调用它。</p>
<h5 id="对象所有权"><a href="#对象所有权" class="headerlink" title="对象所有权"></a>对象所有权</h5><p>如果一个对象内有指向其他对象的实例变量，则称该对象拥有这些对象。如果一个函数创建了一个对象，则称该函数拥有这个对象。</p>
<h5 id="访问方法中的保留和释放"><a href="#访问方法中的保留和释放" class="headerlink" title="访问方法中的保留和释放"></a>访问方法中的保留和释放</h5><p>在访问方法中，先保留新对象，然后再释放对象就不会出现问题了。针对操作的对象是同一个对象的时候，尤其要如上述流程编写代码。</p>
<h5 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h5><p>自动释放池，是一个用来存放对象的池子(集合)，并且能够自动释放。</p>
<p><code>NSObject</code>类提供了一个叫做<code>autorelease</code>的方法：<code>- (id) autorelease;</code>。该方法预先设定了一条会在未来某个时间发送的<code>release</code>消息，其返回值是接收这条消息的对象。当给一个对象发送<code>autorelease</code>消息时，实际上是将该对象添加到了自动释放池中。当自动释放池被销毁时，会向该池中的所有对象发送<code>release</code>消息。</p>
<p>自动释放池以栈的形式实现：当你创建了一个新的自动释放池时，它就被添加到栈顶。接收<code>autorelease</code>消息的对象将被放入最顶端的自动释放池中。<strong>如果将一个对象放入一个自动释放池中，然后创建一个新的自动释放池，再销毁该新建的自动释放池，则这个自动释放池对象仍将存在，因为容纳该对象的自动释放池仍然存在。</strong></p>
<p>Tips:</p>
<p>手动实现自动释放池的参考思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以使用NSMutableArray来编写自己的自动释放池，以容纳对象并在dealloc方法中向池中的所有对象发送release消息。</span><br></pre></td></tr></table></figure>
<p>当对象接收到一条<code>autorelease</code>消息时，其引用计数器的值并不会发生改变。</p>
<h5 id="自动释放池的销毁时间"><a href="#自动释放池的销毁时间" class="headerlink" title="自动释放池的销毁时间"></a>自动释放池的销毁时间</h5><p>有两种方法可以创建一个自动释放池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.通过@autoreleasepool关键字。</span><br><span class="line">2.通过NSAutoreleasePool对象。</span><br></pre></td></tr></table></figure>
<p>在<code>Foundation</code>库工具集中，创建和销毁自动释放池已经由<code>@autorelease</code>关键字完成。</p>
<p>当使用<code>@autorelease{}</code>时，所有在花括号里的代码都会被放入这个新池子里。这种情况下，任何在花括号里定义的变量在括号外就无法使用了。</p>
<p>第二种方法是使用<code>NSAutoreleasePool</code>对象。使用这种方法，创建和释放<code>NSAutoreleasePool</code>对象之间的代码就会使用这个新池子。创建了一个自动释放池后，该池就会自动成为活动的池子。释放该池后，其引用计数器的值归<code>0</code>，然后该池被销毁。在销毁的过程中，该池将释放其包含的所有对象。</p>
<p>销毁自动释放池中对象的方式：<code>-drain</code>：该方法只是清空自动释放池而不会销毁自动释放池。自己编写的代码中，使用<code>-release</code>方法，以兼容更古老的版本。</p>
<p>对同一对象而言，其销毁的过程中，在收到<code>release</code>消息将其引用计数器的值减少为<code>0</code>时，其<code>dealloc</code>方法被调用。</p>
<h5 id="Cocoa的内存管理规则"><a href="#Cocoa的内存管理规则" class="headerlink" title="Cocoa的内存管理规则"></a><code>Cocoa</code>的内存管理规则</h5><blockquote>
<p>1.当使用<code>new</code>、<code>alloc</code>或<code>copy</code>方法创建一个对象时，该对象的引用计数器的值为<code>1</code>。当不再使用该对象时，应该向该对象发送一条<code>release</code>或<code>autorelease</code>消息。这样，该对象将在其使用寿命结束时被销毁。</p>
<p>2.当通过其他方法获得一个对象时，假设该对象的引用计数器的值为<code>1</code>，而且已经被设置为自动释放，那么不需要执行任何操作来确保该对象得到清理。如果打算在一段时间内拥有该对象，则需要保留它并确保在操作完成时释放它。</p>
<p>3.如果保留了某个对象，就需要释放或自动释放该对象。必须保持<code>retain</code>方法和<code>release</code>方法的使用次数相等。</p>
</blockquote>
<p>无论什么时候拥有一个对象，有两件事必须弄清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">怎样获得该对象的？</span><br><span class="line">打算拥有多长时间？</span><br></pre></td></tr></table></figure>
<p>内存管理规则：</p>
<table>
<thead>
<tr>
<th>获得途径</th>
<th>临时对象</th>
<th>拥有对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc/new/copy</td>
<td>不再使用时释放对象</td>
<td>在dealloc方法中释放对象</td>
</tr>
<tr>
<td>其他方法</td>
<td>不需要执行任何操作</td>
<td>获得对象时保留，在dealloc方法中释放对象</td>
</tr>
</tbody>
</table>
<h5 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h5><p>一个典型的图形应用程序往往花费许多时间等待用户操作。在控制程序运行的用户作出决定(如按下某个键)以前，程序将一直处于空闲状态。当发生如按下某个键的事件时，程序将被唤醒并开始工作，执行必要的操作以响应这一事件。在处理完这一事件后，程序返回到休眠状态并等待下一个事件发生。上述过程即为事件循环。(底层是通过<code>do-while</code>控制的)。</p>
<p><strong>为了降低程序的内存空间占用，<code>Cocoa</code>会在程序开始处理事件之前创建一个自动释放池，并在事件处理结束后销毁。这样可以尽量减少累积的临时对象的数量。</strong></p>
<p>如果使用除<code>alloc</code>、<code>new</code>或<code>copy</code>以外的方法获得了一个对象，需要记得保留该对象。如果编写的是<code>GUI</code>应用程序，要考虑到事件循环。需要保留自动释放的对象，以便这些对象在当前的事件循环结束以后仍能继续存在。在这种情况下，需要在执行保留操作的对象中的<code>dealloc</code>方法中释放它，以便它被清理掉。</p>
<p>自动释放池被清理的时间是完全确定的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要么是在代码中程序员自己手动销毁；</span><br><span class="line">要么是使用AppKit时在事件循环结束时销毁。(在调用函数的过程中自动释放池不会被销毁)</span><br></pre></td></tr></table></figure>
<h5 id="内存管理机制的实现"><a href="#内存管理机制的实现" class="headerlink" title="内存管理机制的实现"></a>内存管理机制的实现</h5><blockquote>
<p>垃圾回收，针对<code>OS X</code>应用程序。</p>
<p>自动引用计数<code>(ARC)</code>，针对<code>iOS</code>应用程序。</p>
</blockquote>
<p><strong>垃圾回收和<code>ARC</code>是无法一同使用的。</strong></p>
<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p><code>Objective-C 2.0</code>引入了自动内存管理机制，也称垃圾回收。启用垃圾回收以后，平常的内存管理命令全都变成了空操作指令。垃圾回收器定期检查变量和对象并且跟踪它们之间的指针，当发现没有任何变量指向某个对象时，就将该对象视为应该丢弃的垃圾。与自动释放池一样，垃圾回收器也是在事件循环结束时触发的。<strong>垃圾回收功能只支持OS X应用开发，无法用在iOS应用程序上。</strong>垃圾回收器在运行时工作，通过返回的代码来定期检查对象。</p>
<p>在支持垃圾回收的<code>Objective-C</code>中，<code>dealloc</code>方法无效，如果需要在销毁对象时执行某些操作，则需要重写<code>-finalize</code>方法，当对象最终被回收时该方法会被调用。</p>
<h5 id="自动引用计数-ARC"><a href="#自动引用计数-ARC" class="headerlink" title="自动引用计数(ARC)"></a>自动引用计数<code>(ARC)</code></h5><p>在<code>iOS</code>中无法使用垃圾回收，主要原因是无法知道垃圾回收器什么时候会起作用。垃圾回收机制会对移动设备的可用性产生不利的影响，因为移动设备比电脑更私人化，资源更少。用户可不想在打电话的时候因为系统突然进行内存清理而卡住。</p>
<p>实现与垃圾回收功能相同的移动端解决方案为<strong>自动引用计数<code>(automatic reference counting，ARC)</code>。</strong><code>ARC</code>会追踪你的对象并决定哪一个仍会使用，而哪一个不会再用到。如果启用了<code>ARC</code>，编译器会帮你插入<code>retain</code>和<code>release</code>语句。</p>
<p><code>ARC</code>不是垃圾回收器，垃圾回收器在运行时工作，通过返回的代码来定期检查对象。<code>ARC</code>是在编译时进行工作的，<code>ARC</code>在代码中插入了合适的<code>retain</code>和<code>release</code>语句，完成了内存管理的工作。</p>
<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ARC只对可保留的对象指针(ROPs)有效。可保留的对象指针主要有以下三种：</span><br><span class="line">1.代码块指针</span><br><span class="line">2.Objective-C对象指针</span><br><span class="line">3.通过__attribute__((NSObject))类型定义的指针</span><br><span class="line"></span><br><span class="line">所有其他的指针类型，如char *和CF对象(如CFStringRef)都不支持ARC</span><br><span class="line">特性。如果使用的指针不支持ARC，那么将不得不亲自手动管理它们。ARC</span><br><span class="line">可以与手动的内存管理共同发挥作用。</span><br></pre></td></tr></table></figure>
<p>使用<code>ARC</code>的时候有两种命名规则需要注意：</p>
<blockquote>
<p>1.属性名称不能以<code>new</code>开头。</p>
<p>2.属性不能只有一个<code>read-only</code>而没有内存管理特性。默认的特性是<code>assign</code>(<code>assign</code>只是基础类型的赋值描述)，进行简单的修复，使用<code>unsafe_unretained</code>(<code>unsafe_unretained</code>有对象所用权的描述特性)就可以了。</p>
</blockquote>
<p><strong><code>ARC</code>转换是一个单程的操作，一旦转换成<code>ARC</code>版本，就不可以恢复了。</strong></p>
<p><code>ARC</code>是基于文件进行工作的。</p>
<h5 id="ARC-内存泄漏"><a href="#ARC-内存泄漏" class="headerlink" title="ARC-内存泄漏"></a><code>ARC</code>-内存泄漏</h5><p>程序无法访问到对象，但它们仍占用着内存容量。循环引用场景下会出现内存泄漏的情况。</p>
<h5 id="ARC-归零弱引用"><a href="#ARC-归零弱引用" class="headerlink" title="ARC-归零弱引用"></a><code>ARC</code>-归零弱引用</h5><p>归零弱引用<code>(zeroing weak reference)</code>，不会使所引用的对象的引用计数器的值增加，同时在所引用的对象被释放时，归零弱引用就会被设置为<code>nil</code>。</p>
<p>如果想要使用归零弱引用，必须明确地声明它们。有两种方式可以声明归零弱引用：</p>
<blockquote>
<p>1.声明变量时使用<code>__weak</code>关键字。</p>
<p>2.对属性使用<code>weak</code>特性。</p>
</blockquote>
<p>想在不支持弱引用的旧系统上使用<code>ARC</code>，使用<code>__unsafe_unretained</code>关键字和<code>unsafe_unretained</code>特性，这样<code>ARC</code>便知道这个特殊的引用是弱引用。</p>
<p><strong>注意：内存管理的关键字和特性是不能一起使用的，两者相互排斥。</strong></p>
<h5 id="ARC-拥有者权限"><a href="#ARC-拥有者权限" class="headerlink" title="ARC-拥有者权限"></a><code>ARC</code>-拥有者权限</h5><p>指针支持<code>ARC</code>的一个条件是必须是可保留对象指针<code>(ROP)</code>。即不能简单地将一个<code>ROP</code>表示成不可保留对象指针<code>(non-ROP)</code>，因为指针的所有权会移交。在可保留对象指针<code>(ROP)</code>和不可保留对象指针<code>(non-ROP)</code>共同存在且相互有“交流”的情况下，为了让<code>ARC</code>便于工作，需要告诉编译器哪个对象是指针的拥有者。为此使用桥接转换<code>(bridged cast)</code>的<code>C</code>语言技术，这是一个标准的<code>C</code>语言类型转换，使用关键字：<code>__bridge</code>、<code>__bridge_retained</code>和<code>__bridge_transfer</code>。<code>bridge</code>指的是使用<strong>不同的数据类型</strong>达到<strong>同一目的</strong>的能力。</p>
<p>桥接转换类型：<code>__bridge</code>、<code>__bridge_retained</code>和<code>__bridge_transfer</code>的功能如下：</p>
<blockquote>
<p><code>(__bridge类型)</code>操作符：这种类型的转换会传递指针但不会传递指针的所有权。</p>
<p><code>(__bridge_retained类型)</code>操作符：使用这种类型，所有权会转移到<code>non-ROP</code>上。这个转换类型会给对象的引用计数器的值加<code>1</code>，所以在代码中要让它减<code>1</code>。因为<code>ARC</code>只会注意到<code>ROP</code>，所以要在不用的时候释放它。</p>
<p><code>(__bridge_transfer类型)</code>操作符：这种转换类型与上一个相反，它把所有权转交给<code>ROP</code>。</p>
</blockquote>
<p>桥接技术的使用场景：</p>
<p>结构体<code>(struct)</code>和集合体<code>(union)</code>不能使用ROP作为成员，因此下面的代码是不被允许的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Bad code.</span><br><span class="line">struct &#123;</span><br><span class="line">	int32_t foo;</span><br><span class="line">	char *bar;</span><br><span class="line">	NSString *baz; //ROP成员</span><br><span class="line">&#125; MyStruct;</span><br></pre></td></tr></table></figure>
<p>可以通过使用void *和桥接转换来解决这个问题。如想要分配并获取字符串，可使用如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">	int32_t foo;</span><br><span class="line">	char *bar;</span><br><span class="line">	void *baz;</span><br><span class="line">&#125; MyStruct;</span><br><span class="line">MyStruct.baz = (__bridge_retained void *)ropString;</span><br><span class="line">NSString *myString = (__bridge_transfer NSString *)MyStruct.baz;</span><br></pre></td></tr></table></figure>
<p>不能对<code>ARC</code>管理的对象<strong>调用</strong>的管理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">retain</span><br><span class="line">retainCount</span><br><span class="line">release</span><br><span class="line">autorelease</span><br><span class="line">dealloc</span><br></pre></td></tr></table></figure>
<p>可以重写<code>dealloc</code>方法，因为有时需要释放不支持<code>ARC</code>的对象或执行其他清理操作，但是不能直接调用<code>[super dealloc]</code>。</p>
<p>不能对<code>ARC</code>对象进行<strong>重写</strong>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retain</span><br><span class="line">retainCount</span><br><span class="line">release</span><br><span class="line">autorelease</span><br></pre></td></tr></table></figure>
<h5 id="与异常有关的关键字"><a href="#与异常有关的关键字" class="headerlink" title="与异常有关的关键字"></a>与异常有关的关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@try：定义用来测试的代码块以决定是否要抛出异常。</span><br><span class="line">@catch：定义用来处理已抛出异常的代码块。接收一个参数，通常是NSException类型。</span><br><span class="line">@finally：定义无论是否有抛出异常都会执行的代码块，这段代码总是会执行的。</span><br><span class="line">@throw：抛出异常。</span><br></pre></td></tr></table></figure>
<p>注：与当前<code>@catch</code>异常处理代码相关的<code>@finally</code>代码块会在<code>@throw</code>引发下一个异常处理调用之前执行代码，因为<code>@finally</code>是在<code>@throw</code>发生之前调用的。</p>
<h5 id="对象的分配和初始化"><a href="#对象的分配和初始化" class="headerlink" title="对象的分配和初始化"></a>对象的分配和初始化</h5><p>在<code>Cocoa</code>中，分配和初始化是两个分离的操作：来自<code>NSObject</code>的类方法<code>alloc</code>为对象分配一块内存区域并将其清零，实例方法<code>init</code>用于获得一个对象并使其运行。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><code>@property</code>是一种新的编译器功能，它意味着声明了一个对象的新属性。<code>@property</code>预编译指令的作用是自动声明属性的<code>setter</code>和<code>getter</code>方法。通常属性的名称与实例变量的名称相同。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synthesize是一种编译器功能，它表示“创建了该属性的访问代码”。访问代码指setter、getter方法。当遇到@synthesize代码时，编译器将添加实现对应的setter和getter方法的预编译代码。Xcode4.5以后的版本不必使用@synthesize了。</span><br><span class="line"></span><br><span class="line">@synthesize预编译指令实现的setter和getter代码是看不到的，但是这些方法确实存在并可以被调用。</span><br></pre></td></tr></table></figure>
<p>所有的属性都是基于变量的，所以在合成<code>(synthesize)`</code>getter<code>和</code>setter`方法的时候，编译器会自动创建与属性名称相同的实例变量。如果没有声明这些变量，编译器也会声明的。有两个地方可以用来添加实例变量声明：头文件和实现文件。如果想要其他对象访问到实例变量，则声明在头文件中，反之声明在实现文件中。</p>
<p>点表达式<code>(.)</code>只是调用访问方法的一种便捷方式。</p>
<h5 id="属性特性的使用规则"><a href="#属性特性的使用规则" class="headerlink" title="属性特性的使用规则"></a>属性特性的使用规则</h5><p>属性的特性(<code>copy</code>、<code>retain</code>等)，表明属性会具有怎样的行为。</p>
<p><code>nonatomic</code>声明，如果不在多线程中使用，这个声明可以提高访问方法的调用速度。</p>
<p>如果没有为属性指定任何特性，它们会默认使用<code>nonatomic</code>和<code>assign</code>。可以为可保留的指针(即<code>Objective-C</code>对象)指定<code>retain</code>和<code>copy</code>特性，而其他<code>C</code>类型和不可保留的指针必须使用<code>assign</code>特性并且要手动来管理内存。属性默认是可读写的。</p>
<p>如果自己定义了<code>setter</code>或<code>getter</code>方法，那么就不能使用<code>atomic</code>特性了，必须使用<code>nonatomic</code>特性。</p>
<p>在使用属性的过程中，如果不想要编译器为你创建变量、<code>getter</code>和<code>setter</code>方法，可以使用关键字<code>@dynamic</code>来告诉编译器不要生成该属性任何代码或创建相应的实例变量。</p>
<p>有时想要换掉默认生成的方法名称，可以指定编译器生成的<code>getter</code>和<code>setter</code>方法的名称，使用<code>getter=</code>和<code>setter=</code>特性就可以自定义想要的方法名称。如果这样做的话，需要注意会破坏键/值规则，因此除非有必须使用这些特性的原因，否则请尽量避免使用。</p>
<h5 id="类别-category"><a href="#类别-category" class="headerlink" title="类别(category)"></a>类别<code>(category)</code></h5><p>类别是<code>Objective-C</code>允许你扩展现有的类(即使没有这些类的源代码)的方式。是一种为现有的类添加<strong>新方法</strong>的方式。利用<code>Objective-C</code>的动态运行时分配机制，可以为现有的类添加新方法。</p>
<p>可以在类别中添加属性，但不能添加实例变量，而且属性必须是<code>@dynamic</code>类型的。添加属性的好处在于可以通过点表达式来访问<code>setter</code>和<code>getter</code>方法。</p>
<p>类别有两个局限性：</p>
<blockquote>
<p>第一是无法向类中添加新的实例变量。类别没有空间容纳实例变量。</p>
<p>第二个就是名称冲突，也就是类别中的方法与现有的方法重名。当发生名称冲突时，类别具有更高的优先级。类别方法将完全取代初始方法，导致初始方法不再可用。</p>
</blockquote>
<p>类别的主要三个用途：</p>
<blockquote>
<p>将类的实现代码分散到多个不同文件或框架中；</p>
<p>创建对私有方法的前向引用；</p>
<p>向对象添加非正式协议<code>(informal protocol)</code>。</p>
</blockquote>
<p>类别可以访问其继承的类的实例变量。类别的方法具有更高的优先级。</p>
<p><code>run</code>循环(<code>runloop</code>)是一种<code>Cocoa</code>概念，它在等待某些事情发生之前一直处于阻塞状态，即不执行任何代码。</p>
<p>创建一个<code>NSObject</code>的类别称为“创建一个非正式协议”。协议是一组管理通信的规则。非正式协议的方法，是可选择实现<code>(@optional)</code>的方法。</p>
<h5 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h5><p>类扩展是一个特殊的类别。</p>
<p>类扩展的特点：</p>
<blockquote>
<p>它不需要名字；</p>
<p>可以在包含源代码的类中使用它；</p>
<p>可以添加实例变量；</p>
<p>可以将只读权限改成可读写的权限；</p>
<p>创建的数量不限。</p>
</blockquote>
<p>类扩展名称的由来：因这部分代码没有继承的父类，基本上就是获取当前(目标)的类，并通过添加私有属性和方法来扩展当前(目标)类。</p>
<h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p>选择器只是一个方法名称，它以Objective-C运行时使用的特殊方式编码，以快速执行查询。可以使用@selector()编译指令圆括号中的方法名称来指定选择器。</p>
<h5 id="正式协议"><a href="#正式协议" class="headerlink" title="正式协议"></a>正式协议</h5><p>正式协议要求显式地采用，采用协议的办法是在类的<code>@interface</code>声明中列出协议的名称。</p>
<p>可以继承父协议。在声明语句协议名称后面的尖括号内可以指定父协议的名称。语法如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@protocol customProtocolName &lt;继承的父协议名称&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p><code>zone</code>是<code>NSZone</code>类的一个对象，指向一块可供分配的内存区域。当向一个对象发送<code>copy</code>消息时，该<code>copy</code>消息在到达目标对象代码之前会被转换为<code>copyWithZone:</code>方法。</p>
<p><code>copyWithZone:</code>方法的首要任务是获得<code>self</code>参数所属的类，然后向<code>self</code>对象所属的类发送<code>allocWithZone:</code>消息，以分配内存并创建一个该类的新对象。</p>
<p>可以使用C语言风格的指针运算符直接访问实例变量。如：<code>obj-&gt;variate = newvVariate</code>。</p>
<h5 id="协议和数据类型"><a href="#协议和数据类型" class="headerlink" title="协议和数据类型"></a>协议和数据类型</h5><p>如果一个用尖括号括起来的协议名称跟随在<code>id</code>之后，则编译器将知道你会接受任意类型的对象，但前提是要遵守该协议。</p>
<h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><p>一个可以增强函数功能的<code>Objective-C</code>特性。代码块实际上是由<code>C</code>语言实现的。</p>
<p>代码块对象(简称代码块)，是对<code>C</code>语言中函数的扩展。除了函数中的代码，代码块还包含变量绑定。代码块包含两种类型的绑定：自动型与托管型。自动绑定使用的是栈中的内存，而托管绑定是通过堆创建的。</p>
<p>代码块可以访问与它相同的有效范围内声明的变量，也就是说代码块可以访问与它同时创建的有效变量。</p>
<h5 id="代码块和变量"><a href="#代码块和变量" class="headerlink" title="代码块和变量"></a>代码块和变量</h5><p>代码块被声明后会捕捉创建点时的状态。代码块可以访问函数用到的标准类型的变量：</p>
<blockquote>
<p>全局变量，包括在封闭范围内声明的本地静态变量。这种类型的变量值改变了，代码块内对应的变量值也同步改变了。</p>
<p>全局函数。</p>
<p>封闭范围内的参数。</p>
<p>函数级别(即与代码块声明时相同的级别)的<code>__block</code>变量。<code>__block</code>修饰的变量是可以修改的变量。<br>有些变量是无法声明为<code>__block</code>类型的。它们有两个限制：<br>1.没有长度可变的数组；<br>2.没有包含可变长度数组的结构体。</p>
<p>封闭范围内的非静态变量会被获取为常量。本地变量，因为变量是本地的，代码块会在定义时复制并保存它们的状态。(本地变量会被代码块作为常量获取到)。</p>
<p><code>Objective-C</code>的实例变量。</p>
<p>代码块内部的本地变量。</p>
</blockquote>
<p>在代码块中访问<code>Objective-C</code>变量时必须小心，因为涉及到内存管理问题。</p>
<p>代码块访问<code>Objective-C</code>变量时，处理内存管理的规则：</p>
<blockquote>
<p>如果引用了一个<code>Objective-C</code>对象，必须要保留它。</p>
<p>如果通过引用访问了一个实例变量，要保留一次<code>self</code>(即执行方法的对象)。</p>
<p>如果通过数值访问了一个实例变量，变量需要保留。</p>
</blockquote>
<p>因为代码块是对象，所以可以向它发送任何与内存管理有关的消息。在<code>C</code>语言级别中，必须使用<code>Block_copy()</code>和<code>Block_release()</code>函数来适当地管理内存。</p>
<h5 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h5><p>能够在<strong>同一时间</strong>执行<strong>多项任务</strong>的程序称为并发的程序。编写并发性程序需要创建多个线程。</p>
<p>为了减轻在多核上编程的负担，苹果公司引入了<code>GCD</code>技术。如果想要使用<code>GCD</code>，需要提交代码块或函数作为线程来运行。</p>
<p><code>GCD</code>是一个系统级别<code>(system-level)</code>的技术，因此你可以在任意级别的代码中使用它。<code>GCD</code>决定需要多少线程并安排它们运行的进度。因为<code>GCD</code>是运行在系统级别上的，所以可以平衡应用程序所有内容的加载，这样可以提高计算机或设备的执行效率。</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>同步思想：对临界区资源添加一个标记(flag)或一个互斥(mutex)机制，确保两个线程不会在同一时间进入临界区。</p>
<p><code>Objective-C</code>提供了一个语言级别的关键字<code>@synchronized</code>。它可以确保不同的线程会连续地访问临界区的代码。这样可以使线程间对临界区的代码进行同步操作。</p>
<p><code>nonatomic</code>与<code>atomic</code>对属性性能的影响：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若定义了一个属性并且指定关键字atomic作为属性的特性，此时编译器会生成强制彼此互斥的getter和setter方法，因编译器生成了@synchronize(mutex, atomic)语句来确保彼此互斥，这样设置代码和变量会产生一些消耗，会比直接访问更慢一些。因此若知道属性值不会被多个线程访问的话，可以添加nonatomic特性，这样做可以提高性能。</span><br></pre></td></tr></table></figure>
<h5 id="简单的后台执行"><a href="#简单的后台执行" class="headerlink" title="简单的后台执行"></a>简单的后台执行</h5><p><code>NSObject</code>提供了在后台执行代码的方法，能让一些代码在后台执行。这些方法的名字中都有<code>performSelector:</code>，它们通过创建一个线程来运行方法。<code>(NSThread)</code></p>
<p>定义在后台运行的方法须遵从以下限制：</p>
<blockquote>
<p>这些方法运行在各自的线程里，因此必须为这些<code>Cocoa</code>对象创建一个自动释放池。主自动释放池是与主线程相关的。</p>
<p>这些方法不能有返回值，并且要么没有参数，要么只有一个参数对象。</p>
</blockquote>
<p>当方法执行结束后，<code>Objective-C</code>运行时会特地清理并弃掉线程。方法执行结束后并不会通知你(如何自己实现方法执行结束后发出通知!!!)。</p>
<h5 id="后台执行复杂的操作"><a href="#后台执行复杂的操作" class="headerlink" title="后台执行复杂的操作"></a>后台执行复杂的操作</h5><p><code>GCD</code>可以使用调度队列<code>(dispatch queue)</code>，只需写下目标代码，把它指派给一个队列，系统就会执行它了。队列对象：<code>dispatch_queue_t</code>。</p>
<p>有以下<code>3</code>种类型的调度队列：</p>
<blockquote>
<p>连续队列：每个连续队列都会根据指派的顺序执行任务。可以创建任意数量的队列，它们会并行操作任务。连续队列，任务执行顺序为先进先出<code>(FIFO)</code>：只要任务是异步提交的，队列会确保任务根据预定顺序执行。这些队列都是不会发生死锁的。连续队列创建的方法为：<code>dispatch_queue_create()</code>。连续队列的创建涉及到内存管理。</p>
<p>并发队列：每个并发队列都能并发执行一个或多个任务。任务会根据指派到队列的顺序开始执行。无法创建并发队列，只能从系统提供的<code>3</code>种并发队列内选择一个来使用(<code>3</code>种并发队列：高优先级<code>(high)</code>、默认优先级<code>(default)</code>、低优先级<code>(low)</code>)。并发队列也遵从先进先出<code>(FIFO)</code>的规范。一次所运行的任务数量是无法预测的。每个应用程序都有上述<code>3</code>种并发队列可以使用。要使用它们，调用<code>dispatch_get_global_queue</code>方法，根据需要传入对应的参数，指定队列的优先级。并发队列都是全局的，所以无需为它们管理内存。</p>
<p>主队列：它是应用程序中有效的主队列，执行的是应用程序的主线程任务。使用<code>dispatch_get_main_queue</code>可以访问与应用程序主线程相关的主队列。通常要以同步方式使用这个队列，提交多个任务并在它们操作完毕后执行一些操作。</p>
</blockquote>
<p>可以通过调用<code>dispatch_get_current_queue()</code>来获取代码块当前所在的队列类型，即代码块所在的当前队列。如果在代码块对象之外调用了<code>dispatch_get_current_queue()</code>函数，则它将会返回主队列。</p>
<h5 id="调度队列的内存管理"><a href="#调度队列的内存管理" class="headerlink" title="调度队列的内存管理"></a>调度队列的内存管理</h5><p>调度队列是引用计数对象。使用<code>dispatch_retain()</code>和<code>dispatch_release()</code>来修改队列的引用计数器的值。只能对自己创建的队列使用这些函数，而无法用在全局调度队列上。</p>
<p>队列的上下文：</p>
<blockquote>
<p>系统只能知道上下文包含了与队列有关的数据，上下文数据的内存管理只能由你来做。你必须在需要它的时候分配内存并在队列销毁之前进行清理。在为上下文数据分配内存的时候，可以使用<code>dispatch_set_context()</code>和<code>dispatch_get_context()</code>函数。</p>
</blockquote>
<h5 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h5><p>有两种方式可以向队列中添加任务：</p>
<blockquote>
<p>同步：队列会一直等待前面任务结束。</p>
<p>异步：添加任务后，不必等待任务，函数会立即返回。推荐优先使用这种方式，因为它不会阻塞其他代码的运行。</p>
</blockquote>
<p>可以选择向队列提交代码块或函数。</p>
<h5 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h5><p>调度程序需要使用调度函数，将任务添加到调度队列里。</p>
<p>调度函数有4个，分别是代码块和函数各自的同步与异步方式。(同步：dispatch_sync、dispatch_sync_f；异步：dispatch_async、dispatch_async_f)</p>
<p>添加任务可以通过代码块或函数。添加任务的最简单的方法是通过代码块。代码块必须是dispatch_block_t这样的类型，要定义为没有参数和返回值才行。如：typedef void (^dispatch_block_t)(void)。</p>
<p>也可以向队列中添加函数，函数的标准原型必须要像如下这样：void function_name(void *argument)。</p>
<p>队列创建完之后，就做好接收任务的准备了。当我们添加了一个任务，队列就会安排好它的进度。</p>
<p>暂停队列：dispatch_suspend();</p>
<p>重新启用队列：dispatch_resume();</p>
<h5 id="操作队列"><a href="#操作队列" class="headerlink" title="操作队列"></a>操作队列</h5><p>操作(operation)API的使用，可以让队列在Objective-C层级上使用起来更加简单。(NSOperation)。</p>
<p>操作对应于任务；操作队列对应于调度队列。</p>
<p>如果想要使用操作，首先需要创建一个操作对象，然后将其指派给操作队列，并让队列执行它。</p>
<p>有3种创建操作的方式：</p>
<blockquote>
<p><code>NSInvocationOperation</code>：如果已经拥有一个可以完成工作的类，并且想要在队列上执行，可使用这种方法。NSInvocationOperation会为执行任务的类调用选择器。</p>
<p><code>NSBlockOperation</code>：像包含了需要执行代码块的dispatch_async函数。</p>
<p>自定义的操作：根据需要可以创建自己的自定义类型。必须通过<code>NSOperation</code>子类来定义自己的操作。</p>
</blockquote>
<p><code>NSOperationQueue</code>一般会并发执行操作。它具有相关性，因此如果某操作是基于其他操作的，它们会相应地执行。</p>
<p>一旦向队列中添加了操作，它就会被安排进度并执行。</p>
<p>如果经常要使用并发任务，应避免发生死锁(任务互相关联导致程序永远无法结束)。</p>
<hr>
<h5 id="图形框架介绍"><a href="#图形框架介绍" class="headerlink" title="图形框架介绍"></a>图形框架介绍</h5><p><code>OS X</code></p>
<p>通常在<code>Xcode</code>中为新创建的类添加前缀，因为<code>Objective-C</code>中没有命名空间，它用的是一种伪命名空间的方法，将应用程序中的一些名称储存起来了。<code>Xcode</code>内置了<code>Subversion(SVN)</code>和<code>Git</code>的源代码管理功能。</p>
<p><code>nib</code>是<code>NeXT Interface Builder</code>的首字母缩写，是<code>Cocoa</code>从<code>NeXT</code>公司沿袭下来的技术结晶。使用中将<code>.xib</code>文件称为<code>nib</code>文件。<code>nib</code>件是包含了压缩对象的二进制文件，而<code>.xib</code>文件是<code>XML</code>格式的<code>nib</code>文件，在编译时，<code>.xib</code>文件将会编辑为<code>nib</code>格式。</p>
<p><code>IBOutlet</code>的工作机制：</p>
<blockquote>
<p>在加载<code>nib</code>文件时(创建项目时创建的如<code>mainxxx.nib</code>文件会在应用程序启动时自动加载)，存储在<code>nib</code>文件中的任何对象都会被重新创建。这意味着会在后台执行<code>alloc</code>和<code>init</code>方法。所以，当应用程序启动时，会分配并初始化一个<code>AppDelegate</code>实例。在执行<code>init</code>方法期间，所有<code>IBOutlet</code>实例变量都是<code>nil</code>。只有在生成了<code>nib</code>文件中的所有对象(如按钮等)后，所有连接才算完成。一旦建立了所有连接(也就是将<code>nib</code>中控件等对象的地址添加到<code>AppDelegate</code>的实例变量中)，就会向创建的每个对象发送消息<code>awakeFromNib</code>。需注意，对象的创建和<code>awakeFromNib</code>消息的发送没有任何既定的顺序。</p>
<p>在<code>nib</code>项目中，在<code>awakeFromNib</code>方法中操作是最“稳妥”的，因此时对象已经创建并初始化完毕。对应于<code>iOS</code>中的<code>viewDidLoad</code>方法。</p>
</blockquote>
<p><code>iOS</code></p>
<p><code>iOS</code>没有命令行使用权。所有的应用程序都是在主窗口内运行的。视图控制器会在<code>nib</code>文件加载和对象初始化完成后调用<code>viewDidLoad</code>方法。</p>
<p><code>iOS</code>不支持虚拟内存，应用程序只能使用设备中可用的内存。</p>
<p><code>viewDidLoad</code>和<code>viewDidUnLoad</code>在视图的生命周期内只会调用到一次。</p>
<hr>
<h5 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h5><p><code>Cocoa</code>提供了两个处理文件的通用类：属性列表和对象编码。</p>
<p>属性列表能存储：<code>NSArray</code>、<code>NSDictionary</code>、<code>NSString</code>、<code>NSNumber</code>、<code>NSDate</code>和<code>NSData</code>。</p>
<p><code>NSTimeInterval</code>以秒为单位。</p>
<p>可以在终端查看<code>ASCII</code>表：在终端键入<code>man ascii</code></p>
<h5 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h5><p><code>Cocoa</code>具备一种将对象转换成某中格式并保存到磁盘中的机制。对象可以将它们的实例变量和其他数据编码为数据块，然后保存到磁盘中。这些数据块以后还可以读回内存中，并且还能基于保存到数据创建新对象。这个过程被称为编码与解码，也可以称为序列化与反序列化。</p>
<p>编码器的使用，<code>NSCoder</code>是一个抽象类，实现编码解码功能的是其子类，如<code>NSKeyedArchiver</code>和<code>NSKeyedUnarchiver</code>。</p>
<p>当使用<code>NSKeyedArchiver</code>和<code>NSKeyedUnarchiver</code>对对象进行编码解码时，会对应的调用<code>NSCoding</code>协议中的<code>encodeWithCoder</code>和<code>initWithCoder</code>的编码解码方法，因此对象若想实现编码解码功能，对应的类须遵从<code>NSCoding</code>协议，并实现<code>encodeWithCoder</code>和<code>initWithCoder</code>方法。使用时<code>NSKeyedArchiver</code>调用<code>archivedDataWithRootObject</code>进行编码；<code>NSKeyedUnarchiver</code>调用<code>unarchivedObjectOfClass</code>进行解码。</p>
<p>使用编码解码可以将大量对象转换成<code>NSData</code>，然后保存到磁盘中供以后读取。通过这种<code>NSData</code>，可以重新创建对象。</p>
<h5 id="键-值编码-KVC"><a href="#键-值编码-KVC" class="headerlink" title="键/值编码(KVC)"></a>键/值编码<code>(KVC)</code></h5><p><code>KVC</code>，其实现方法是使用字符串表示要更改的对象状态。</p>
<p>键/值编码中的基本调用是<code>valueForKey</code>和<code>setValueForKey</code>方法。可以向对象发送消息，并传递想要访问的属性名称(即，键)作为参数。</p>
<p><code>valueForKey</code>(检索值)的功能实现：</p>
<blockquote>
<p><code>valueForKey:</code>会首先查找以参数名命名(格式为<code>-key</code>或<code>-isKey</code>)的<code>getter</code>方法。如果没有这样的<code>getter</code>方法，它将会在对象内寻找名称格式为<code>_key</code>或<code>key</code>的实例变量。<code>valueForKey</code>在<code>Objective-C</code>运行时中使用元数据打开对象并进入其中查找需要的信息。</p>
</blockquote>
<p>通过使用<code>KVC</code>，没有相关<code>getter</code>方法也能获取对象值，不需要通过对象指针来直接访问实例变量。</p>
<p>对于<code>KVC</code>，<code>Cocoa</code>会自动装箱和开箱标量值。即，当使用<code>setValueForKey</code>时，它自动将标量值(<code>int</code>、<code>float</code>和<code>struct</code>)放入<code>NSNumber</code>或<code>NSValue</code>中；当使用<code>setValueForKey</code>时，它自动将标量值从这些对象中取出。仅<code>KVC</code>具有这种自动装箱功能，常规方法调用和属性语法不具备该功能。</p>
<p><code>setValueForKey</code>(设置值)的功能实现：</p>
<blockquote>
<p><code>setValueForKey</code>的工作方式和<code>valueForKey</code>相同。它首先查找名称的<code>setter</code>方法，如<code>-setKey</code>，然后调用它并传递参数。如果不存在<code>setter</code>方法，它将在类中寻找名为<code>key</code>或<code>_key</code>的实例变量，然后为它赋值。</p>
</blockquote>
<p>如想设置一个标量值，在调用<code>setValueForKey</code>方法之前需要将标量值包装起来，即装箱到对象中。在对对象进行<code>setValueForKey</code>时，<code>setValueForKey</code>方法会先开箱取出该值，再调用对应的<code>setter</code>方法或更改对应的实例变量。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译器和苹果公司都以下划线开头的形式保存实例变量名称。</span><br></pre></td></tr></table></figure>
<p>除了通过键设置值之外，键/值编码还支持指定键路径。对应的方法为：<code>valueForKeyPath</code>和<code>setValueForKeyPath</code>。</p>
<p>关于<code>KVC</code>常用的一点，如果使用某个键值来访问一个<code>NSArray</code>数组，它实际上会查询相应数组中的每个对象，然后将查询结果打包到另一个数组中并返回。这种方法也同样适用于通过键路径访问的位于对象中的数组。</p>
<p>将<code>valueForKey:</code>发送给数组时，键将作用于数组中的所有元素。</p>
<p><code>key</code>部分的字符串值区分大小写。</p>
<h5 id="键路径的优点"><a href="#键路径的优点" class="headerlink" title="键路径的优点"></a>键路径的优点</h5><p>键路径，它们是由点分割的键，用于在对象的网络中指定路径。</p>
<p>键路径不仅能引用对象值，还可以引用一些运算符来进行一些运算。</p>
<p>不要滥用<code>KVC</code>，因为<code>KVC</code>需要解析字符串来计算需要的答案，因此速度比较慢。此外，编译器还无法对它进行错误检查，因此编译器不能辅助判断错误。</p>
<h5 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h5><p><code>KVC</code>包含两个调用，可以使用它们为对象进行批量更改。这两个方法是：<code>dictionaryWithValuesForKeys</code>(它接收一个字符串数组，该调用获取键的名称，并对每个键使用<code>valueForKey</code>方法，然后为键字符串和刚获取的值构建一个字典)和<code>setValuesForKeysWithDictionary</code>。</p>
<p>在使用<code>KVC</code>的过程中可根据错误提示信息对程序进行优化。如提示中含有<code>setNilValueForKey</code>，则是当前类没有对设置为<code>nil</code>时作兼容处理，此时在类中重写<code>setNilValueForKey</code>并作相应处理即可。类似情况可以处理未定义的键，同样重写<code>valueForUndefinedKey</code>和<code>setValue:forUndefinedKey</code>。</p>
<p>在使用<code>KVC</code>的<code>setValue:forKey:</code>方法时，通过这种方法，调用者可以直接传入<code>nil</code>值，不必在代码中检查它。而如果使用<code>NSDictionary</code>的<code>setObject:forKey:</code>方法时，提供<code>nil</code>值，会报警告信息。如果在字典中对<code>setValue:forKey:</code>方法传入<code>nil</code>值，字典会把对应键的值给删除。</p>
<p><code>&lt;null&gt;</code>与<code>(null)</code>的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;null&gt;是一种[NSNull null]对象，而(null)是一个真正的nil值。</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="静态分析器-static-analyzer"><a href="#静态分析器-static-analyzer" class="headerlink" title="静态分析器(static analyzer)"></a>静态分析器<code>(static analyzer)</code></h5><p>静态分析器，是一个不需要运行程序就可以从逻辑上检测代码的工具。静态分析器不是简单的浏览一遍源代码，而是在应用程序的代码通道中查找逻辑错误并反馈给你。</p>
<p>静态分析器可分析的几种错误：</p>
<blockquote>
<p>安全问题，如内存泄漏和缓冲区溢出。</p>
<p>并发性问题，如静态条件(即依赖时间的两个或多个任务失败)。</p>
<p>逻辑问题，包括废代码和不好的编码习惯。</p>
</blockquote>
<p>使用静态分析器的快捷键：<code>Command + shift + B</code>。</p>
<p>使用<code>NSPredicate</code>(谓词)类来过滤集合中的对象。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/iOS面试知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/05/iOS面试知识点/" class="post-title-link" itemprop="url">iOS面试知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-05 11:14:24" itemprop="dateCreated datePublished" datetime="2019-03-05T11:14:24+08:00">2019-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><code>Apple</code>源码 <a href="https://github.com/opensource-apple?tab=overview&amp;from=2018-12-01&amp;to=2018-12-31" target="_blank" rel="noopener">Apple Github</a>、<a href="https://opensource.apple.com/source/" target="_blank" rel="noopener">Apple OpenSource</a></li>
</ul>
<h5 id="weak"><a href="#weak" class="headerlink" title="weak"></a><code>weak</code></h5><p><code>weak</code>关键字的作用弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候，<code>weak</code>修饰的对象会自动被设置为<code>nil</code>。</p>
<p><code>weak</code>底层原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">weak 的功能实现通过runtime初始化并维护的。weak是由Runtime维护</span><br><span class="line">的weak表。weak表是一个hash表，用于存储指向某个对象的所有weak指</span><br><span class="line">针，key是指向对象的地址，value是weak指针的地址&lt;这个地址的值是所</span><br><span class="line">指对象指针的地址&gt;数组。</span><br><span class="line"></span><br><span class="line">具体步骤：</span><br><span class="line">1，初始化时：runtime会调用objc_initWeak函数，初始化一个新的</span><br><span class="line">weak指针指向对象的地址。</span><br><span class="line">2， 添加引用时：objc_initWeak函数会调用 storeWeak() 函数，</span><br><span class="line"> storeWeak() 的作用是更新指针指向，创建对应的弱引用表。</span><br><span class="line">3，释放时,调用clearDeallocating函数。clearDeallocating函数</span><br><span class="line">首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中</span><br><span class="line">的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</span><br></pre></td></tr></table></figure>
<p><code>runtime</code>源码中对应的<code>weak</code>文件，见<a href="https://opensource.apple.com/source/objc4/objc4-750/runtime/" target="_blank" rel="noopener">objc4-750</a>。</p>
<p>补充：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash表是链表数组的数据结构，操作存储的数据时会用到对应的hash函数和 equals函数。</span><br></pre></td></tr></table></figure>
<p>扩展题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">两个对象 Person p1 p2</span><br><span class="line">问题：如果两个对象的哈希值相同，p1.hashCode()==p2.hashCode()</span><br><span class="line">两个对象的equals一定返回true吗？p1.equals(p2)一定是true吗？</span><br><span class="line">答案：不一定</span><br><span class="line"></span><br><span class="line">如果两个对象的equals方法返回true,p1.equals(p2)==true</span><br><span class="line">两个对象的哈希值一定相同吗？</span><br><span class="line">答案：一定</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a><code>KVO</code></h5><p><code>KVO</code>即是<code>NSKeyValueObserving</code>，是对象(如：a)用来通知其他对象(如：b)指定的属性(如：name)发生了改变的一种非正式协议。其中：a是被监听的对象，b是监听的对象。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">非正式协议，是NSObject的一个分类Category，非正式协议的方法</span><br><span class="line">是可选的。分类是OC的语言特性，能够给类对象添加方法而不需要创建子类。</span><br><span class="line"></span><br><span class="line">正式协议，正式协议有自己的声明、类型检查语法。一个正式协议声明了类</span><br><span class="line">需要实现的方法列表，可以使用required或者optional关键字指定方法</span><br><span class="line">是否必须实现。正式协议也可以遵守其他协议。子类继承父类遵守的协议。</span><br></pre></td></tr></table></figure>
<p>实现<code>KVO</code>的过程：</p>
<p>1.添加监听，监听指定的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<p>2.实现监听，收到监听反馈后，实现具体的逻辑处理。在监听的对象里，要实现非正式协议的方法，以对收到的监听反馈进行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<p>3.移除监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
<p><code>KVO</code>的底层实现：</p>
<p>在添加监听(<code>addObserver</code>)之后，实例对象的类对象发生了变化，系统动态添加了一个<code>NSKVONotifying_被监听的类名</code>的类(中间类)，如<code>NSKVONotifying_Animal</code>，<code>Animal</code>是被监听的类。因为改变对象属性的值是通过<code>setter</code>方法实现的，所以很明显是系统动态生成的中间类重写了<code>setter</code>方法。系统重写<code>setter</code>方法的过程中调用了<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法，<code>didChangeValueForKey</code>方法中调用了<code>observeValueForKeyPath</code>。</p>
<hr>
<h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a><code>Runtime</code></h5><p><code>Runtime</code>运行时，是<code>OC</code>动态性的基础。<code>OC</code>的动态性体现在动态类型、动态绑定、动态加载。基于<code>Runtime</code>，<code>OC</code>语言将数据类型的确定由编译时推迟到了运行时。基于<code>Runtime</code>，在编译时确定的方法推迟到了运行时，所以能动态产生、修改、删除类、成员变量、方法。<code>Runtime</code>是一个<code>C</code>语言<code>API</code>的库。</p>
<p>常用的<code>Runtime</code>接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对应文件：#import &lt;objc/runtime.h&gt; </span><br><span class="line"></span><br><span class="line">操作成员变量、类、方法：</span><br><span class="line">Ivar * class_copyIvarList : 获得某个类内部的所有成员变量</span><br><span class="line">Method * class_copyMethodList : 获得某个类内部的所有方法</span><br><span class="line">Method class_getInstanceMethod : 获得某个实例方法（对象方法，减号-开头）</span><br><span class="line">Method class_getClassMethod : 获得某个类方法（加号+开头）</span><br><span class="line">method_exchangeImplementations : 交换2个方法的具体实现</span><br></pre></td></tr></table></figure>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息传递，属于动态调用过程，即在编译阶段不能确定真正所要调用的函</span><br><span class="line">数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="从源代码到运行的APP"><a href="#从源代码到运行的APP" class="headerlink" title="从源代码到运行的APP"></a>从源代码到运行的<code>APP</code></h5><p>当点击了<code>build</code>之后，发生的事：<strong>预处理(生成.i文件) - 编译(生成.s文件) - 汇编(生成.o文件) - 链接</strong></p>
<ul>
<li>预处理<code>(Pre-process)</code>：把宏替换，删除注释，展开头文件，产生<code>.i</code>文件</li>
<li>编译<code>(Compliling)</code>：把之前的<code>.i</code>文件转换成汇编语言，产生<code>.s</code>文件</li>
<li>汇编<code>(Asembly)</code>：把汇编语言文件转换为机器码文件，产生<code>.o</code>文件</li>
<li>链接<code>(Link)</code>：对<code>.o</code>文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件(同时也包括多个<code>.o</code>文件进行<code>link</code>)</li>
</ul>
<hr>
<h5 id="self-navigationItem-title与self-title有什么区别"><a href="#self-navigationItem-title与self-title有什么区别" class="headerlink" title="self.navigationItem.title与self.title有什么区别"></a><code>self.navigationItem.title</code>与<code>self.title</code>有什么区别</h5><ul>
<li>联系<ul>
<li><code>self.title</code>是控制器默认<code>view</code>的<code>title</code></li>
<li><code>self.navigationItem.title</code>是显示在<code>navigationBar</code>中间的<code>title</code></li>
<li>修改<code>self.title</code>或者<code>self.navigationItem.title</code>都可以修改标题</li>
</ul>
</li>
<li>区别<ul>
<li>标题始终显示<code>self.navigationItem.title</code>的值</li>
<li>当<code>self.navigationItem.title</code>为空<code>(null)</code>时，则显示空白</li>
<li>当<code>self.title</code>的值被修改时，<code>self.navigationItem.title</code>的值也会跟着修改为<code>self.title</code>的值</li>
<li>当<code>self.navigationItem.title</code>的值被修改时，<code>self.title</code>的值不变，标题也会跟着修改为<code>self.navigationItem.title</code>的值</li>
<li><code>self.title</code>作用于<code>tabbar</code>标题上和<code>self.navigationItem.title上</code>；<code>self.navigationItem.title</code>作用于<code>navigationBar</code>的标题上</li>
</ul>
</li>
</ul>
<hr>
<h5 id="UINavigationController的title不显示问题"><a href="#UINavigationController的title不显示问题" class="headerlink" title="UINavigationController的title不显示问题"></a><code>UINavigationController</code>的<code>title</code>不显示问题</h5><p><code>title</code>这个属性实际上是属于<code>UIViewController</code>而不属于<code>UINavigationController</code>。所以，这个属性是从<code>UIViewController</code>上面继承过来的。而不是<code>UINavigationController</code>上面的名字。由于<code>UINavigationController</code>属于容器，所以最少需要一个<code>RootController</code>。然后在<code>RootController</code>的<code>viewDidLoad</code>设置<code>title</code>而不是在<code>UINavigationController</code>的<code>subclass</code>中设置。而且<code>viewDidLoad</code>设置的<code>title</code>是统一显示的，导航视图控制的<code>UIViewController</code>的<code>title</code>都是一样的。</p>
<hr>
<h5 id="category和extension的区别"><a href="#category和extension的区别" class="headerlink" title="category和extension的区别"></a><code>category</code>和<code>extension</code>的区别</h5><ul>
<li><p><code>extension</code>(扩展)</p>
<ul>
<li>在编译期决定，是类的一部分。在编译期和头文件(<code>.h</code>)里的<code>@interface</code>以及实现文件(<code>.m</code>)里的<code>@implement</code>一起形成一个完整的类。<code>extension</code>伴随类的产生而产生，亦随类的消亡而消亡</li>
<li>一般用来隐藏类的私有信息。必须有类的源码才能为一个类添加<code>extension</code>，所以无法为系统的类，如<code>NSString</code>添加<code>extension</code></li>
</ul>
</li>
<li><p><code>category</code>(分类)</p>
<ul>
<li>是在运行期决定的</li>
</ul>
</li>
</ul>
<p>从上面<code>category</code>和<code>extension</code>的区别来看，<code>extension</code>可以添加实例变量，而<code>category</code>是无法添加实例变量的，因在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内存布局，这对编译型语言来说是灾难性的。</p>
<ul>
<li><p><code>category</code>的加载过程</p>
<ul>
<li>把<code>category</code>的实例方法、协议以及属性添加到类上</li>
<li>把<code>category</code>的类方法添加到类的<code>metaclass</code>上</li>
</ul>
</li>
<li><p>在类和<code>category</code>中都有<code>+load</code>方法时</p>
<ul>
<li>在类的<code>+load</code>方法调用的时候，可以调用<code>category</code>中声明的方法，因为附加<code>category</code>到类的操作会先于<code>+load</code>方法的执行</li>
<li>类和<code>category</code>中的<code>+load</code>方法，调用顺序为，<code>+load</code>的执行顺序是先类，后<code>category</code>，而<code>category</code>的<code>+load</code>执行顺序是根据编译顺序决定的。对于<code>+load</code>的执行顺序是这样，但是对于<strong>覆盖</strong>掉的方法，则会先找到最后一个编译的<code>category</code>里对应的方法</li>
</ul>
</li>
<li><p>关于使用<code>category</code>时，出现类中的方法被<code>category</code>中同名的方法<strong>覆盖</strong>掉的理解</p>
<ul>
<li><code>category</code>的方法<strong>没有完全替换掉</strong>原来类已经有的方法，即<code>category</code>和原来类都有同名方法<code>methodA</code>，那么<code>category</code>附加完成之后，类的方法列表里会有两个<code>methodA</code></li>
<li><code>category</code>的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是平常所说的<code>category</code>中的方法会<strong>覆盖</strong>掉原来类的同名方法，因为运行时在查找方法的时候是顺着方法列表的顺序查找的，只有找到对应名字的方法，就会返回，不管后面会不会还有一样名字的方法</li>
</ul>
</li>
<li><p>如何调用到原来类中被<code>category</code><strong>覆盖</strong>掉的方法</p>
<ul>
<li><code>category</code>并不是完全替换掉原来类中的同名方法，只是<code>category</code>中的方法在方法列表的前面，优先命中了而已，所以只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类中的方法</li>
<li>实现代码如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 假设被覆盖的方法名叫 methodA。</span><br><span class="line">Class currentClass = [OriginalClass class];</span><br><span class="line">OriginalClass *my = [[OriginalClass alloc] init];</span><br><span class="line"></span><br><span class="line">if (currentClass) &#123;</span><br><span class="line">    unsigned int methodCount;</span><br><span class="line">    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);</span><br><span class="line">    IMP lastImp = NULL;</span><br><span class="line">    SEL lastSel = NULL;</span><br><span class="line">    for (NSInteger i = 0; i &lt; methodCount; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding];</span><br><span class="line">        if ([@&quot;methodA&quot; isEqualToString:methodName]) &#123;</span><br><span class="line">            lastImp = method_getImplementation(method);</span><br><span class="line">            lastSel = method_getName(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    typedef void (*fn)(id,SEL);</span><br><span class="line"></span><br><span class="line">    if (lastImp != NULL) &#123;</span><br><span class="line">        fn f = (fn) lastImp;</span><br><span class="line">        f(my, lastSel);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/CocoaPods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/04/CocoaPods/" class="post-title-link" itemprop="url">CocoaPods</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-04 15:35:13" itemprop="dateCreated datePublished" datetime="2019-03-04T15:35:13+08:00">2019-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><code>CocoaPods</code>是一个<code>Xcode</code>项目下管理类库依赖的工具。在使用<code>CocoaPods</code>之后，只需要将用到的第三方开源库的名字放到<code>Podfile</code>文件中，然后执行<code>pod install</code>。<code>CocoaPods</code>就会自动将<code>podfile</code>文件中的第三方开源库的源码下载下来，并且为工程设置好相应的系统依赖和编译参数。</p>
<p><code>CocoaPods</code>的介绍可见<a href="https://guides.cocoapods.org/using/getting-started.html" target="_blank" rel="noopener">What is CocoaPods</a></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><code>CocoaPods</code>是用<code>Ruby</code>写的工具。因此安装<code>CocoaPods</code>之前要先安装<code>Ruby</code>。在<code>Ruby</code>环境下，通过<code>gem</code>来安装<code>CocoaPods</code>。</p>
<ul>
<li>安装<code>Ruby</code>、<code>gem</code></li>
</ul>
<p><code>Ruby</code>的安装方式有多种。具体安装方式见<a href="http://www.ruby-lang.org/zh_cn/documentation/installation/" target="_blank" rel="noopener">安装 Ruby</a>。</p>
<p><code>MacOS</code>环境下，通常会使用包管理系统工具<code>Homebrew</code>，获取安装最新的<code>Ruby</code>，安装命令为：<code>brew install ruby</code>。<code>RubyGems</code>从<code>Ruby1.9</code>版起成为<code>Ruby</code>标准库的一部分，可见<a href="http://www.runoob.com/ruby/ruby-rubygems.html" target="_blank" rel="noopener">RubyGems 介绍</a>。因此安装最新版本的<code>Ruby</code>就有<code>gem</code>包管理工具。</p>
<p>可通过<code>brew -v</code>查看<code>Homebrew</code>的版本信息，如未安装<code>Homebrew</code>，参考<a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">安装 Homebrew</a>。</p>
<p>如需手动安装<code>gem</code>，参考<a href="https://rubygems.org/pages/download" target="_blank" rel="noopener">安装 RubyGems</a>。</p>
<p>通过<code>gem help commands</code>查看<code>gem</code>的对应命令。如查看<code>gem</code>的安装路径用<code>gem environment gemdir</code>。</p>
<ul>
<li>安装<code>CocoaPods</code></li>
</ul>
<p>使用淘宝的镜像安装Ruby的第三方库，修改gem的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem sources --remove https://rubygems.org/</span><br><span class="line">gem sources -a https://ruby.taobao.org/</span><br></pre></td></tr></table></figure>
<p>为了验证<code>Ruby</code>镜像是并且仅是淘宝，可以用以下命令查看：<code>gem sources -l</code></p>
<p>只有在终端中出现下面文字才表明修改<code>gem</code>的镜像命令是成功的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https://ruby.taobao.org/</span><br></pre></td></tr></table></figure>
<p>修改<code>gem</code>镜像成功后，终端中执行命令<code>sudo gem install cocoapods</code>安装<code>CocoaPods</code>。安装完成后，执行命令<code>pod setup</code>初始化<code>CocoaPods</code>的环境。</p>
<p>Tips:</p>
<p>官宣安装介绍，可见<a href="https://guides.cocoapods.org/using/getting-started.html#getting-started" target="_blank" rel="noopener">Getting Started</a>。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul>
<li>创建<code>Xcode</code>工程并<code>cd</code>到工程路径</li>
<li>使用命令<code>pod init</code>，此时会在当前路径下生成<code>Podfile</code>文件</li>
<li>编辑<code>Podfile</code>文件，添加需要使用的第三方库的名字，如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &apos;9.0&apos;</span><br><span class="line">pod &apos;Masonry&apos;</span><br><span class="line">pod &apos;SDWebImage&apos;</span><br></pre></td></tr></table></figure>
<p>往<code>Podfile</code>添加第三方库的格式为：<code>pod &#39;第三方库名称&#39;, &#39;版本号&#39;</code></p>
<p>版本号标识的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;&gt; 0.1&apos; Any version higher than 0.1</span><br><span class="line">&apos;&gt;= 0.1&apos; Version 0.1 and any higher version</span><br><span class="line">&apos;&lt; 0.1&apos; Any version lower than 0.1</span><br><span class="line">&apos;&lt;= 0.1&apos; Version 0.1 and any lower version</span><br><span class="line"></span><br><span class="line">&apos;~&gt; 0.1.2&apos; Version 0.1.2 and the versions up to 0.2, not including 0.2 and higher</span><br><span class="line">&apos;~&gt; 0.1&apos; Version 0.1 and the versions up to 1.0, not including 1.0 and higher</span><br><span class="line">&apos;~&gt; 0&apos; Version 0 and higher, this is basically the same as not having it.</span><br><span class="line"></span><br><span class="line">有版本号，但不加任何操作符修饰，则为下载安装指定版本号的库。</span><br><span class="line">无版本号，则为下载安装最新版本号的库。</span><br></pre></td></tr></table></figure>
<p><code>Podfile</code>的编辑规范，可见<a href="https://guides.cocoapods.org/using/the-podfile.html" target="_blank" rel="noopener">The Podfile</a></p>
<ul>
<li>安装工程依赖的第三方库</li>
</ul>
<p>执行命令<code>pod install</code>    ，出现<code>pods installed</code>提示，则表示所需的第三方库安装成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如是初始配置工程使用 CocoaPods，则在执行 pod install 成功后，项目文件夹下会新增 xxx.xcworkspace、Podfile.lock、Pods</span><br></pre></td></tr></table></figure>
<ul>
<li>打开<code>.xcworkspace</code>文件，在需要使用第三方库的类中导入第三方库文件，如<code>#import &lt;Masonry.h&gt;</code>即可。</li>
</ul>
<h5 id="使用过程中遇到的问题及解决方法"><a href="#使用过程中遇到的问题及解决方法" class="headerlink" title="使用过程中遇到的问题及解决方法"></a>使用过程中遇到的问题及解决方法</h5><hr>
<ul>
<li><code>Ruby</code>镜像源问题</li>
</ul>
<p>在<code>Ruby</code>镜像源是<code>https://ruby.taobao.org/</code>的情况下，安装<code>cocoapods</code>(<code>sudo gem install cocoapods</code>)，出现如下错误提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:  Could not find a valid gem &apos;cocoapods&apos; (&gt;= 0), here is why:</span><br><span class="line">          Unable to download data from https://ruby.taobao.org/ - SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://ruby.taobao.org/specs.4.8.gz)</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>切换源，不用淘宝的了，用基于腾讯云的<code>https://gems.ruby-china.com/</code>(注意服务域名的更换，已经将<code>.org</code>换成<code>.com</code>)</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看当前Ruby镜像源：gem sources -l</span><br><span class="line">查看当前pod版本：pod --version</span><br><span class="line">移除镜像源：gem sources --remove 镜像源地址(可用gem sources -l来查询)</span><br><span class="line">添加镜像源：gem sources -a 镜像源地址</span><br><span class="line"></span><br><span class="line">安装指定版本的cocoapods，有两个方法：</span><br><span class="line">方法一：gem install cocoapods -v 1.7.3(指定版本号，这种方法不一定能成功)</span><br><span class="line">方法二：sudo gem install -n /usr/local/bin cocoapods -v 1.7.3(指定版本号，这种方法成功概率大)</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/07/微信小程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/07/微信小程序/" class="post-title-link" itemprop="url">微信小程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-07 11:34:46" itemprop="dateCreated datePublished" datetime="2019-02-07T11:34:46+08:00">2019-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当微信中的<code>WebView</code>逐渐成为移动<code>Web</code>的一个重要入口时，微信就有相关的<code>JS API</code>了。为了使在微信中对网页的开发简洁、高效，微信在<code>2015</code>年发布了一整套<strong>网页开发工具包<code>JS-SDK</code></strong>，让开发者可以使用到微信的原生能力。</p>
<p><code>JS-SDK</code>解决了<strong>移动网页</strong>能力不足的问题，通过暴露微信的接口使得<code>Web</code>开发者能够拥有更多的能力，然而在更多的能力之外，<code>JS-SDK</code>的模式并没有解决使用移动网页遇到的体验不良的问题。</p>
<p>使用移动网页遇到的体验不良问题，有：</p>
<ol>
<li>白屏过程(在移动端，受限于设备性能和网络速度，白屏会更加明显。有微信<code>Web</code>资源离线存储的解决方案)<ul>
<li>微信<code>Web</code>资源离线存储是面向<code>Web</code>开发者提供的基于微信内的<code>Web</code>加速方案：通过使用微信离线存储，<code>Web</code>开发者可借助微信提供的资源存储能力，直接从微信本地加载<code>Web</code>资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有<code>Web App</code>累计最多可缓存<code>5M</code>的资源</li>
<li>简单的页面通过<strong>离线存储</strong>能够解决白屏问题，但对于复杂页面(如页面加载了大量的<code>CSS</code>或是<code>JavaScript</code>文件)，依然会有白屏问题，因为构建复杂页面的文件的执行时间占用了大量的<code>UI</code>线程</li>
</ul>
</li>
<li>缺少操作的反馈，主要表现在：<ul>
<li>页面切换的生硬</li>
<li>点击的迟滞感</li>
</ul>
</li>
</ol>
<p>为解决上述的用户体验问题，使开发者对移动网页的开发简洁、高效，全新的系统小程序应运而生。小程序具有以下特点：</p>
<ul>
<li>快速的加载</li>
<li>更强大的能力</li>
<li>原生的体验</li>
<li>易用且安全的微信数据开放</li>
<li>高效和简单的开发</li>
</ul>
<h3 id="小程序与普通网页开发的区别"><a href="#小程序与普通网页开发的区别" class="headerlink" title="小程序与普通网页开发的区别"></a>小程序与普通网页开发的区别</h3><p>小程序的主要开发语言是<code>JavaScript</code></p>
<p>网页开发<strong>渲染线程</strong>和<strong>脚本线程</strong>是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种<strong>浏览器暴露出来的<code>DOM API</code></strong>，进行<code>DOM</code>选中和操作。小程序的<strong>逻辑层</strong>和<strong>渲染层</strong>是分开的，逻辑层运行在<code>JSCore</code>中，并没有一个完整<strong>浏览器对象</strong>，因而缺少相关的<code>DOM API</code>和<code>BOM API</code>。这一区别导致了前端开发非常熟悉的一些库，例如<code>jQuery</code>、<code>Zepto</code>等，在小程序中是无法运行的。同时<code>JSCore</code>的环境同<code>NodeJS</code>环境也是不尽相同，所以一些<code>NPM</code>的包在小程序中也是无法运行的。</p>
<p><strong>网页开发</strong>者需要面对的环境是各式各样的<strong>浏览器</strong>，<code>PC</code>端需要面对<code>IE</code>、<code>Chrome</code>、<code>QQ</code>浏览器等，在移动端需要面对<code>Safari</code>、<code>Chrome</code>以及<code>iOS</code>、<code>Android</code>系统中的各式<code>WebView</code>。而小程序开发过程中需要面对的是两大操作系统<code>iOS</code>和<code>Android</code>的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，区别如下：</p>
<p><img src="/2019/02/07/微信小程序/小程序的运行环境.png" alt="小程序的运行环境"></p>
<h3 id="小程序代码组成"><a href="#小程序代码组成" class="headerlink" title="小程序代码组成"></a>小程序代码组成</h3><p>小程序由配置代码<code>JSON</code>文件、模板代码<code>WXML</code>文件、样式代码<code>WXSS</code>文件以及<strong>逻辑代码</strong><code>JavaScript</code>文件组成。</p>
<h5 id="JSON配置"><a href="#JSON配置" class="headerlink" title="JSON配置"></a><code>JSON</code>配置</h5><p><code>JSON</code>是一种数据格式，并不是编程语言。在小程序中<code>.json</code>为后缀的<code>JSON</code>文件是配置文件。</p>
<p><code>JSON</code>文件在小程序代码中扮演静态配置的作用，在小程序运行之前就决定了小程序一些表现，需要注意的是小程序是无法在运行过程中去动态更新<code>JSON</code>配置文件从而发生对应变化的。</p>
<ul>
<li><code>JSON</code>语法</li>
</ul>
<p>通过<code>key-value</code>的方式来表达数据，<code>JSON</code>中键和值都用双引号包裹。<code>JSON</code>文件中无法使用注释，添加注释将会引发报错。</p>
<ul>
<li><code>JSON</code>的值只能是以下几种数据格式<ol>
<li>数字，包含浮点数和整数</li>
<li>字符串，需要包裹在双引号中</li>
<li><code>Bool</code>值，<code>true</code>或者<code>false</code></li>
<li>数组，需要包裹在方括号中<code>[]</code></li>
<li>对象，需要包裹在大括号中<code>{}</code></li>
<li><code>Null</code></li>
</ol>
</li>
</ul>
<p><strong>小程序配置 app.json</strong></p>
<p><code>app.json</code> 是当前小程序的<strong>全局配置</strong>，包括了小程序的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所有页面路径、</span><br><span class="line">界面表现、</span><br><span class="line">网络超时时间、</span><br><span class="line">底部 tab 等。</span><br></pre></td></tr></table></figure>
<p>主要配置项的含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pages - 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径+文件名 信息。</span><br><span class="line">文件名不需要写文件后缀，框架会自动去寻找对应位置的 .json, .js, .wxml, .wxss 四个文件进行处理。</span><br><span class="line"></span><br><span class="line">pages配置项的值是数组，数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。</span><br><span class="line"></span><br><span class="line">tabBar - 指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</span><br><span class="line">其中 tabBar 的 list 属性接受一个数组，只能配置最少 2 个、最多 5 个 tab。tab 按数组的顺序排序，每个项都是一个对象。</span><br></pre></td></tr></table></figure>
<p>配置项细节可参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html" target="_blank" rel="noopener">小程序的配置 app.json</a></p>
<p><strong>工具配置 project.config.json</strong></p>
<p>使用场景：开发者在小程序开发者工具上做的任何配置都会写入到这个文件，当重新安装工具或换电脑时，只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到之前开发项目时的个性化配置。</p>
<p>配置项细节可参考<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html" target="_blank" rel="noopener">开发者工具的配置</a></p>
<p><strong>页面配置 page.json</strong></p>
<p>这类配置是<code>pages/xxx</code>目录下和小程序页面相关的配置。让开发者可以独立定义每个页面的属性，如顶部颜色、是否允许下拉刷新。</p>
<p>页面的配置只能设置<code>app.json</code>中部分<code>window</code>配置项的内容，页面中配置项会覆盖<code>app.json</code>的<code>window</code>中相同的配置项。</p>
<p>配置项细节可参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#页面配置" target="_blank" rel="noopener">页面配置</a></p>
<h5 id="wxml后缀的WXML模板文件"><a href="#wxml后缀的WXML模板文件" class="headerlink" title=".wxml后缀的WXML模板文件"></a><code>.wxml</code>后缀的<code>WXML</code>模板文件</h5><p><code>WXML</code>全称是<code>WeiXin Markup Language</code>，是小程序框架设计的一套标签语言，结合小程序的基础组件、事件系统，可以构建出页面的结构。<code>WXML</code>要求标签必须是严格闭合的，没有闭合将会导致编译错误。</p>
<p><strong>标签</strong>可以拥有<strong>属性</strong>，属性提供了有关的<strong><code>WXML</code>元素</strong>更多信息。<strong>属性总是定义在开始标签中</strong>，除了一些特殊的属性外，其余<strong>属性的格式都是key=”value”的方式成对出现</strong>。需要注意的是，<code>WXML</code>中的<strong>属性是大小写敏感的</strong>，也就是说<code>class</code>和<code>Class</code>在<code>WXML</code>中是不同的属性。</p>
<p>网页编程采用的是<code>HTML + CSS + JS</code>这样的组合，其中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML： 是用来描述当前这个页面的结构；</span><br><span class="line">CSS： 用来描述页面的样子；</span><br><span class="line">JS： 通常是用来处理这个页面和用户的交互。</span><br></pre></td></tr></table></figure>
<p>和<code>HTML</code>相似，<code>WXML</code>由标签、属性等构成。也有很多不一样的地方，区别如下：</p>
<ol>
<li>标签名字不一样：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">写 HTML 的时候，经常会用到的标签是 div，p，span，在写一个页面的</span><br><span class="line">时候可以根据这些基础的标签组合出不一样的组件，如日历、弹窗等。基于</span><br><span class="line">此小程序把常用的组件包装起来，用指定的标签表示包装起来的组件，同时</span><br><span class="line">被包装起来的组件拥有对应的基本能力。如小程序的 WXML 用的标签是 </span><br><span class="line">view，button，text等，这些标签就是小程序给开发者包装好的基本组件</span><br><span class="line">能力，除此之外微信还提供了地图、视频、音频等组件能力。</span><br></pre></td></tr></table></figure>
<p>更多组件能力的详细信息可参考<a href="https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/framework.html" target="_blank" rel="noopener">小程序的能力</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/component/" target="_blank" rel="noopener">小程序的组件</a></p>
<ol start="2">
<li>多了一些<code>wx:if</code>这样的属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">多了一些 wx:if 这样的属性以及 &#123;&#123;&#125;&#125; 这样的表达式。</span><br><span class="line"></span><br><span class="line">小程序中，wx:if 这样的属性和 &#123;&#123;&#125;&#125; 这样的表达式引入的背景：</span><br><span class="line"></span><br><span class="line">在网页的一般开发流程中，通常会通过 JS 操作 DOM（对应 HTML 的描述</span><br><span class="line">产生的树），以引起界面的一些变化响应用户的行为。如，用户点击某个按</span><br><span class="line">钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操</span><br><span class="line">控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时</span><br><span class="line">候，代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不</span><br><span class="line">是一个很好的开发模式，因此就有了 MVVM 的开发模式（如React，</span><br><span class="line">Vue），提倡把渲染和逻辑分离。</span><br></pre></td></tr></table></figure>
<p><strong>小程序框架的思路：</strong>简单来说就是不要再让 <code>JS</code> 直接操控 <code>DOM</code>，<code>JS</code> 只需要管理状态即可，然后再通过一种<strong>模板语法</strong>来描述状态和界面结构的关系即可。</p>
<ul>
<li>数据绑定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数据绑定实现程序运行的过程中，可以动态的去改变渲染界面。在Web开发中，开发者使用JavaScript</span><br><span class="line">通过Dom接口来完成界面的实时更新。在小程序中，使用WXML语言所提供的数据绑定功能，来完成</span><br><span class="line">此项功能。</span><br><span class="line"></span><br><span class="line">WXML通过&#123;&#123;变量名&#125;&#125;来绑定WXML文件和对应的JavaScript文件中的data对象属性。</span><br><span class="line"></span><br><span class="line">属性值也可以动态的去改变，有所不同的是，属性值必须被包裹在双引号中。需要注意的是变量名是大小写敏</span><br><span class="line">感的，也就是说&#123;&#123;name&#125;&#125;和&#123;&#123;Name&#125;&#125;是两个不同的变量。没有被定义的变量或者是被设置为</span><br><span class="line">undefined的变量不会被同步到wxml中。</span><br></pre></td></tr></table></figure>
<ul>
<li>逻辑语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过&#123;&#123;变量名&#125;&#125;语法可以使得WXML拥有动态渲染的能力，除此外还可以在&#123;&#123; &#125;&#125;内进行简单的逻辑运算。</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#125;&#125;内支持的逻辑运算：</span><br><span class="line">  * 三元运算</span><br><span class="line">  * 算数运算(类似于算数运算，支持字符串的拼接)</span><br><span class="line">  * &#123;&#123;&#125;&#125;中可以直接放置数字、字符串或者是数组</span><br></pre></td></tr></table></figure>
<ul>
<li>条件逻辑</li>
</ul>
<p><code>WXML</code>中，使用<code>wx:if=&quot;&quot;</code>来判断是否需要<strong>渲染</strong>该代码块。使用<code>wx:elif</code>和<code>wx:else</code>来添加一个<code>else</code>块。</p>
<p>因为<code>wx:if</code>是一个<strong>控制属性</strong>，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个<code>&lt;block/&gt;</code>标签将多个组件包装起来，并在上边使用<code>wx:if</code>控制属性。</p>
<ul>
<li>列表渲染</li>
</ul>
<p>在组件上使用<code>wx:for</code>控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为<code>index</code>，数组当前项的变量名默认为<code>item</code>。使用<code>wx:for-item</code>指定数组当前元素的变量名，使用<code>wx:for-index</code>指定数组当前下标的变量名(相当于命名别名)。</p>
<p>如果需要保持列表项目的特征和状态时(如：<code>&lt;input/&gt;</code>中的输入内容，<code>&lt;switch/&gt;</code>的选中状态)，需要使用<code>wx:key</code>来指定列表中项目的唯一标识符。基于在渲染时，带有<code>key</code>的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p><code>wx:key</code>的值以两种形式提供：</p>
<ol>
<li><strong>字符串</strong>，代表在<code>for</code>循环的<code>array</code>中<code>item</code>的某个<code>property</code>，该<code>property</code>的值需要是列表中<strong>唯一的字符串或数字，且不能动态改变</strong></li>
<li>保留关键字<code>this</code>代表在<code>for</code>循环中的<code>item</code>本身，这种表示需要<code>item</code>本身是一个唯一的字符串或者数字</li>
</ol>
<ul>
<li>模版</li>
</ul>
<p><code>WXML</code>提供模板(<code>template</code>)，可以在模板中定义代码片段，然后在不同的地方调用。使用<code>name</code>属性，作为模板的名字。然后在<code>&lt;template/&gt;</code>内定义代码片段。</p>
<p>定义模版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template name=&quot;msgItem&quot;&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt;</span><br><span class="line">    &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>is</code>属性，声明需要使用的模板，然后将模板所需要的<code>data</code>传入。<code>is</code>可以动态决定具体需要渲染哪个模板。</p>
<ul>
<li>引用</li>
</ul>
<p><code>WXML</code>提供两种文件引用方式<code>import</code>和<code>include</code>。</p>
<ol>
<li><code>import</code>可以在该文件中使用目标文件定义的<code>template</code>。需要注意的是<code>import</code>有作用域的概念，即只会<code>import</code>目标文件中定义的<code>template</code>，而不会<code>import</code>目标文件中<code>import</code>的<code>template</code>，简言之就是<code>import</code>不具有递归的特性</li>
<li><code>include</code>可以将目标文件中除了<code>&lt;template/&gt;`</code><wxs><code>外的整个代码引入，相当于是拷贝到</code>include`位置</wxs></li>
</ol>
<h5 id="wxss后缀的WXSS样式文件"><a href="#wxss后缀的WXSS样式文件" class="headerlink" title=".wxss后缀的WXSS样式文件"></a><code>.wxss</code>后缀的<code>WXSS</code>样式文件</h5><p><code>WXSS</code>(<code>WeiXin Style Sheets</code>)是一套用于小程序的<strong>样式语言</strong>，用于描述<code>WXML</code>的<strong>组件样式</strong>，也就是视觉上的效果。<code>WXSS</code>与<code>Web</code>开发中的<code>CSS</code>类似。</p>
<p><code>app.wxss</code>为项目的公共样式，它会被注入到小程序的每个页面。页面样式，是与<code>app.json</code>注册过的页面同名且位置同级的<code>.wxss</code>文件。其他样式，可以被项目公共样式和页面样式引用。</p>
<p>在小程序开发中，开发者不需要像<code>Web</code>开发那样去优化样式文件的请求数量，只需要考虑<strong>代码的组织</strong>即可，样式文件最终会被编译优化。</p>
<p>在<code>WXSS</code>中，引入了<code>rpx</code>(<code>responsive pixel</code>)尺寸单位，以适配不同宽度的屏幕。小程序编译后，<code>rpx</code>会做一次<code>px</code>换算。换算是以<code>375</code>个物理像素为基准，也就是在一个宽度为<code>375</code>物理像素的屏幕下，<code>1rpx = 1px</code>。</p>
<p>常用机型<code>rpx</code>尺寸换算表：</p>
<p><img src="/2019/02/07/微信小程序/常用机型rpx尺寸换算表.png" alt="常用机型rpx尺寸换算表"></p>
<p>由于<code>WXSS</code>最终会被<strong>编译打包</strong>到目标文件中，用户只需要下载一次，在使用过程中不会因为样式的引用而产生多余的文件请求。小程序中样式文件的引用格式为：<code>@import &#39;.wxss文件路径&#39;</code>。</p>
<p>小程序中<code>WXSS</code>内联样式与<code>Web</code>一样。即通过样式属性<code>style</code>进行设置。小程序支持动态更新内联样式。</p>
<p>小程序<code>WXSS</code>现阶段支持的选择器：</p>
<p><img src="/2019/02/07/微信小程序/小程序WSXX现阶段支持的选择器.png" alt="小程序WSXX现阶段支持的选择器"></p>
<p><code>WXSS</code>选择器优先级：</p>
<p><img src="/2019/02/07/微信小程序/WXSS选择器优先级.png" alt="WXSS选择器优先级"></p>
<p><strong>权重越高越优先。在优先级相同的情况下，后设置的样式优先级高于先设置的样式。</strong></p>
<h5 id="js后缀的JS脚本逻辑文件"><a href="#js后缀的JS脚本逻辑文件" class="headerlink" title=".js后缀的JS脚本逻辑文件"></a><code>.js</code>后缀的<code>JS</code>脚本逻辑文件</h5><p>小程序的主要开发语言是<code>JavaScript</code>，开发者使用<code>JavaScript</code>来<strong>开发业务逻辑</strong>以及调用小程序的<code>API</code>来完成业务需求。</p>
<p>小程序中的<code>JavaScript</code>与浏览器中的<code>JavaScript</code>和<code>NodeJS</code>中的<code>JavaScript</code>的区别：</p>
<ul>
<li><p>浏览器中的<code>JavaScript</code></p>
<ul>
<li>浏览器中的<code>JavaScript</code>是由<strong><code>ECMAScript</code></strong>和<strong><code>BOM</code>(浏览器对象模型)</strong>以及<strong><code>DOM</code>(文档对象模型)</strong>组成的，<code>Web</code>前端开发者会很熟悉这两个对象模型，它使得开发者可以去操作浏览器的一些表现，比如修改<code>URL</code>、修改页面呈现、记录数据等等。</li>
</ul>
</li>
<li><p><code>NodeJS</code>中<code>JavaScript</code></p>
<ul>
<li><code>NodeJS</code>中的<code>JavaScript</code>是由<strong><code>ECMAScript</code></strong>和<strong><code>NPM</code></strong>以及<strong><code>Native</code>模块</strong>组成，<code>NodeJS</code>的开发者会非常熟悉<code>NPM</code>的包管理系统，通过各种拓展包来快速的实现一些功能，同时通过使用一些原生的模块例如<code>FS</code>、<code>HTTP</code>、<code>OS</code>等等来拥有一些语言本身所不具有的能力。</li>
</ul>
</li>
<li><p>小程序中的<code>JavaScript</code></p>
<ul>
<li>小程序中的<code>JavaScript</code>是由<strong><code>ECMAScript</code></strong>以及<strong>小程序框架</strong>和<strong>小程序<code>API</code></strong>来实现的。同浏览器中的<code>JavaScript</code>相比没有<code>BOM</code>以及<code>DOM</code>对象，所以类似<code>JQuery</code>、<code>Zepto</code>这种浏览器类库是无法在小程序中运行起来的，同样的缺少<code>Native</code>模块和<code>NPM</code>包管理的机制，小程序中无法加载原生库，也无法直接使用大部分的<code>NPM</code>包。</li>
</ul>
</li>
</ul>
<p>除<code>JavaScript</code>不同外，不同的平台的小程序的脚本执行环境也是有所区别的。目前小程序可以运行在三大平台，<code>iOS平台</code>、<code>Android平台</code>、<code>小程序IDE</code>，这种区别主要是体现三大平台实现的<code>ECMAScript</code>的标准有所不同。</p>
<p>浏览器中，所有<code>JavaScript</code>是运行在同一个作用域下的，定义的参数或者方法可以被后续加载的脚本访问或者改写。与浏览器不同，小程序中可以将任何一个<code>JavaScript</code>文件作为一个模块，通过<code>module.exports</code>或者<code>exports</code>对外暴露接口。</p>
<p>使用<code>require(path)</code>将模块引入。</p>
<ul>
<li>脚本的执行顺序</li>
</ul>
<p>浏览器中，脚本严格按照加载的顺序执行。在小程序中脚本的执行顺序与浏览器中的有所不同，小程序的执行入口文件是<code>app.js</code>，会根据其中<code>require</code>的模块顺序决定文件的运行顺序。当<code>app.js</code>执行结束后，小程序会按照开发者在<code>app.json</code>中定义的<code>pages</code>的顺序，逐一执行。</p>
<ul>
<li>作用域</li>
</ul>
<p>小程序脚本的作用域，在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响。</p>
<p>当需要使用全局变量的时候，通过使用全局函数<code>getApp()</code>获取全局的实例，并设置相关属性值，来达到设置全局变量的目的。</p>
<p>注，脚本中全局变量的访问，对全局变量声明所在的脚本和变量所使用的脚本有顺序上的依赖关系，只有变量声明所在的脚本先执行了，变量使用的脚本才能有效的使用变量。</p>
<p>当需要保证全局的数据可以在任何文件中安全的被使用到，那么可以在<code>App()</code>中进行设置(即在<code>app.js</code>中的<code>App()</code>中进行设置)。</p>
<h3 id="小程序的宿主环境"><a href="#小程序的宿主环境" class="headerlink" title="小程序的宿主环境"></a>小程序的宿主环境</h3><p>微信客户端给小程序提供了宿主环境，小程序可以调用宿主环境提供的微信客户端的能力，这使得小程序比普通网页拥有更多的能力。</p>
<p>小程序的运行环境分成<strong>渲染层</strong>和<strong>逻辑层</strong>。<code>WXML</code>模板和<code>WXSS</code>样式工作在渲染层，<code>JS</code>脚本工作在逻辑层。在小程序中渲染层和逻辑层是分离的。</p>
<ul>
<li>通信模型</li>
</ul>
<p>小程序的渲染层和逻辑层分别由<code>2</code>个线程管理：渲染层的界面使用了<code>WebView</code>进行渲染；逻辑层采用<code>JsCore</code>线程运行<code>JS</code>脚本。一个小程序存在多个界面，所以渲染层存在多个<code>WebView</code>线程，这两个线程的通信会经由微信客户端(可用<code>Native</code>来代指微信客户端)做中转，逻辑层发送网络请求也经由<code>Native</code>转发。</p>
<ul>
<li>数据驱动</li>
</ul>
<p>通常界面视图和变量状态是相关联的，通过<strong>数据驱动</strong>可省去手动修改视图的工作。</p>
<p>小程序数据驱动的基本原理：<code>WXML</code>结构实际上等价于一棵<code>Dom</code>树，通过一个<code>JS</code>对象也可以来表达<code>Dom</code>树的结构。<code>WXML</code>可以先转成<code>JS</code>对象，然后再渲染出真正的<code>Dom</code>树。数据状态变化后，产生的<code>JS</code>对象对应的节点就会发生变化，此时可以对比前后两个<code>JS</code>对象得到变化的部分，然后把这个差异应用到原来的<code>Dom</code>树上，从而达到更新<code>UI</code>的目的。(即：状态更新的时候，通过对比前后<code>JS</code>对象变化，进而改变视图层的<code>Dom</code>树)</p>
<ul>
<li>双线程下的界面渲染</li>
</ul>
<p>小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把<code>WXML</code>转化成对应的<code>JS</code>对象，在逻辑层发生数据变更的时候，通过宿主环境提供的<code>setData</code>方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的<code>Dom</code>树上，渲染出正确的<code>UI</code>界面。</p>
<p>大致流程如下：</p>
<ol>
<li>描述界面</li>
<li>传递页面数据</li>
<li>对比应用差异重新渲染界面</li>
</ol>
<ul>
<li>小程序界面渲染的基本原理<ul>
<li>小程序的页面结构由<code>WXML</code>进行描述，<code>WXML</code>可以通过<strong>数据绑定</strong>的语法绑定从逻辑层传递过来的数据字段，这里所说的数据其实就是来自于页面<code>Page</code>构造器的<code>data</code>字段，<code>data</code>参数是页面第一次渲染时从逻辑层传递到渲染层的数据</li>
</ul>
</li>
</ul>
<h5 id="程序与页面"><a href="#程序与页面" class="headerlink" title="程序与页面"></a>程序与页面</h5><p>从逻辑组成来说，一个小程序是由多个“页面”组成的“程序”。</p>
<p>小程序与程序的区别：<strong>小程序</strong>指的是产品层面的程序；<strong>程序</strong>指的是代码层面的程序实例。</p>
<ul>
<li>程序构造器<code>App()</code></li>
</ul>
<p>宿主环境提供了<code>App()</code>构造器用来注册一个程序<code>App</code>，需要留意的是<code>App()</code>构造器必须写在项目根目录的<code>app.js</code>里，<strong><code>App</code>实例是单例对象</strong>，在其他<code>JS</code>脚本中可以使用宿主环境提供的<code>getApp()</code>来获取<strong>程序实例</strong>。</p>
<p><code>App</code>构造器接受一个<code>Object</code>参数，其中<code>onLaunch</code>/<code>onShow</code>/<code>onHide</code>三个回调是<code>App</code>实例的生命周期函数。</p>
<p><code>App</code>构造器的参数</p>
<p><img src="/2019/02/07/微信小程序/App构造器的参数.png" alt="App构造器的参数"></p>
<ul>
<li><p>程序的生命周期和打开场景</p>
<ul>
<li>程序生命周期<ul>
<li>初次进入小程序的时候，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境，初始化完毕后，微信客户端就会给<code>App</code>实例派发<code>onLaunch</code>事件，<code>App</code>构造器参数所定义的<code>onLaunch</code>方法会被调用</li>
<li>进入小程序之后，用户可以点击右上角的关闭，或者按手机设备的<code>Home</code>键离开小程序，此时小程序并没有被直接销毁，把这种情况称为“小程序进入后台状态”，App构造器参数所定义的<code>onHide</code>方法会被调用</li>
<li>当再次回到微信或者再次打开小程序时，微信客户端会把“后台”的小程序唤醒，把这种情况称为“小程序进入前台状态”，<code>App</code>构造器参数所定义的<code>onShow</code>方法会被调用</li>
</ul>
</li>
<li><code>App</code>的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，不应该从其他代码里主动调用<code>App</code>实例的生命周期函数</li>
<li><p>在微信客户端中打开小程序的途径</p>
<ul>
<li>从群聊会话里打开</li>
<li>从小程序列表中打开</li>
<li>通过微信扫一扫二维码打开</li>
<li>从另外一个小程序打开当前小程序</li>
<li><p>针对不同途径的打开方式，小程序有时需要做不同的业务处理，所以微信客户端会把打开方式带给<code>onLaunch</code>和<code>onShow</code>的调用参数<code>options</code></p>
<p><img src="/2019/02/07/微信小程序/onLaunch_onShow的参数.png" alt="onLaunch_onShow的参数"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>小程序全局数据</p>
</li>
</ul>
<p>小程序的<code>JS</code>脚本是运行在<code>JsCore</code>的线程里，小程序的每个页面各自有一个<code>WebView</code>线程进行渲染，所以小程序切换页面时，小程序逻辑层的<code>JS</code>脚本运行上下文依旧在同一个<code>JsCore</code>线程中。<code>App</code>实例是单例的，因此不同页面直接可以通过<code>App</code>实例下的属性来共享数据，<code>App</code>构造器可以传递其他参数作为全局属性以达到全局共享数据的目的。</p>
<p>要特别留意一点，所有页面的脚本逻辑都跑在同一个<code>JsCore</code>线程，页面使用<code>setTimeout</code>或者<code>setInterval</code>的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理。</p>
<ul>
<li>页面</li>
</ul>
<p>一个页面是分三部分组成：界面、配置和逻辑。<strong>界面</strong>由<code>WXML</code>文件和<code>WXSS</code>文件来负责描述，<strong>配置</strong>由<code>JSON</code>文件进行描述，<strong>页面逻辑</strong>则是由<code>JS</code>脚本文件负责。</p>
<p>一个页面的文件需要放置在同一个目录下，其中<code>WXML</code>文件和<code>JS</code>文件是必须存在的，<code>JSON</code>和<code>WXSS</code>文件是可选的。</p>
<p>页面路径需要在小程序代码根目录<code>app.json</code>中的<code>pages</code>字段声明，否则这个页面不会被注册到宿主环境中。</p>
<p>默认<code>pages</code>字段的第一个页面路径为小程序的首页。</p>
<ul>
<li>页面构造器<code>Page()</code></li>
</ul>
<p>宿主环境提供了<code>Page()</code>构造器用来注册一个小程序页面，<code>Page()</code>在页面对应的脚本<code>.js</code>中调用。<code>Page()</code>构造器接受一个<code>Object</code>参数，其中<code>data</code>属性是当前页面<code>WXML</code>模板中可以用来做数据绑定的初始数据。</p>
<p><code>Page</code>实例的生命周期函数：<code>onLoad</code>/<code>onReady</code>/<code>onShow</code>/<code>onHide</code>/<code>onUnload</code></p>
<p>页面的用户行为：<code>onPullDownRefresh</code>/<code>onReachBottom</code>/<code>onShareAppMessage</code>/<code>onPageScroll</code></p>
<p><code>Page</code>构造器的参数</p>
<p><img src="/2019/02/07/微信小程序/Page构造器的参数01.png" alt="Page构造器的参数01"><br><img src="/2019/02/07/微信小程序/Page构造器的参数02.png" alt="Page构造器的参数02"></p>
<ul>
<li><p>页面的生命周期和打开参数</p>
<ul>
<li>页面初次加载的时候，微信客户端就会给<code>Page</code>实例派发<code>onLoad</code>事件，<code>Page</code>构造器参数所定义的<code>onLoad</code>方法会被调用，<code>onLoad</code>在页面没被销毁之前只会触发<code>1</code>次，在<code>onLoad</code>的回调中，可以获取当前页面所调用的打开参数<code>option</code></li>
<li>页面显示之后，<code>Page</code>构造器参数所定义的<code>onShow</code>方法会被调用，一般从别的页面返回到当前页面时，当前页的<code>onShow</code>方法都会被调用</li>
<li>在页面初次渲染完成时，<code>Page</code>构造器参数所定义的<code>onReady</code>方法会被调用，<code>onReady</code>在页面没被销毁前只会触发<code>1</code>次，<code>onReady</code>触发时，表示页面已经准备妥当，在逻辑层就可以和视图层进行交互了</li>
<li>事件触发的时机是<code>onLoad</code>早于<code>onShow</code>，<code>onShow</code>早于<code>onReady</code></li>
<li>页面不可见时，<code>Page</code>构造器参数所定义的<code>onHide</code>方法会被调用，这种情况会在使用<code>wx.navigateTo</code>切换到其他页面、底部<code>tab</code>切换时触发</li>
<li>当前页面使用<code>wx.redirectTo</code>或<code>wx.navigateBack</code>返回到其他页时，当前页面会被微信客户端销毁回收，此时<code>Page</code>构造器参数所定义的<code>onUnload</code>方法会被调用</li>
<li><code>Page</code>的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，我们不应该在其他代码中主动调用<code>Page</code>实例的生命周期函数</li>
<li>打开参数<ul>
<li>小程序把页面的<strong>打开路径</strong>定义成<strong>页面<code>URL</code></strong>，其组成格式和网页的<code>URL</code>类似，在页面路径后使用英文<code>?</code>分隔<code>path</code>和<code>query</code>部分，<code>query</code>部分的多个参数使用<code>&amp;</code>进行分隔，参数的名字和值使用<code>key=value</code>的形式声明</li>
<li>在页面<code>Page</code>构造器里<code>onLoad</code>的<code>option</code>可以拿到当前页面的<strong>打开参数</strong>，其类型是一个<code>Object</code>，其键值对与页面<code>URL</code>上<code>query</code>键值对一一对应</li>
<li>和网页<code>URL</code>一样，页面<code>URL</code>上的<code>value</code>如果涉及特殊字符（例如：<code>&amp;</code>字符、<code>?</code>字符、中文字符等，详情参考<code>URI</code>的<code>RFC3986</code>说明 ），需要采用<code>UrlEncode</code>后再拼接到页面<code>URL</code>上</li>
</ul>
</li>
</ul>
</li>
<li><p>页面的数据</p>
</li>
</ul>
<p>宿主环境所提供的<code>Page</code>实例的原型中有<code>setData</code>函数，可以在<code>Page</code>实例下的方法调用<code>this.setData</code>把数据传递给渲染层，从而达到更新界面的目的。</p>
<p>由于小程序的渲染层和逻辑层分别在两个线程中运行，所以<code>setData</code>传递数据实际是一个异步的过程。<code>setData</code>的第二个参数是一个<code>callback</code>回调，在这次<code>setData</code>对界面渲染完毕后触发。</p>
<p><code>setData</code>其一般调用格式是<code>setData(data, callback)</code>，其中<code>data</code>是由多个<code>key: value</code>构成的<code>Object</code>对象。<code>data</code>中的<code>key</code>还可以非常灵活，以数据路径的形式给出。</p>
<p>设置修改页面数据时需要注意的点：</p>
<ol>
<li>直接修改<code>Page</code>实例的<code>this.data</code>而不调用<code>this.setData</code>是无法改变页面的状态的，还会造成数据不一致</li>
<li>由于<code>setData</code>是需要两个线程的一些通信消耗，<strong>为了提高性能，每次设置的数据不应超过<code>1024kB</code></strong></li>
<li>不要把<code>data</code>中的任意一项的<code>value</code>设为<code>undefined</code>，否则可能会引起一些不可预料的<code>bug</code></li>
</ol>
<p><strong>提高小程序渲染性能遵循的原则：每次只设置需要改变的最小单位数据。</strong></p>
<ul>
<li>页面的用户行为</li>
</ul>
<p>小程序宿主环境提供了四个和页面相关的用户行为回调：</p>
<ol>
<li>下拉刷新<code>onPullDownRefresh</code><ul>
<li>监听用户下拉刷新事件，需要在<code>app.json</code>的<code>window</code>选项中或页面配置<code>page.json</code>中设置<code>enablePullDownRefresh</code>为<code>true</code>。当处理完数据刷新后，<code>wx.stopPullDownRefresh</code>可以停止当前页面的下拉刷新</li>
</ul>
</li>
<li>上拉触底<code>onReachBottom</code><ul>
<li>监听用户上拉触底事件。可以在<code>app.json</code>的<code>window</code>选项中或页面配置<code>page.json</code>中设置触发距离<code>onReachBottomDistance</code>。在触发距离内滑动期间，本事件只会被触发一次</li>
</ul>
</li>
<li>页面滚动<code>onPageScroll</code><ul>
<li>监听用户滑动页面事件，参数为<code>Object</code>，包含<code>scrollTop</code>字段，表示页面在垂直方向已滚动的距离(单位<code>px</code>)</li>
</ul>
</li>
<li>用户转发<code>onShareAppMessage</code><ul>
<li>只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮，在用户点击转发按钮的时候会调用，此事件需要<code>return</code>一个<code>Object</code>，包含<code>title</code>和<code>path</code>两个字段，用于自定义转发内容</li>
</ul>
</li>
</ol>
<ul>
<li>页面跳转和路由</li>
</ul>
<p>小程序通过<strong>页面栈</strong>来管理页面。(页面栈即是页面层级)</p>
<p>一个小程序拥有多个页面，可以通过<code>wx.navigateTo</code>推入一个新的页面，新的页面会进入页面栈内。</p>
<p>小程序宿主环境限制了页面栈的最大层级为<code>10</code>层，也就是当页面栈到达<code>10</code>层之后就没有办法再推入新的页面了。</p>
<p>和导航相关的<code>API</code>：(基于已有的页面栈<code>[pageA,pageB,pageC]</code>进行描述)</p>
<ol>
<li>使用<code>wx.navigateTo({url: &#39;pageD&#39;})</code>可以往当前页面栈多推入一个<code>pageD</code>，此时页面栈变成<code>[pageA, pageB, pageC, pageD]</code></li>
<li>使用<code>wx.navigateBack()</code>可以退出当前页面栈的最顶上页面，此时页面栈变成<code>[pageA, pageB, pageC]</code></li>
<li>使用<code>wx.redirectTo({url: &#39;pageE&#39;})</code>是替换当前页变成<code>pageE</code>，此时页面栈变成<code>[pageA, pageB, pageE]</code>，当页面栈到达<code>10</code>层没法再新增的时候，往往就是使用<code>redirectTo</code>这个<code>API</code>进行页面跳转</li>
<li>小程序提供了原生的<code>Tabbar</code>支持，我们可以在<code>app.json</code>声明<code>tabBar</code>字段来定义<code>Tabbar</code>页<ul>
<li>可以在有<code>Tabbar</code>页的页面栈中，使用<code>wx.switchTab({url: &#39;pageF&#39;})</code>，此时原来的页面栈会被清空(除了已经声明为<code>Tabbar</code>页<code>pageA</code>外其他页面会被销毁)，然后会切到<code>pageF</code>所在的<code>tab</code>页面，页面栈变成<code>[pageF]</code>，此时点击<code>Tab_PageA</code>切回到<code>pageA</code>时，<code>pageA</code>不会再触发<code>onLoad</code>，因为<code>pageA</code>没有被销毁</li>
<li><code>Tabbar</code>页面初始化之后不会被销毁</li>
</ul>
</li>
<li>可以使用<code>wx.reLaunch({url: &#39;pageH&#39;})</code>重启小程序，并且打开<code>pageH</code>，此时页面栈为<code>[pageH]</code></li>
</ol>
<p><strong>注：<code>wx.navigateTo</code>和<code>wx.redirectTo</code>只能打开非<code>TabBar</code>页面，<code>wx.switchTab</code>只能打开<code>Tabbar</code>页面</strong></p>
<p><a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0004eec99acc808b00861a5bd5280a" target="_blank" rel="noopener">页面路由及对应的页面生命周期函数详情</a>见文档底部</p>
<h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><p>组件是小程序页面的基本组成单元。组件是在<code>WXML</code>模板文件声明中使用的。小程序使用标签名来引用一个组件，通常包含开始标签和结束标签，该标签的属性用来描述该组件。组件由小程序的宿主环境提供。</p>
<p>所有组件名和属性都是小写，多个单词会以英文横杠<code>-</code>进行连接。</p>
<p>组件共有属性(主要涉及样式和事件绑定)</p>
<p><img src="/2019/02/07/微信小程序/组件共有属性.png" alt="组件共有属性"></p>
<p>事件绑定(<code>bind/catch</code>)详情，见下文<strong>事件</strong>。</p>
<p>各组件详细属性<a href="https://developers.weixin.qq.com/miniprogram/dev/component/" target="_blank" rel="noopener">见文档</a></p>
<h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>宿主环境提供了丰富的<code>API</code>，可以很方便调起微信提供的能力。调用宿主环境<code>API</code>的<code>wx</code>对象是小程序的宿主环境所提供的全局对象。几乎所有小程序的<code>API</code>都挂载在<code>wx</code>对象底下。</p>
<ul>
<li><code>API</code>调用的一般约定<ol>
<li><code>wx.on*</code>开头的<code>API</code>是监听某个事件发生的<code>API</code>接口，接受一个<code>Callback</code>函数作为参数。当该事件触发时，会调用<code>Callback</code>函数</li>
<li>如未特殊约定，多数<code>API</code>接口为异步接口，都接受一个<code>Object</code>(通常是<code>{}</code>)作为参数</li>
<li><code>API</code>的<code>Object</code>参数一般由<code>success</code>、<code>fail</code>、<code>complete</code>三个回调来接收接口调用结果</li>
<li><code>wx.get*</code>开头的<code>API</code>是获取宿主环境数据的接口</li>
<li><code>wx.set*</code>开头的<code>API</code>是写入数据到宿主环境的接口</li>
</ol>
</li>
</ul>
<p>各<code>API</code>详情<a href="https://developers.weixin.qq.com/miniprogram/dev/api/" target="_blank" rel="noopener">见文档</a></p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件的定义：在小程序里，把“用户在渲染层(<code>UI</code>界面)的行为反馈”以及“组件的部分状态反馈”抽象为渲染层传递给逻辑层的“事件”。</p>
<ul>
<li><p>事件绑定及对应处理函数的调用流程</p>
<ul>
<li>事件一般是通过<code>bindtap</code>这个属性绑定在组件上的，同时在当前页面的<code>Page</code>构造器中定义对应的事件处理函数<code>tapHandleFunction</code>，当用户点击已绑定事件处理的区域时，达到触发条件生成事件<code>tap</code>，该事件处理函数<code>tapHandleFunction</code>会被执行，同时还会收到一个事件对象<code>event</code></li>
</ul>
</li>
<li><p>事件类型和事件对象</p>
</li>
</ul>
<p>当事件回调触发的时候，会收到一个事件对象。</p>
<p>常见事件类型和事件对象<a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=000846df9a03909b0086a50025180a" target="_blank" rel="noopener">见文档</a></p>
<ul>
<li>事件绑定与冒泡捕获</li>
</ul>
<p>事件绑定的写法和组件属性一致，以<code>key=&quot;value&quot;</code>的形式，其中：</p>
<ol>
<li><code>key</code>以<code>bind</code>或者<code>catch</code>开头，然后跟上事件的类型，如<code>bindtap</code>、<code>catchtouchstart</code>。<code>bind</code>和<code>catch</code>后可以紧跟一个冒号，其含义不变，如<code>bind:tap</code>、<code>catch:touchstart</code>。同时<code>bind</code>和<code>catch</code>前还可以加上<code>capture-</code>来表示捕获阶段</li>
<li><code>value</code>是一个字符串，需要在对应的页面<code>Page</code>构造器中定义同名的函数，否则触发事件时在控制台会有报错信息</li>
</ol>
<p><code>bind</code>和<code>capture-bind</code>的含义分别代表事件的<strong>冒泡阶段</strong>和<strong>捕获阶段</strong>。先是事件捕获，再是事件冒泡阶段。</p>
<p><code>bind</code>事件绑定不会阻止冒泡事件向上冒泡，<code>catch</code>事件绑定可以阻止冒泡事件向上冒泡。<code>capture-catch</code>将中断捕获阶段和取消冒泡阶段。可以使用<code>catch</code>阻止事件的传递。</p>
<ul>
<li>兼容</li>
</ul>
<p>可以使用<code>wx.getSystemInfo</code>或者<code>wx.getSystemInfoSync</code>来获取手机品牌、操作系统版本号、微信版本号以及小程序基础库版本号等，通过这些信息，可以针对不同平台做差异化的服务，进而实现兼容。</p>
<p>随着宿主环境的更新，新版本的宿主环境会提供一些新的<code>API</code>，你可以通过判断此<code>API</code>是否存在来做程序上的兼容。</p>
<p>小程序还提供了<code>wx.canIUse</code>这个<code>API</code>，用于判断接口或者组件在当前宿主环境是否可用，其参数格式为: <code>${API}.${method}.${param}.${options}</code>或者<code>${component}.${attribute}.${option}</code>。</p>
<h3 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h3><h5 id="基本的布局方法-–-Flex布局"><a href="#基本的布局方法-–-Flex布局" class="headerlink" title="基本的布局方法 – Flex布局"></a>基本的布局方法 – <code>Flex</code>布局</h5><p><code>Flex</code>布局中约定的术语：采用<code>flex</code>布局的元素，简称为“容器”，以<code>container</code>表示容器的类名。容器内的元素简称为“项目”，以<code>item</code>表示项目的类名。</p>
<p><code>Flex</code>，目的是提供一种更加灵活的布局模型，使容器能通过改变里面项目的高宽、顺序，来对可用空间实现最佳的填充，方便适配不同大小的内容区域。</p>
<p><code>Flex</code>不单是一个属性，它包含了一套新的属性集。属性集包括用于设置容器，和用于设置项目两部分。</p>
<p>属性集中设置容器的属性：</p>
<p><img src="/2019/02/07/微信小程序/属性集中设置容器的属性.png" alt="属性集中设置容器的属性"></p>
<p>属性集中设置项目的属性：</p>
<p><img src="/2019/02/07/微信小程序/属性集中设置项目的属性.png" alt="属性集中设置项目的属性"></p>
<p>坐标轴：默认的情况下，水平方向的是<strong>主轴(<code>main axis</code>)</strong>，垂直方向的是<strong>交叉轴(<code>cross axis</code>)</strong>。项目是在主轴上排列，排满后在交叉轴方向换行。需要注意的是，交叉轴垂直于主轴，它的方向取决于主轴方向。</p>
<h5 id="常见的交互反馈"><a href="#常见的交互反馈" class="headerlink" title="常见的交互反馈"></a>常见的交互反馈</h5><p><code>Toast</code>提示默认<code>1.5</code>秒后自动消失。</p>
<p>需注意，不应该把<code>Toast</code>用于错误提示，因为错误提示需要明确告知用户具体原因，因此不适合用这种一闪而过的<code>Toast</code>弹出式提示。一般需要用户明确知晓操作结果状态的话，会使用模态对话框来提示，同时附带下一步操作的指引。</p>
<h5 id="发起HTTPS网络通信"><a href="#发起HTTPS网络通信" class="headerlink" title="发起HTTPS网络通信"></a>发起HTTPS网络通信</h5><p>小程序宿主环境要求<code>request</code>发起的网络请求必须是<code>https</code>协议请求，因此开发者服务器必须提供<code>HTTPS</code>服务的接口，同时为了保证小程序不乱用任意域名的服务，<code>wx.request</code>请求的域名需要在小程序管理平台进行配置，如果小程序正式版使用<code>wx.request</code>请求未配置的域名，在控制台会有相应的报错。</p>
<p><code>wx.request</code>的<code>method</code>参数需大写，有效值有：<code>OPTIONS</code>,<code>GET</code>,<code>HEAD</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>,<code>TRACE</code>,<code>CONNECT</code></p>
<p>接口的兼容：要兼容旧版本接口的数据格式，对于新版本的接口所提供的新特性，是在旧版本接口的基础上进行新特性字段的添加。</p>
<p>通过<code>wx.request</code>这个<code>API</code>，有两种方法把数据传递到服务器：通过<code>url</code>上的参数以及通过<code>data</code>参数。注，<code>url</code>是有长度限制的，其最大长度是<code>1024</code>字节，同时<code>url</code>上的参数需要拼接到字符串里，参数的值还需要做一次<code>urlEncode</code>。向服务端发送的数据超过<code>1024</code>字节时，就要采用<code>HTTP POST</code>的形式，此时传递的数据就必须要使用<code>data</code>参数。因此，需要传递数据时，使用<code>data</code>参数来传递。</p>
<p><code>success</code>回调的参数<code>data</code>字段类型是根据<code>header[&#39;content-type&#39;]</code>决定的，默认<code>header[&#39;content-type&#39;]</code>是<code>application/json</code>，在触发<code>success</code>回调前，小程序宿主环境会对<code>data</code>字段的值做<code>JSON</code>解析，如果解析成功，那么<code>data</code>字段的值会被设置成解析后的<code>Object</code>对象，其他情况<code>data</code>字段都是<code>String</code>类型，其值为<code>HTTP</code>回包包体。</p>
<p>小程序<code>request</code>默认的请求超时时间是<code>60</code>秒。通常的交互体验下，请求等待超过<code>3</code>秒，就需要给用户明确的服务不可用提示。小程序中的时间单位是毫秒。</p>
<h5 id="本地数据缓存"><a href="#本地数据缓存" class="headerlink" title="本地数据缓存"></a>本地数据缓存</h5><ul>
<li>缓存限制和隔离</li>
</ul>
<p>小程序宿主环境会管理不同小程序的数据缓存，不同小程序的本地缓存空间是分开的，每个小程序的缓存空间上限为<code>10MB</code>，如果当前缓存已经达到<code>10MB</code>，再通过<code>wx.setStorage</code>写入缓存会触发<code>fail</code>回调。</p>
<p>由于本地缓存是存放在当前设备，用户换设备之后无法从另一个设备读取到当前设备数据，因此用户的关键信息不建议只存在本地缓存，应该把数据放到服务器端进行持久化存储。</p>
<h3 id="小程序的发布"><a href="#小程序的发布" class="headerlink" title="小程序的发布"></a>小程序的发布</h3><p>对用户体验进行评估，可依据以下<code>9</code>点基础设计原则进行参考：</p>
<ol>
<li>导航清晰<ul>
<li>导航是确保用户在网页中浏览跳转时不迷路的最关键因素</li>
<li>导航需要告诉用户，当前在哪，可以去哪，如何回去等问题</li>
</ul>
</li>
<li>流程明确<ul>
<li>当前页面只设置了单一任务，且不出现目标流程之外的内容</li>
<li>完成任务的操作简单</li>
</ul>
</li>
<li>重点突出<ul>
<li>页面有明确的重点，便于用户进入页面时能快速理解页面的内容</li>
</ul>
</li>
<li>符合预期<ul>
<li>在产品设计阶段便将自身信息架构和模型与用户的心理模型匹配</li>
<li>便于用户能够依据以往的使用经验或其他生活经验，降低使用的理解和学习成本</li>
</ul>
</li>
<li>等待与反馈<ul>
<li>因页面过长时间的等待会引起不良情绪，在需要加载等待时，需要用明确的等待状态告知用户，以舒缓用户在等待时期的不良情绪</li>
</ul>
</li>
<li>异常处理<ul>
<li>在出现异常的时候需要给予用户清晰的状态提示，并告知解决方案，使其有路可退</li>
</ul>
</li>
<li>内容和文案准确友好<ul>
<li>使用的语言应当简洁，礼貌并容易被用户理解</li>
</ul>
</li>
<li>和谐统一<ul>
<li>设计风格应该是统一、和谐且具有延续性的</li>
</ul>
</li>
<li>平台适配</li>
</ol>
<ul>
<li>发布</li>
</ul>
<p>发布有两种模式：全量发布和分阶段发布。全量发布是指当点击发布之后，所有用户访问小程序时都会使用当前最新的发布版本。分阶段发布是指分不同时间段来控制部分用户使用最新的发布版本，分阶段发布我们也称为灰度发布。由于微信客户端存有旧版本小程序包缓存，微信客户端会在某些特定的时机异步去更新最新的小程序包，所以一般是全量发布的<code>24</code>小时后，所有用户才会真正使用到最新版的小程序。</p>
<h3 id="底层框架"><a href="#底层框架" class="headerlink" title="底层框架"></a>底层框架</h3><p>小程序界面主要由成熟的<code>Web</code>技术渲染，辅之以大量的接口提供丰富的客户端原生能力。每个小程序页面都是用不同的<code>WebView</code>去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个<code>WebView</code>的任务过于繁重。</p>
<ul>
<li>管控与安全</li>
</ul>
<p>基于<code>Web</code>技术来渲染小程序是存在一些不可控因素和安全风险的。这是因为<code>Web</code>技术是非常开放灵活的，可以利用<code>JavaScript</code>脚本随意地跳转网页或者改变界面上的任意内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小程序是一个多WebView的架构，每一个小程序页面都是不同的WebView渲染后显示的。</span><br></pre></td></tr></table></figure>
<ul>
<li>天生的延时</li>
</ul>
<p>由于小程序是基于双线程模型的，意味着任何数据传递都是线程间的通信，因此会有一定的延时。在小程序架构里，逻辑层和渲染层间数据传递的通信是异步的。异步会使得各部分的运行时序变得复杂一些，小程序框架中已处理好，开发者只需要理解生命周期，以及控制合适的时机更新<code>UI</code>即可。</p>
<p>除了逻辑层与渲染层之间的通信有延时，各层(逻辑层、渲染层)与客户端原生交互同样是有延时的。以逻辑层为例，开发者的代码是跑在逻辑层这个线程之上，而客户端原生是跑在微信主线程之上，所以注册给逻辑层有关客户端能力的接口，实际上也是跟微信主线程之间的通信，同样意味着有延时。这也是大部分提供的接口都是异步的原因。</p>
<h5 id="组件系统"><a href="#组件系统" class="headerlink" title="组件系统"></a>组件系统</h5><ul>
<li><code>Exparser</code>框架<ul>
<li><code>Exparser</code>是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由<code>Exparser</code>组织管理</li>
<li><code>Exparser</code>会维护整个页面的<strong>节点树</strong>相关信息，包括节点的属性、事件绑定等</li>
<li>小程序中，所有节点树相关的操作都依赖于<code>Exparser</code>，包括<code>WXML</code>到页面最终节点树的构建、<code>createSelectorQuery</code>调用和自定义组件特性等</li>
</ul>
</li>
</ul>
<p>各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、<code>setData</code>调用，<code>createSelectorQuery</code>也将运行在<code>ShadowTree</code>(组件节点树)的层面上。</p>
<p>小程序中组件的使用，需要经过注册和实例化。</p>
<ul>
<li>组件间通信</li>
</ul>
<p>不同组件实例间的通信有<code>WXML</code>属性值传递、事件系统、<code>selectComponent</code>和<code>relations</code>等方式。其中，<strong><code>WXML</code>属性值传递</strong>是从<strong>父组件向子组件</strong>的基本通信方式，而<strong>事件系统</strong>是从<strong>子组件向父组件</strong>的基本通信方式。(<code>WXML</code>属性值传递是父到子；事件系统是子到父)。事件可以分为冒泡事件和非冒泡事件。冒泡事件还可以划分为在<code>ShadowTree</code>(组件节点树)上冒泡的事件和在<code>ComposedTree</code>(页面节点数)上冒泡的事件。如果在<code>ShadowTree</code>上冒泡，则冒泡只会经过这个组件<code>ShadowTree</code>上的节点，这样可以有效控制事件冒泡经过的范围。</p>
<p>在自定义组件中使用<code>triggerEvent</code>触发事件时，可以指定事件的<code>bubbles</code>、<code>composed</code>和<code>capturePhase</code>属性，用于标注事件的冒泡性质。</p>
<ul>
<li>原生组件</li>
</ul>
<p>在内置组件中，有一些组件较为特殊，它们并不完全在<code>Exparser</code>的渲染体系下，而是由客户端原生参与组件的渲染，这类组件我们称为“原生组件”,这也是小程序<code>Hybrid</code>技术的一个应用。</p>
<p>原生组件的层级会比所有在<code>WebView</code>层渲染的普通组件要高，原生组件之间的层级就可以按照一定的规则控制。</p>
<p>原生组件渲染限制：原生组件脱离在<code>WebView</code>渲染流程外，这带来了一些限制。最主要的限制是一些<code>CSS</code>样式无法应用于原生组件，例如，不能在父级节点使用<code>overflow:hidden</code>来裁剪原生组件的显示区域；不能使用<code>transformrotate</code>让原生组件产生旋转等。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>小程序的启动流程如下</p>
<p><img src="/2019/02/07/微信小程序/小程序的启动流程.png" alt="小程序的启动流程"></p>
<p>在小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。</p>
<ul>
<li><p>下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包</p>
<ul>
<li>从开发者的角度看，控制代码包大小有助于减少小程序的启动时间</li>
<li>常规控制代码包大小的方法有以下几种<ul>
<li>精简代码，去掉不必要的<code>WXML</code>结构和未使用的<code>WXSS</code>定义</li>
<li>减少在代码包中直接嵌入的资源文件</li>
<li>压缩图片，使用适当的图片格式</li>
<li>如果小程序比较复杂，优化后的代码总量可能仍然比较大，此时可以采用<strong>分包加载</strong>的方式进行优化</li>
</ul>
</li>
</ul>
</li>
<li><p>页面层级准备</p>
</li>
</ul>
<p>在视图层内，小程序的每一个页面都独立运行在一个页面层级上。小程序启动时仅有一个页面层级，每次调用<code>wx.navigateTo</code>都会创建一个新的页面层级；相对地，<code>wx.navigateBack</code>会销毁一个页面层级。对于<code>wx.redirectTo</code>，这个调用不会打开一个新的页面层级，而是将当前页面层级重新初始化：重新传入页面的初始数据、路径等，视图层清空当前页面层级的渲染结果然后重新渲染页面。</p>
<p>页面层级的准备工作分为三个阶段：第一阶段是启动一个<code>WebView</code>，在<code>iOS</code>和<code>Android</code>系统上，操作系统启动<code>WebView</code>都需要一小段时间；第二阶段是在<code>WebView</code>中初始化基础库，此时还会进行一些基础库内部优化，以提升页面渲染性能；第三阶段是注入小程序<code>WXML</code>结构和<code>WXSS</code>样式，使小程序能在接收到页面初始数据之后马上开始渲染页面(这一阶段无法在小程序启动前执行)。</p>
<p>页面层级准备过程如下图：</p>
<p><img src="/2019/02/07/微信小程序/页面层级准备过程图.png" alt="页面层级准备过程图"></p>
<ul>
<li>数据通信</li>
</ul>
<p>小程序中，页面的数据通信，体现在逻辑层向视图层发送页面数据(<code>data</code>和<code>setData</code>的内容)，视图层向逻辑层反馈用户事件。</p>
<p>页面初始数据通信时序图：</p>
<p><img src="/2019/02/07/微信小程序/页面初始数据通信时序图.png" alt="页面初始数据通信时序图"></p>
<p>页面初始化的时间大致由<strong>页面初始数据通信时间</strong>和<strong>初始渲染时间</strong>两部分构成。传输时间与数据量大体上呈现正相关关系，传输过大的数据将使这一时间显著增加。因而减少传输数据量是降低数据传输时间的有效方式。</p>
<p>为了提升数据更新的性能，开发者在执行<code>setData</code>调用时，最好遵循以下原则：</p>
<ol>
<li>不要过于频繁调用<code>setData</code>，应考虑将多次<code>setData</code>合并成一次<code>setData</code>调用</li>
<li>数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用<code>setData</code>来设置这些数据</li>
<li>与界面渲染无关的数据最好不要设置在<code>data</code>中，可以考虑设置在<code>page</code>对象的其他字段下</li>
</ol>
<p>事件通信有延迟，降低延迟时间的方法主要有以下两个：</p>
<ol>
<li>去掉不必要的事件绑定(<code>WXML</code>中的<code>bind</code>和<code>catch</code>)，从而减少通信的数据量和次数</li>
<li>事件绑定时需要传输<code>target</code>和<code>currentTarget</code>的<code>dataset</code>，因而不要在节点的<code>data</code>前缀属性中放置过大的数据</li>
</ol>
<ul>
<li>视图层渲染</li>
</ul>
<p>视图层在接收到初始数据(<code>data</code>)和更新数据(<code>setData</code>数据)时，需要进行视图层渲染。在一个页面的生命周期中，视图层会收到一份初始数据和多份更新数据。收到初始数据时需要执行初始渲染，每次收到更新数据时需要执行重渲染。</p>
<p>渲染流程中，时间开销大体上与节点树中节点的总量成正比例关系。因而减少<code>WXML</code>中节点的数量可以有效降低初始渲染和重渲染的时间开销，提升渲染性能。</p>
<p>重渲染的机制：初始渲染中得到的<code>data</code>和当前节点树会保留下来用于重渲染。每次重渲染时，将<code>data</code>和<code>setData</code>数据套用在<code>WXML</code>片段上，得到一个新节点树。然后将新节点树与当前节点树进行比较，这样可以得到哪些节点的哪些属性需要更新、哪些节点需要添加或移除。最后，将<code>setData</code>数据合并到<code>data</code>中，并用新节点树替换旧节点树，用于下一次重渲染。</p>
<p>重渲染流程图如下：</p>
<p><img src="/2019/02/07/微信小程序/视图层重渲染流程图.png" alt="视图层重渲染流程图"></p>
<p>小程序优化策略可分为以下三点：</p>
<ol>
<li>精简代码，降低<code>WXML</code>结构和<code>JS</code>代码的复杂性</li>
<li>合理使用<code>setData</code>调用，减少<code>setData</code>次数和数据量</li>
<li>必要时使用分包优化</li>
</ol>
<h3 id="小程序基础库"><a href="#小程序基础库" class="headerlink" title="小程序基础库"></a>小程序基础库</h3><p>由于小程序的渲染层和逻辑层是两个线程管理，渲染层<code>WebView</code>层注入的称为<code>WebView</code>基础库，逻辑层注入的称为<code>AppService</code>基础库。</p>
<p>小程序基础库分为：<code>WebView</code>基础库、<code>AppService</code>基础库</p>
<p>小程序的基础库，会被提前内置在微信客户端。这样做有以下两点好处：</p>
<ol>
<li>降低业务小程序的代码包大小</li>
<li>可以单独修复基础库中的<code>Bug</code>，无需修改到业务小程序的代码包</li>
</ol>
<ul>
<li>异常</li>
</ul>
<p>小程序基础库在<code>WebView</code>侧使用<code>window.onerror</code>方案进行捕捉异常，在逻辑层<code>AppService</code>侧通过把<code>App</code>实例和<code>Page</code>实例的各个生命周期等方法包裹在<code>try-catch</code>里进行捕捉异常。同时在<code>App</code>构造器里提供了<code>onError</code>的回调，当业务代码运行产生异常时，这个回调被触发，同时能够拿到异常的具体信息，开发者自己根据业务情况处理对应的容错逻辑。</p>
<h3 id="微信开发者工具"><a href="#微信开发者工具" class="headerlink" title="微信开发者工具"></a>微信开发者工具</h3><p>微信开发者工具和微信客户端都无法直接运行小程序的源码，因此我们需要对小程序的源码进行编译。<strong>代码编译过程包括本地预处理、本地编译和服务器编译。</strong>为了快速预览，微信开发者工具模拟器运行的代码只经过本地预处理、本地编译，没有服务器编译过程，而微信客户端运行的代码是额外经过服务器编译的。</p>
<ul>
<li>编译<code>WXML</code></li>
</ul>
<p>小程序的渲染层的运行环境是一个<code>WebView</code>，而<code>WebView</code>无法直接理解<code>WXML</code>标签，所以需要经过编译。微信开发者工具内置了一个二进制的<code>WXML</code>编译器，这个编译器接受<strong><code>WXML</code>代码文件列表</strong>，处理完成之后输出<code>JavaScript</code>代码，这段代码是各个页面的结构生成函数。</p>
<h3 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h3><ul>
<li><p><code>wxs</code></p>
<ul>
<li><code>wxs</code>是对<code>JavaScript</code>做了一些封装和限制</li>
<li><code>wxs</code>修饰的变量对外是不可见的，可以通过<code>exports</code>对外暴露对应的变量</li>
<li><code>wxs</code>的注释<ul>
<li>单行注释 - <code>//</code></li>
<li>多行注释 - <code>/**/</code></li>
<li>结尾注释 - <code>/*</code></li>
</ul>
</li>
</ul>
</li>
<li><p>小程序的开发框架，称为<code>MINA</code>框架</p>
<ul>
<li>有三层：<code>View</code>(视图层)、<code>App Service</code>(逻辑层)、<code>Native</code>(系统层)</li>
</ul>
</li>
<li><p>小程序的启动</p>
<ul>
<li>冷启动<ul>
<li>小程序首次被打开</li>
<li>打开后长期置于后台状态(该时间一般维持<code>5</code>分钟)被系统给销毁后再次被打开</li>
<li>短时间内连续收到系统的两次告警(这个时间间隔是<code>5</code>秒)微信就会主动销毁小程序</li>
</ul>
</li>
<li>热启动，小程序已经被打开过，从后台状态切换到前台状态的启动</li>
</ul>
</li>
<li><p>小程序的加载</p>
<ul>
<li><code>CDN</code><ul>
<li>内容分发网络</li>
<li>作用：把请求的内容，分发到距离用户最近的网路节点服务器，提高用户访问的响应速度以及成功率，解决带宽及服务器带来的一些延迟问题</li>
</ul>
</li>
</ul>
</li>
<li><p>小程序的生命周期</p>
<ul>
<li>小程序应用生命周期<ul>
<li>四个回调方法<ul>
<li>onLaunch</li>
<li>onShow</li>
<li>onHide</li>
<li>onError</li>
</ul>
</li>
<li>globalData是小程序应用的全局数据</li>
</ul>
</li>
<li>小程序页面生命周期<ul>
<li>五个回调方法<ul>
<li>onLoad - 在页面没被销毁之前只会被调用一次</li>
<li>onShow</li>
<li>onReady - 在页面没被销毁之前只会被调用一次</li>
<li>onHide</li>
<li>onUnload</li>
</ul>
</li>
<li>data是小程序当前页面的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>页面路由</p>
<ul>
<li>多页面小程序，页面间的路由通过框架来管理，框架以栈的形式，维护了小程序的所有页面</li>
<li>六种路由方式<ul>
<li>初始化</li>
<li>打开新页面</li>
<li>页面重定向</li>
<li>页面返回</li>
<li><code>Tab</code>切换</li>
<li>重加载</li>
</ul>
</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li>通过事件来让视图层和逻辑层进行通讯</li>
<li>事件是视图层到逻辑层的通讯方式</li>
<li>事件可以将用户的行为反馈到逻辑层进行处理</li>
<li>事件可以绑定在组件上，触发事件后，就会执行逻辑层中对应的事件处理函数</li>
<li>事件对象可以携带额外信息</li>
<li>小程序中有事件模型的概念<ul>
<li>事件捕获阶段<ul>
<li>可捕获事件</li>
<li><code>tap</code> &lt; 350毫秒</li>
<li><code>touchstart</code></li>
<li><code>touchmove</code></li>
<li><code>touchcancel</code></li>
<li><code>touchend</code></li>
<li><code>longpress</code> &gt; 350毫秒 - 推荐使用</li>
<li><code>longtap</code> &gt; 350毫秒</li>
</ul>
</li>
<li>事件处理阶段</li>
<li>事件冒泡阶段<ul>
<li>可冒泡事件</li>
<li><code>touchstart</code></li>
<li><code>longtap</code></li>
<li><code>touchmove</code></li>
<li><code>transitionend</code></li>
<li><code>touchcancel</code></li>
<li><code>animationstart</code></li>
<li><code>touchend</code></li>
<li><code>animationiteration</code></li>
<li><code>tap</code></li>
<li><code>animationend</code></li>
<li><code>longpress</code></li>
<li><code>touchforcechange</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>富文本组件(<code>rich-text</code>)，可以用来绘制表格</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/07/iOS崩溃调试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/07/iOS崩溃调试/" class="post-title-link" itemprop="url">iOS崩溃调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-07 10:56:54" itemprop="dateCreated datePublished" datetime="2019-02-07T10:56:54+08:00">2019-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根据<code>.ips</code>文件进行分析。</p>
<ul>
<li>准备</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建一个临时文件夹，将.ips文件更改为后缀为.crash的文件放入临时文</span><br><span class="line">件夹，找到.ips文件对应的.xcarchive文件，查看内容找到.app</span><br><span class="line">和.dSYM文件，都放入临时文件夹。</span><br></pre></td></tr></table></figure>
<ul>
<li>校验</li>
</ul>
<p><strong>需要校验.ipa，.crash(.ips)，.dSYM的一致性。</strong></p>
<p>方法：通过验证构建版本的UUID和crash信息包含的UUID是否一致。</p>
<p>步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.查看.crash日志中包含的UUID</span><br><span class="line">cd到.crash所在文件夹，使用指令：</span><br><span class="line">grep --after-context=2 &quot;Binary Images:” xxx.crash</span><br><span class="line">（Binary Images:为.crash文件中的特定字符串，context=2取Binary Images:后的前两行内容）</span><br><span class="line">&lt;&gt;中的内容即为UUID</span><br><span class="line"></span><br><span class="line">2.查询.ipa的UUID</span><br><span class="line">解压.ipa文件（将原来.ipa文件后缀改为.zip解压出Payload文件夹），cd到解压后的文件夹，使用指令：</span><br><span class="line">xcrun dwarfdump --uuid xxx.app/xxx</span><br><span class="line"></span><br><span class="line">3.查询.dSYM文件的UUID</span><br><span class="line">找到.xcarchive（显示包内容）中的.dSYM文件，使用指令：</span><br><span class="line">dwarfdump --uuid （.dSYM所在路径）</span><br></pre></td></tr></table></figure>
<ul>
<li>将崩溃日志符号化</li>
</ul>
<p>使用xcode自带的符号化工具（两种方式）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line">1.1: 找xcode自带的符号化工具（symbolicatecrash）：</span><br><span class="line">find /Applications/Xcode.app -name symbolicatecrash -type f</span><br><span class="line">将查询结果中/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash该路径下的symbolicatecrash工具，</span><br><span class="line">放入临时文件夹，此时临时文件夹中有：symbolicatecrash，.crash，.app，.dSYM。</span><br><span class="line"></span><br><span class="line">1.2: 在终端cd到临时文件夹：</span><br><span class="line">先export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer，</span><br><span class="line">再./symbolicatecrash xxx.crash xxx.app &gt; xxx.log，执行完该命令后，会在临时文件夹中生成xxx.log文件（即为崩溃日志符号化后的文件）</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">临时文件夹中只有.crash，.app，.dSYM时，</span><br><span class="line">先export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer，</span><br><span class="line">再/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash xxx.crash xxx.app &gt; xxx.log，执行完该命令后，</span><br><span class="line">会在临时文件夹中生成xxx.log文件（即为崩溃日志符号化后的文件）</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
