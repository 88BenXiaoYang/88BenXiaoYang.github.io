<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ben&#39;Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Ben&#39;Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ben&#39;Blog">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Ben'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ben'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工欲善其事，必先利其器</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/06/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/06/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-06 16:38:40" itemprop="dateCreated datePublished" datetime="2019-02-06T16:38:40+08:00">2019-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h5><ul>
<li><p>进入数据库（登录mysql）：<code>mysql -u root -p</code></p>
</li>
<li><p>修改密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set password for ‘root’@‘localhost’ = password(‘新密码’);</span><br></pre></td></tr></table></figure>
<ul>
<li>修改密码归类（四种在MySQL中修改root密码的方法）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1: 用SET PASSWORD命令</span><br><span class="line">        mysql -u root</span><br><span class="line">        mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;newpass&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法2: 用mysqladmin</span><br><span class="line">        mysqladmin -u root password &quot;newpass&quot;</span><br><span class="line">        如果root已经设置过密码，采用如下方法</span><br><span class="line">        mysqladmin -u root password oldpass &quot;newpass&quot;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法3: 用UPDATE直接编辑user表</span><br><span class="line">        mysql -u root</span><br><span class="line">        mysql&gt; use mysql;</span><br><span class="line">        mysql&gt; UPDATE user SET Password = PASSWORD(&apos;newpass&apos;) WHERE user = &apos;root&apos;;</span><br><span class="line">        mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方法4: 如果你忘记了或者不知道初始密码</span><br><span class="line">       step1:</span><br><span class="line">       苹果-&gt;系统偏好设置-&gt;最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server）</span><br><span class="line">       </span><br><span class="line">       step2:</span><br><span class="line">       进入终端输入：cd /usr/local/mysql/bin/</span><br><span class="line">       回车后 登录管理员权限 sudo su</span><br><span class="line">       回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">       回车后mysql会自动重启（偏好设置中mysql的状态会变成running）</span><br><span class="line">       </span><br><span class="line">       step3:</span><br><span class="line">       输入命令 ./mysql</span><br><span class="line">       回车后，输入命令 FLUSH PRIVILEGES;</span><br><span class="line">       回车后，输入命令 SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;你的新密码’);</span><br></pre></td></tr></table></figure>
<p>  至此，密码修改完成。</p>
<ul>
<li>如何查看Mysql中有哪些数据库和表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">想要知道自己的Mysql中有哪些数据库和表：</span><br><span class="line">show databases;//查看有哪些数据库</span><br><span class="line">use databaseName;//指定使用哪个数据库</span><br><span class="line">show tables;//查看指定数据库下都有哪些表</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用前要指定具体数据库名称: <code>use 数据库名称;</code></p>
</li>
<li><p>查看当前所使用数据库的名称（三种方法）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a、select database();</span><br><span class="line">b、show tables;</span><br><span class="line">c、status;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看数据库端口号: <code>show global variables like ‘port’;</code></li>
</ul>
<p><strong>注: 项目中操作数据库时，需要先查询判断目标数据库是否存在，若存在再进行后续查询等操作。因在打开数据库时，若数据库不存在，系统会新建一个同名数据库，因此时新建的数据库内容为空，执行SQL API时会不成功。</strong></p>
<ul>
<li>MySQL建表时的规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、表必备三个字段：id、gmt_create、gmt_modified。</span><br><span class="line">其中id必为主键,类型为unsigned bigint、单表时自增、步长为1。</span><br><span class="line">gmt_create, gmt_modified 的类型均为 date_time 类型。</span><br><span class="line"></span><br><span class="line">2、表的命名最好是加上“业务名称_表的作用”。</span><br><span class="line"></span><br><span class="line">3、单表行数超过 500 万行或者单表容量超过 2GB,才推荐进行分库分表。</span><br><span class="line">如果预计三年后的数据量根本达不到这个级别,请不要在创建表时就分库分表。</span><br></pre></td></tr></table></figure>
<ul>
<li>ORM规约</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、xml 配置中参数注意使用:#&#123;&#125;,#param# 不要使用$&#123;&#125; 此种方式容易出现 SQL 注入。</span><br></pre></td></tr></table></figure>
<ul>
<li>开启数据库服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用：mysql -u root -p进入数据库时，若出现zsh: command not found: mysql，则是数据库服务未开启</span><br><span class="line">使用：/usr/local/bin -&gt; sudo ln -fs /usr/local/mysql/bin/mysql mysql 输入电脑密码（ln -s或ln -fs是做链接操作）</span><br><span class="line">使用：mysql --version，若输出版本信息，则数据库服务成功开启</span><br><span class="line">使用：mysql -u root -p，输入数据库密码，进入数据库</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/06/数据库规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/06/数据库规范/" class="post-title-link" itemprop="url">数据库规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-06 16:23:00" itemprop="dateCreated datePublished" datetime="2019-02-06T16:23:00+08:00">2019-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="通用规范"><a href="#通用规范" class="headerlink" title="通用规范"></a>通用规范</h5><p>一、基础规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">表存储引擎必须使用InnoDB</span><br><span class="line"> </span><br><span class="line">表字符集默认使用utf8，必要时候使用utf8mb4</span><br><span class="line">解读：</span><br><span class="line">（1）通用，无乱码风险，汉字3字节，英文1字节</span><br><span class="line">（2）utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它</span><br><span class="line"> </span><br><span class="line">禁止使用存储过程，视图，触发器，Event</span><br><span class="line">解读：</span><br><span class="line">（1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层</span><br><span class="line">（2）调试，排错，迁移都比较困难，扩展性较差</span><br><span class="line"> </span><br><span class="line">禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径</span><br><span class="line">禁止在线上环境做数据库压力测试</span><br><span class="line">测试，开发，线上数据库环境必须隔离</span><br></pre></td></tr></table></figure>
<p>二、命名规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">库名，表名，列名必须用小写，采用下划线分隔</span><br><span class="line">解读：abc，Abc，ABC都是给自己埋坑</span><br><span class="line"> </span><br><span class="line">库名，表名，列名必须见名知义，长度不要超过32字符</span><br><span class="line">解读：tmp，wushan谁TM知道这些库是干嘛的</span><br><span class="line"> </span><br><span class="line">库备份必须以bak为前缀，以日期为后缀</span><br><span class="line">从库必须以-s为后缀</span><br><span class="line">备库必须以-ss为后缀</span><br></pre></td></tr></table></figure>
<p>三、表设计规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">单实例表个数必须控制在2000个以内</span><br><span class="line">单表分表个数必须控制在1024个以内</span><br><span class="line">表必须有主键，推荐使用UNSIGNED整数为主键</span><br><span class="line">潜在坑：删除无主键的表，如果是row模式的主从架构，从库会挂住</span><br><span class="line"> </span><br><span class="line">禁止使用外键，如果要保证完整性，应由应用程式实现</span><br><span class="line">解读：外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈</span><br><span class="line"> </span><br><span class="line">建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据</span><br><span class="line">解读：具体参考《如何实施数据库垂直拆分》</span><br></pre></td></tr></table></figure>
<p>四、列设计规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">根据业务区分使用tinyint/int/bigint，分别会占用1/4/8字节</span><br><span class="line">根据业务区分使用char/varchar</span><br><span class="line">解读：</span><br><span class="line">（1）字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高</span><br><span class="line">（2）字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间</span><br><span class="line"> </span><br><span class="line">根据业务区分使用datetime/timestamp</span><br><span class="line">解读：前者占用5个字节，后者占用4个字节，存储年使用YEAR，存储日期使用DATE，存储时间使用datetime</span><br><span class="line"> </span><br><span class="line">必须把字段定义为NOT NULL并设默认值</span><br><span class="line">解读：</span><br><span class="line">（1）NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化</span><br><span class="line">（2）NULL需要更多的存储空间</span><br><span class="line">（3）NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑</span><br><span class="line"> </span><br><span class="line">使用INT UNSIGNED存储IPv4，不要用char(15)</span><br><span class="line"> </span><br><span class="line">使用varchar(20)存储手机号，不要使用整数</span><br><span class="line">解读：</span><br><span class="line">（1）牵扯到国家代号，可能出现+/-/()等字符，例如+86</span><br><span class="line">（2）手机号不会用来做数学运算</span><br><span class="line">（3）varchar可以模糊查询，例如like ‘138%’</span><br><span class="line"> </span><br><span class="line">使用TINYINT来代替ENUM</span><br><span class="line">解读：ENUM增加新值要进行DDL操作</span><br></pre></td></tr></table></figure>
<p>五、索引规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">唯一索引使用uniq_[字段名]来命名</span><br><span class="line">非唯一索引使用idx_[字段名]来命名</span><br><span class="line">单张表索引数量建议控制在5个以内</span><br><span class="line">解读：</span><br><span class="line">（1）互联网高并发业务，太多索引会影响写性能</span><br><span class="line">（2）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引</span><br><span class="line">（3）异常复杂的查询需求，可以选择ES等更为适合的方式存储</span><br><span class="line"> </span><br><span class="line">组合索引字段数不建议超过5个</span><br><span class="line">解读：如果5个字段还不能极大缩小row范围，八成是设计有问题</span><br><span class="line"> </span><br><span class="line">不建议在频繁更新的字段上建立索引</span><br><span class="line">非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引</span><br><span class="line">解读：踩过因为JOIN字段类型不一致，而导致全表扫描的坑么？</span><br><span class="line"> </span><br><span class="line">理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)</span><br></pre></td></tr></table></figure>
<p>六、SQL规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">禁止使用select *，只获取必要字段</span><br><span class="line">解读：</span><br><span class="line">（1）select *会增加cpu/io/内存/带宽的消耗</span><br><span class="line">（2）指定字段能有效利用索引覆盖</span><br><span class="line">（3）指定字段查询，在表结构变更时，能保证对应用程序无影响</span><br><span class="line"> </span><br><span class="line">insert必须指定字段，禁止使用insert into T values()</span><br><span class="line">解读：指定字段插入，在表结构变更时，能保证对应用程序无影响</span><br><span class="line"> </span><br><span class="line">隐式类型转换会使索引失效，导致全表扫描</span><br><span class="line"> </span><br><span class="line">禁止在where条件列使用函数或者表达式</span><br><span class="line">解读：导致不能命中索引，全表扫描</span><br><span class="line"> </span><br><span class="line">禁止负向查询以及%开头的模糊查询</span><br><span class="line">解读：导致不能命中索引，全表扫描</span><br><span class="line"> </span><br><span class="line">禁止大表JOIN和子查询</span><br><span class="line">同一个字段上的OR必须改写问IN，IN的值必须少于50个</span><br><span class="line">应用程序必须捕获SQL异常</span><br><span class="line">解读：方便定位线上问题</span><br></pre></td></tr></table></figure>
<h5 id="项目开发中的规范"><a href="#项目开发中的规范" class="headerlink" title="项目开发中的规范"></a>项目开发中的规范</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、统一采用Mysql数据库；</span><br><span class="line">2、数据库操作采用单表操作；</span><br><span class="line">3、表与表之间不建立物理外键关系；</span><br><span class="line">4、库名与应用名称尽量一致；</span><br><span class="line">5、表名规则</span><br><span class="line">   表名：应用简称-业务简称；</span><br><span class="line">   例如： kq_emp_info，kq代表考勤，emp_info 代表员工信息；</span><br><span class="line">6、合理创建索引；</span><br><span class="line">6、其他：</span><br><span class="line">   1、表名、字段名必须使用小写字母或数字 ； 禁止出现数字开头，禁</span><br><span class="line">   止两个下划线中间只出现数字；</span><br><span class="line">   2、每个表字段不能为空，必须有默认值；</span><br><span class="line">   3、int、 bigint 必须加类型限定符“unsigned”；</span><br><span class="line">   4、字符集统一为“utf8‘’；</span><br><span class="line">   5、表必备字段：表名首字母_id， create_time、update_time、delete_time说明：</span><br><span class="line">   其中 “表名首字母_id”必为主键（如员工表kq_emp_info ,则主键为</span><br><span class="line">   ei_id），且以表名的类型为 unsigned  bigint 、单表时自增、</span><br><span class="line">   步长为 1。</span><br><span class="line">   create_time , update_time, delete_time的类型均为bigint 类型；</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/06/SQLite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/06/SQLite/" class="post-title-link" itemprop="url">SQLite</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-06 12:10:46" itemprop="dateCreated datePublished" datetime="2019-02-06T12:10:46+08:00">2019-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SQLite原生语言是C语言。SQLite数据库的所有操作都是在事务上下文内完成的。</p>
<ul>
<li>事务生命周期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务在哪些对象上运行，这与API直接相关，数据库写操作时，是在用一个</span><br><span class="line">连接，一次一个事务。因此，所有语句的对象都是运行在派生它们自身的连</span><br><span class="line">接的单个事务上下文中。</span><br></pre></td></tr></table></figure>
<ul>
<li>事务：读事务、写事务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的操作，写操作或者读操作，都必须经历：未加锁、待定锁、共享锁。</span><br></pre></td></tr></table></figure>
<ul>
<li>锁</li>
</ul>
<p>SQLite的锁是基于标准的文件锁定实现的。SQLite在数据库文件中有三种不同的文件锁：<code>保留字节、待定字节、一个共享区域</code>。</p>
<p>SQLite的故障恢复机制使用保留字节来判断什么时候需要恢复数据库（涉及关键字：一致性、热日志、“回放”日志&lt;将数据库还原到初始的被中断的事务之前的状态&gt;）（热日志：系统异常崩溃时的日志）。热日志就是隐式的独占锁。</p>
<p>通过在保留状态完成所有数据库的工作，可以最小化独占状态的时间。如果在保留状态完成所有的工作，那么独占状态的持有时间只是将修改页面刷新到磁盘那么长（因不用编译更多的查询，处理更多的结果，然后写到磁盘）。在保留状态中处理，可以显著提高整体的并发性。</p>
<p>保留状态下，pager实际上管理三种页：<code>已修改页、未修改页和日志页</code>。日志页，就是已修改页的原始版本。</p>
<ul>
<li>SQLite API</li>
</ul>
<p>SQLite API由两个基本部分组成：<code>核心API和扩展API</code>。<br>核心API围绕两个基本的用于执行SQL命令的<strong>数据结构：</strong><code>连接和语句</code>。<br>命令通过三个步骤执行：<code>编译、执行和完成</code>。<br>SQLite的封装函数exec()和get_table()将上面三步封装成一个函数调用，自动处理相关联的语句对象。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键字：连接、句柄、事务、锁</span><br></pre></td></tr></table></figure>
<h5 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h5><p>在执行SQL命令前，首先要连接数据库。连接称为打开较形象，因为SQLite数据库包含在单个操作系统文件（一个文件对应一个数据库），与此对应，断开称为关闭。打开数据库的函数的声明中的flags，作用是进一步控制数据库句柄的事务行为。</p>
<p><strong>注：在写另一个连接之前始终要调用finalize()或reset()。</strong></p>
<p><strong>堆上的变量需要手动释放，栈上的变量系统自动管理。</strong></p>
<ul>
<li>SQLite原生数据类型（存储类）5种：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">integer、float、text、blob、null对应的整数值为:</span><br><span class="line">integer（1）、float（2）、text（3）、blob（4）、null（5）</span><br></pre></td></tr></table></figure>
<ul>
<li>列类型声明</li>
</ul>
<p>SQLite在创建表字段时，支持声明列类型和不声明列类型的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">声明列类型：即在创建字段时指明字段所在的域值类型（严格类型）；</span><br><span class="line"></span><br><span class="line">不声明列类型：即在创建字段时不指明字段所在的域值类型，具体类型根据</span><br><span class="line">插入的值进行推断确定当前的字段域值类型（动态类型）。</span><br></pre></td></tr></table></figure>
<p>即，SQLite的显示类型声明，列可以有类型且类型可依据值来推断。</p>
<ul>
<li>参数编号</li>
</ul>
<p>SQL中的参数，位置参数从1开始，顺序使用整数值，为每个参数分配一个可唯一标识的编号。在SQL语句中给参数编号时，允许的范围是整数值1~999 。若要取得最优的性能和内存利用率，应选择较小的数字。</p>
<ul>
<li>绑定函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">绑定函数分为两类：</span><br><span class="line">一类用于标量值（int、double、int64、NULL）；</span><br><span class="line">一类用于数组（blob、text、text16）。</span><br><span class="line">绑定函数的区别：在于数组绑定函数需要一个长度参数和指向清理函数的指针。</span><br></pre></td></tr></table></figure>
<ul>
<li>三种一定要在代码中关注的情况是：<code>错误、繁忙情况、模式更改</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">繁忙处理程序的唯一局限是它们可能不会关闭数据库。</span><br></pre></td></tr></table></figure>
<ul>
<li>会遇到的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">遇到SQLITE_BUSY时的简单处理就是重新再调用一次。</span><br><span class="line">SQLITE_SCHEMA情况存在的最终原因与VDBE有关。</span><br><span class="line"></span><br><span class="line">SQLite中与线程相关的一个限制是UNIX平台上的系统调用fork()。决不</span><br><span class="line">要尝试在fork()调用中将连接传递给子进程，否则将无法正常工作。</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/26/SQL基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/26/SQL基础/" class="post-title-link" itemprop="url">SQL基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-26 15:10:22" itemprop="dateCreated datePublished" datetime="2019-01-26T15:10:22+08:00">2019-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-10 11:54:33" itemprop="dateModified" datetime="2020-12-10T11:54:33+08:00">2020-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>注意：<strong>数据库的名称只能使用小写字符。</strong>（实际存储的命名是小写字符，如在命名时有大写字符，在实际存储的时候也会转成小写字符。在PostgreSQL上验证过）</p>
<ul>
<li>DBMS主要是通过<strong>数据的保存格式</strong>（数据库种类）来进行分类的，主要有以下五种</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一、层次型数据库（HDB）（树形结构）</span><br><span class="line">二、关系型数据库（RDB）（采用行列二维表结构来管理数据，使用专门的</span><br><span class="line">SQL（structured Query Language，结构化查询语言）语言对数据进</span><br><span class="line">行操作）（对应的数据库管理系统，是RDBMS，具有代表性的RDBMS有：</span><br><span class="line">Oracle Database[甲骨文]、SQL Server[微软]、DB2[IBM]、</span><br><span class="line">PostgreSQL[开源]、MySQL[开源] ）</span><br><span class="line">三、面向对象数据库（OODB）</span><br><span class="line">四、XML数据库（XMLDB）</span><br><span class="line">五、键值存储系统（Key-Value Store，KVS）</span><br></pre></td></tr></table></figure>
<p>关系数据库采用被称为数据库表的二维表来管理数据。用来管理数据的二维表在关系数据库中简称为表，表存储在由RDBMS管理的数据库中，一个数据库中可以存储多个表。</p>
<p>数据库表由表示数据项目的列（字段）和表示一条数据的行（记录）所组成，以记录为单位进行数据读写。（每个字段值[行列交汇的单元格]，只能输入一个数据）</p>
<p>根据SQL语句的内容返回的数据，同样必须是二维表的形式。</p>
<ul>
<li>操作关系数据库表的法则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、关系数据库必须以行为单位进行数据读写</span><br><span class="line">2、在一个单元格中只能输入一个数据</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL语句的书写规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、SQL语句要以分号（;）结尾</span><br><span class="line">2、SQL语句不区分大小写（SQL不区分关键字的大小写）</span><br><span class="line">2.1 关键字大写</span><br><span class="line">2.2 表名的首个字母大写</span><br><span class="line">2.3 其余（列名等）小写</span><br><span class="line">3、常数的书写方式是固定的。SQL中的常数，是在SQL语句中直接书写的字</span><br><span class="line">符串、日期或者数字等称为常数。字符串、日期常数需要使用单引号（&apos;）</span><br><span class="line">括起来，数字常数直接书写即可。</span><br><span class="line">4、单词需要用半角空格或者换行来分隔。</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL语句的命名规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、只能使用半角英文字母、数字、下划线作为数据库、表和列的名称；</span><br><span class="line">2、名称必须以半角英文字母开头；</span><br><span class="line">3、名称不能重复。</span><br></pre></td></tr></table></figure>
<ul>
<li>安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了防止重要数据被窃读或篡改，RDBMS只允许注册用户接触数据库。</span><br></pre></td></tr></table></figure>
<ul>
<li>补充</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、所有的列都必须指定数据类型。</span><br><span class="line">2、约束，是除了数据类型之外，对列中存储的数据进行限制或者追加条件的功能。</span><br></pre></td></tr></table></figure>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><ul>
<li>常用指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建数据库：create database 数据库名称</span><br><span class="line">删除数据库：drop database 数据库名称</span><br><span class="line">查看已创建的数据库：</span><br><span class="line">select * from pg_database;（postgreSQL下）</span><br><span class="line">show databases;//查看有哪些数据库（MySQL）</span><br><span class="line"></span><br><span class="line">查看数据库中已建的表：</span><br><span class="line">select tablename from pg_tables where schemaname=&apos;public’;</span><br><span class="line">use databaseName;//指定使用哪个数据库（MySQL）</span><br><span class="line">show tables;//查看指定数据库下都有哪些表（MySQL）</span><br></pre></td></tr></table></figure>
<ul>
<li>运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">所有包含NULL的计算，结果肯定是NULL。</span><br><span class="line">（通常情况下除数为零的式子会出错，但有NULL的除法运算中，除数为零时式子不会出错，并且结果为NULL）</span><br><span class="line"></span><br><span class="line">大于等于（&gt;=）、小于等于（&lt;=）：不等号在左，等号在右</span><br><span class="line">不等号：&lt;&gt;</span><br><span class="line"></span><br><span class="line">SQL不识别“= NULL”和“&lt;&gt; NULL”，对应的运算符是：IS NULL和 IS NOT NULL。</span><br><span class="line"></span><br><span class="line">SQL中的逻辑运算是包含对真、假和不确定进行运算的三值逻辑。</span><br><span class="line"></span><br><span class="line">逻辑运算结果是真值。（真值就是值为真或假其中之一的值）</span><br><span class="line"></span><br><span class="line">算术运算符返回的结果是数字。</span><br></pre></td></tr></table></figure>
<ul>
<li>运算符优先级：<code>and运算优先于or运算执行</code></li>
</ul>
<p>SQL中的逻辑，是三值逻辑（包括真、假、不确定），因加入不确定后，运算结果会比较复杂，所以在建表时，会对相应列进行NOT NULL约束。</p>
<p>聚合函数会将NULL排除在外。但count(*)例外，并不会排除NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAX/MIN函数几乎适用于所有数据类型的列，</span><br><span class="line">SUM/AVG函数只适用于数值类型的列。</span><br></pre></td></tr></table></figure>
<p>通常select语句执行结果的显示顺序都是随机的，想要按照某种特定顺序进行排序，需要在select语句中进行指定。</p>
<ul>
<li>子句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">只有select子句和having子句（以及order by子句）中能够使用聚合函数。</span><br><span class="line"></span><br><span class="line">where子句用来指定数据行的条件，having子句用来指定分组的条件。</span><br><span class="line"></span><br><span class="line">select子句的执行顺序在group by子句之后，在order by子句之前。</span><br></pre></td></tr></table></figure>
<ul>
<li>子句的书写顺序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、select子句-&gt;2、from子句-&gt;3、where子句-&gt;4、group by子句-&gt;5、having子句-&gt;6、order by子句</span><br></pre></td></tr></table></figure>
<ul>
<li>select语句的顺序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;order by</span><br></pre></td></tr></table></figure>
<p>默认值的设定，可以通过在创建表的create table语句中设置default约束来实现。</p>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p><code>事务，是数据库中用来管理数据更新的重要概念。</code></p>
<p>数据库事务(Database Transaction)，是指作为单个逻辑工作单元执行的一系列操作，要么完整的执行，要么完全不执行。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功，要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足ACID(原子性、一致性、隔离型和持久性)属性。</p>
<p><strong>事务是需要在同一个处理单元中执行的一系列更新处理的集合。</strong>事务代表了对表中数据进行更新的单位。通过使用事务，可以对数据库中的数据更新处理的提交和取消进行管理。<strong>数据库的更新操作以事务为单位进行。</strong></p>
<ul>
<li>事务的特性</li>
</ul>
<p>事务具有ACID特性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性（Atomicity）；</span><br><span class="line">一致性（Consistency）；</span><br><span class="line">隔离性（Isolation）；</span><br><span class="line">持久性（Durability）。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">原子性：事务中的操作要么都执行，要么都不执行（反映到对数据库操作的</span><br><span class="line">最终结果上。即一个事务完成后，对结果的操作不可撤销，结果不可恢复到</span><br><span class="line">操作前的状态，即与持久性相对应！！！）</span><br><span class="line"></span><br><span class="line">一致性：指的是事务中包含的处理，要满足数据库提前设置的约束。即针对</span><br><span class="line">对应字段域的处理，要满足建表时对该字段域所设置的约束，即保证新的操</span><br><span class="line">作与原有数据类型的完整性。如操作过程中有失败的情况，会撤销当前失败</span><br><span class="line">的操作，回滚到上一次操作成功完成后的状态，随后继续执行后续的操作。</span><br><span class="line"></span><br><span class="line">隔离性：指的是保证不同事务之间互不干扰的特性。在事务未提交之前，该</span><br><span class="line">事务中的操作对其他事务而言是不可见的。</span><br><span class="line"></span><br><span class="line">持久性：指的是事务（不论是提交还是回滚）一旦结束，DBMS会保证该时点</span><br><span class="line">的数据状态得以保存的特性。</span><br></pre></td></tr></table></figure>
<p><strong>DBMS的事务都遵循ACID标准规格的约定！！！</strong></p>
<p>遇到需要在同一个处理单元中执行一系列更新操作的情况，一定要使用事务来进行处理。进行数据库更新操作，有事务的环境下，才能进行撤销或确认操作。使用事务开始语句和事务结束语句，将一系列DML语句（insert/update/delete语句）括起来，就实现了一个事务处理。</p>
<p>事务处理的终止指令包括commit（提交处理）和rollback（取消处理）两种。</p>
<ul>
<li>事务的常用模式</li>
</ul>
<p><strong>注：实际上，几乎所有的数据库产品的事务都无需开始指令。这是因为大部分情况下，事务在数据库连接建立时就已经悄悄开始了，并不需要用户再明确发出开始指令。</strong></p>
<p>像这样不使用指令而悄悄开始事务的情况下，应该如何区分各个事务呢？通常会有如下两种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一、每条SQL语句就是一个事务（自动提交模式）</span><br><span class="line">二、直到用户执行commit或者rollback为止算作一个事务</span><br></pre></td></tr></table></figure>
<p>通常的DBMS都可以选择其中任意一种模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认使用自动提交模式的DBMS有：SQL Server、PostgreSQL和MySQL；</span><br><span class="line">默认使用第二种模式的有Oracle。</span><br></pre></td></tr></table></figure>
<p>自动提交的模式可关闭，在关闭自动提交模式的情况下，可以通过事务开始语句，明示开始事务，相应的需要事务结束语句，明示结束事务。</p>
<ul>
<li>小结<ul>
<li>事务(Transaction)是数据库操作中并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。通过事务，SQL Server能将逻辑相关的一组操作绑定在一起，以便服务器保持数据的完整性</li>
<li>事务通常是以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束<ul>
<li>COMMIT表示提交，即提交事务的所有操作。具体说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束(在提交前，操作的数据结果可能是存到缓存中)</li>
<li>ROLLBACK表示回滚，即在事务执行的过程中发生了某种故障，事务不能继续进行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始的状态</li>
<li>如果事务没有错误则提交(COMMIT Transaction)，如果出现错误或死机则回滚事务(ROLLBACK)</li>
</ul>
</li>
<li>事务运行的三种模式<ul>
<li>自动提交事务：每条单独的语句都是一个事务，每个语句后都隐含一个COMMIT</li>
<li>显式事务：以BEGIN TRANSACTION显式开始，以COMMIT或ROLLBACK显式结束</li>
<li>隐式事务：在前一个事务完成时，新事务隐式启动，但每个事务仍以COMMIT或ROLLBACK显式结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="视图和表"><a href="#视图和表" class="headerlink" title="视图和表"></a>视图和表</h5><ul>
<li>视图的概念</li>
</ul>
<p>从SQL的角度来看，视图和表是相同的。两者的区别（仅有的区别）在于表中保存的是实际的数据，而视图中保存的是select语句（视图本身并不存储数据）。视图是一个工具。使用视图，可以完成跨多表查询数据等复杂操作。<strong>实际上视图保存的是select语句（从视图中读取数据时，视图会在内部执行select语句并创建出一张临时表）。</strong>视图归根到底就是select语句，所谓“参照视图”也就是“执行select语句”的意思。因此可以保证数据的最新状态。</p>
<ul>
<li>数据存储过程</li>
</ul>
<p>通常，在创建表时，会通过insert语句将数据保存到数据库中。而数据库中的数据实际上会被保存到计算机的存储设备（通常是硬盘）中。因此，通过select语句查询数据时，实际上就是从存储设备（硬盘）中读取数据，进行各种计算之后，将结果返回给用户。</p>
<ul>
<li>视图的优点</li>
</ul>
<p>一、节省存储设备的数据领域。</p>
<p>二、将频繁使用的select语句保存成视图（类似创建快捷键），有利于提高效率。</p>
<p><strong>注：视图中的数据会随着原表的变化自动更新。</strong></p>
<ul>
<li>一幅视图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看数据库中已建的视图：</span><br><span class="line">select viewname from pg_views where schemaname=&apos;public&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>视图的操作</li>
</ul>
<p>视图和表需要同时进行更新，因此通过聚合得到的视图无法进行更新。使用cascade选项来删除关联视图，会把目标视图，和与之相关联的视图都删除。</p>
<p>子查询就是一次性的视图（select语句）。与视图不同，子查询在select语句执行完毕之后就会消失。子查询的特点概括起来就是一张一次性视图。</p>
<p>通常指定关联子查询作为exist的参数。</p>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p><code>函数，就是输入某一值得到相应输出结果的功能（SQL自带有便利的工具---函数），具体表现有：类的方法。</code></p>
<p>聚合函数基本上只包含<code>count、sum、avg、max、min</code>这5种。</p>
<ul>
<li>算术函数：除常用的加减乘除还有以下函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abs（absolute values，绝对值函数），语法：abs（数值）</span><br><span class="line"></span><br><span class="line">mod（modulo的简称），是计算除法余数（剩余）的函数，语法：mod（被</span><br><span class="line">除数，除数）（被除数写在根号里）（如：7/3的余数是1，因此mod（7，</span><br><span class="line">3）的结果也是1）。由于小数计算中并没有余数的概念，所以只能对整数类</span><br><span class="line">型的列使用mod函数。</span><br><span class="line"></span><br><span class="line">注：主流的DBMS都支持mod函数，只有SQL Server不支持该函数，SQL </span><br><span class="line">Server用运算符（%）来实现等价的效果（SQL Server：7%3=1）</span><br><span class="line"></span><br><span class="line">round（四舍五入函数），语法：round（对象数值，保留小数的位数）</span><br><span class="line">（如指定四舍五入的位数为1，那么就会对小数点第2位进行四舍五入处理；</span><br><span class="line">如指定位数为2，那么就会对小数点第3位进行四舍五入处理）</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">拼接函数（||函数），语法：str1 || str2 = str1str2。进行字符串</span><br><span class="line">拼接时，如果其中包含null，那么得到的结果也是null，因为“||”也是变了形的函数。</span><br><span class="line">SQL Server和MySQL中，“||”函数无效，对应的等价函数是：SQL </span><br><span class="line">Server是“+”；MySQL是concat(字符串1，字符串2，...)。</span><br><span class="line"></span><br><span class="line">字符串长度函数（length函数），语法：length（字符串）</span><br><span class="line">SQL Server中，length函数无效，对应的等价函数是：len（字符串）</span><br><span class="line"></span><br><span class="line">小写转换函数（lower），语法：lower（字符串）；大写转换函数（upper）</span><br><span class="line"></span><br><span class="line">字符串替换函数（replace），语法：replace（对象字符串，替换前的字符串，替换后的字符串）</span><br><span class="line"></span><br><span class="line">字符串截取函数（substring），语法：</span><br><span class="line">substring（对象字符串 from 截取的起始位置 for 截取的字符数）（PostgreSQL/MySQL）</span><br><span class="line">substring（对象字符串，截取的起始位置，截取的字符数）（SQL Server）</span><br><span class="line">substr（对象字符串，截取的起始位置，截取的字符数）（Oracle/DB2）</span><br></pre></td></tr></table></figure>
<h5 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h5><p><strong>谓词，就是返回值为真值的函数。</strong>谓词是SQL的抽出条件中不可或缺的工具。谓词是需要满足特定条件的函数，该条件就是“返回值是真值”。谓词的返回值全都是真值（true/false/unknown）。</p>
<p>like谓词：字符串的部分一致查询（%，代表“0字符以上的任意字符串”的特殊符号）（可用“_”代替“%”，与“%”不同的是其代表了“任意1个字符”）。</p>
<p>between谓词：范围查询。</p>
<p>is null、is not null谓词：判断是否为null。</p>
<p>in谓词：or的简便用法。</p>
<p><strong>谓词的作用是“判断是否存在满足某种条件的记录”。</strong></p>
<h5 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h5><p><strong>集合运算符会除去重复的记录。</strong></p>
<ul>
<li>集合运算的注意事项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一：作为运算对象的记录的列数必须相同；</span><br><span class="line">二：作为运算对象的记录中列的类型必须一致；</span><br><span class="line">三：可以使用任何select语句，但order by子句只能在最后使用一次。</span><br></pre></td></tr></table></figure>
<h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p>表达式可以书写在任意位置。</p>
<p>case表达式无论多长都是一个表达式。</p>
<p><strong>外联结有一点非常重要，那就是要把哪张表作为主表，最终的结果中会包含主表内所有的数据。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/图解HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/25/图解HTTP/" class="post-title-link" itemprop="url">图解HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-25 16:45:15" itemprop="dateCreated datePublished" datetime="2019-01-25T16:45:15+08:00">2019-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><ul>
<li>协议</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">协议是指规则的约定。</span><br><span class="line">协议，是相互之间通信前所定下的规则。</span><br></pre></td></tr></table></figure>
<p>像通过发送请求获取服务器资源的Web浏览器等，都可称为客户端。Web是建立在HTTP协议上通信的。（HTTP是Web文档传输的协议）</p>
<ul>
<li>WWW</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WWW这一提议是致力于全世界的研究者们进行知识共享。</span><br><span class="line">WWW基本理念：</span><br><span class="line">借助多文档之间相互关联形成的超文本（HyperText），</span><br><span class="line">连成可相互参阅的WWW（world wide web，万维网）。</span><br><span class="line"></span><br><span class="line">现阶段构建WWW的3项技术：</span><br><span class="line">HTML、HTTP（文档传递协议）、URL</span><br></pre></td></tr></table></figure>
<ul>
<li>TCP/IP</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP是互联网相关的各类协议族的总称。</span><br><span class="line">TCP/IP协议族里重要的一点就是分层。</span><br><span class="line">分为4层：</span><br><span class="line">应用层（FTP/DNS/HTTP）、</span><br><span class="line">传输层（TCP/UDP）、</span><br><span class="line">网络层、</span><br><span class="line">数据链路层（硬件上的范畴均在链路层的作用范围之内）</span><br></pre></td></tr></table></figure>
<p>通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。利用TCP/IP协议族进行网络通信时，当客户端的请求传输到服务器的应用层，才能算真正接收到由客户端发送过来的HTTP请求。（HTTP属于TCP/IP内部的一个子集）</p>
<h5 id="与HTTP关系密切的协议：IP、TCP、DNS"><a href="#与HTTP关系密切的协议：IP、TCP、DNS" class="headerlink" title="与HTTP关系密切的协议：IP、TCP、DNS"></a>与HTTP关系密切的协议：IP、TCP、DNS</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 负责传输的IP协议</span><br><span class="line">- 确保可靠性的TCP协议</span><br><span class="line">- 负责域名解析的DNS服务（DNS提供域名到IP地址之间的解析服务）</span><br></pre></td></tr></table></figure>
<ul>
<li>IP和IP地址的区别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- IP其实是一种协议的名称，IP协议的作用是把各种数据包传送给对方。</span><br><span class="line">要保证确实传送到对方那里，则需要满足各类条件，其中两个重要的条件</span><br><span class="line">是IP地址和MAC地址（media access control address）。</span><br><span class="line"></span><br><span class="line">- IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址，</span><br><span class="line">IP地址可以和MAC地址进行配对，IP地址可变换，但MAC地址基本上不会更改。</span><br></pre></td></tr></table></figure>
<p>IP间的通信依赖MAC地址。ARP（address resolution protocol）是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p>
<ul>
<li>TCP</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TCP位于传输层，提供可靠的字节流服务。</span><br><span class="line">为了准确无误地将数据送达目标处，</span><br><span class="line">TCP协议采用了三次握手（three-way handshaking）策略。</span><br><span class="line">握手过程中使用了TCP的标志（flag），SYN（synchronize）和ACK（acknowledgement）。</span><br></pre></td></tr></table></figure>
<ul>
<li>DNS</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。</span><br></pre></td></tr></table></figure>
<p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。相对URL，是指从浏览器中基本URI处指定的URL，形如<code>/image/logo.gif</code>。</p>
<p>计算机既可以被赋予IP地址，也可以被赋予主机名和域名（如：<a href="http://www.baidu.com）。" target="_blank" rel="noopener">www.baidu.com）。</a></p>
<p>RFC（Request for Comments，征求修正意见书），是一些用来制定HTTP协议技术标准的文档。</p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>HTTP用于客户端和服务器之间的通信。HTTP协议应用过程中，有客户端角色、服务器端角色划分。计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。即是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。通过请求和响应的交换达成通信。请求和响应过程中对应相应的报文。</p>
<ul>
<li>请求报文</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请求报文是由请求方法、请求URI、协议版本、</span><br><span class="line">可选的请求首部字段和内容实体构成的。</span><br></pre></td></tr></table></figure>
<p>结构图如下：</p>
<p><img src="/2019/01/25/图解HTTP/请求报文结构图.jpg" alt="请求报文结构图"></p>
<p>接收到请求的服务器，会将请求内容的处理结果以响应报文的形式返回。</p>
<ul>
<li>响应报文</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、</span><br><span class="line">用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</span><br></pre></td></tr></table></figure>
<p>结构图如下：</p>
<p><img src="/2019/01/25/图解HTTP/响应报文结构图.jpg" alt="响应报文结构图"></p>
<p><strong>HTTP是一种不保存状态，即无状态协议。</strong>即在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。协议本身并不保留之前一切的请求或响应报文的信息，<strong>这是为了更快地处理大量事务，确保协议的可伸缩性，</strong>而特意把HTTP协议设计成如此简单。</p>
<p>HTTP协议使用URI定位互联网上的资源。如果不是访问特定资源而是对服务器本身发起请求，可以用一个<code>*</code>来代替请求<code>URI</code>。</p>
<ul>
<li>告知服务器意图的HTTP方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET：获取资源</span><br><span class="line">POST：传输实体主体</span><br><span class="line">PUT：传输文件</span><br><span class="line">HEAD：获得报文首部</span><br><span class="line">DELETE：删除文件</span><br><span class="line">OPTIONS：询问支持的方法</span><br><span class="line">TRACK：追踪路径</span><br><span class="line">CONNECT：要求用隧道协议连接代理</span><br></pre></td></tr></table></figure>
<p>GET方法用来请求访问已被URI识别的资源，指定的资源经服务器端解析后返回响应内容。</p>
<p>POST方法用来传输实体的主体。（GET也有这一功能，但这种情况下，通常使用POST方法）</p>
<p>HTTP/1.1的PUT/DELETE方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站部使用该方法。</p>
<p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</p>
<p>TRACK方法是用来确认连接过程中发生的一系列操作。（容易引发XST—Cross-Site Tracing 跨站追踪攻击）</p>
<p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。</p>
<p><strong>方法的作用在于，可以指定请求的资源按期望产生某种行为。注意方法名区分大小写，注意要用大写字母。</strong></p>
<p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接（断开、重连会增加通信量的开销）。持久连接使得多数请求以管线化方式发送成为可能。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p>
<p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。<code>HTTP/1.1</code>虽然是无状态协议，但为了实现期望的保持状态功能，引入了<code>Cookie</code>技术。有了<code>Cookie</code>再用HTTP协议通信，就可以管理状态了。</p>
<p>Cookie技术的引入，是为了解决HTTP无状态保存的问题。<strong>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态</strong>，Cookie会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知<strong>客户端保存Cookie。</strong></p>
<ul>
<li>状态信息校验获取过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去；</span><br><span class="line">服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，</span><br><span class="line">然后对比服务器上的记录，最后得到之前的状态信息。</span><br></pre></td></tr></table></figure>
<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p>用于HTTP协议交互的信息被称为HTTP报文。</p>
<ul>
<li>HTTP报文可分为：<strong>报文首部</strong>和<strong>报文主体</strong>两块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">报文首部：服务器端或客户端需处理的请求或响应的内容及属性</span><br><span class="line">报文主体：应被发送的数据</span><br></pre></td></tr></table></figure>
<ul>
<li>报文的首部字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">报文的首部字段，一般有4种首部，分别是：</span><br><span class="line">通用首部、请求首部、响应首部、实体首部</span><br></pre></td></tr></table></figure>
<ul>
<li>报文：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输</span><br></pre></td></tr></table></figure>
<ul>
<li>实体：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</span><br></pre></td></tr></table></figure>
<p>通常，报文主体等于实体主体。只有当传输中进行编码操作<strong>（编码的操作需要计算机来完成，因此会消耗更多的CPU资源）</strong>时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<p>HTTP协议中有一种被称为内容编码的功能能将待发送的“附件”压缩。内容编码后的实体由客户端接收并负责解码。</p>
<ul>
<li>常用的内容编码有以下几种：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip(GNU zip)</span><br><span class="line">compress(UNIX系统的标准压缩)</span><br><span class="line">deflate(zlib)</span><br><span class="line">identity(不进行编码)</span><br></pre></td></tr></table></figure>
<p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块（分块传输编码），能够让浏览器逐步显示页面。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。</p>
<p>发送邮件时，可以在邮件里写入文字并添加多份附件，这是因为采用了MIME（多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。在MIME扩展中会使用一种称为多部分对象集合的方法，来容纳多份不同类型的数据。</p>
<ul>
<li>内容协商</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内容协商使用场景：</span><br><span class="line">同一个页面样式，根据请求的语言、浏览器类型加载出与当前请求目标相对应的页面（如谷歌的首页，中文版、英文版）</span><br><span class="line"></span><br><span class="line">内容协商技术有3种类型：</span><br><span class="line">服务器驱动协商、客户端驱动协商、透明协商</span><br></pre></td></tr></table></figure>
<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h5 id="HTTP的状态码"><a href="#HTTP的状态码" class="headerlink" title="HTTP的状态码"></a>HTTP的状态码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</span><br><span class="line">状态码以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。</span><br></pre></td></tr></table></figure>
<ul>
<li>响应类别有以下5种：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1XX：信息性状态码-&gt;接收的请求正在处理</span><br><span class="line">2XX：成功状态码-&gt;请求正常处理完毕</span><br><span class="line">3XX：重定向状态码-&gt;需要进行附加操作以完成请求</span><br><span class="line">4XX：客户端错误状态码-&gt;服务器无法处理请求（客户端请求的格式有错，导致服务器无法处理请求）</span><br><span class="line">5XX：服务器错误状态码-&gt;服务器处理请求出错</span><br></pre></td></tr></table></figure>
<h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>一台Web服务器可搭建多个独立域名的Web网站，也可作为通信路径上的中转服务器提升传输效率。</p>
<p>虚拟主机（虚拟服务器）：即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。</p>
<p>客户端使用HTTP协议访问服务器时，会采用类似<code>www.baidu.com</code>这样的主机名和域名。在互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。所以当请求发送到服务器时，已经是以IP地址形式访问了。</p>
<p>通常Web服务托管在指定的服务器（该服务器上通常会使用虚拟主机技术）上供客户端访问。在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在host首部内完整指定主机名和域名的URI。</p>
<ul>
<li>通信数据转发程序：<code>代理（应用程序）、网关（服务器）、隧道（应用程序）</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代理：负责服务器和客户端，请求、响应的转发</span><br><span class="line">网关：转发提供资源的服务器（类似拥有资源的源服务器）</span><br><span class="line">隧道：保持（相隔甚远的）客户端和服务器双方通信连接的应用程序</span><br><span class="line">（隧道的目的是确保客户端能与服务器进行安全的通信，通常会使用SSL等加密手段进行通信；</span><br><span class="line">隧道本身不会去解析HTTP请求，即原样传输）</span><br></pre></td></tr></table></figure>
<ul>
<li>缓存代理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代理服务器将响应的资源缓存，遇到相同的请求时，直接把缓存的资源作为</span><br><span class="line">响应返回（缓存服务器会向源服务器确认缓存资源的有效性）。利用缓存可</span><br><span class="line">减少对源服务器的访问，因此也就节省了通信流量和通信时间。</span><br></pre></td></tr></table></figure>
<p>每次通过代理服务器转发请求或响应时，会追加写入Via首部信息。通过设置组织内部的代理服务器可做到针对特定URI访问的控制。</p>
<h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p>HTTP协议的请求和响应报文中必定包含HTTP首部。</p>
<p>HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成2种类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.端到端首部（End-to-end Header）</span><br><span class="line">2.逐跳首部（Hop-by-hop Header）</span><br></pre></td></tr></table></figure>
<p>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号<code>:</code>分隔，即：<code>首部字段名:字段值</code>。</p>
<ul>
<li>HTTP首部字段根据实际用途被分为以下4种类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.通用首部字段：如Via（代理服务器的相关信息），指请求报文和响应报文</span><br><span class="line">双方都会使用的首部（使用首部字段Via是为了追踪客户端与服务器之间的</span><br><span class="line">请求和响应报文的传输路径；首部字段Via不仅用于追踪报文的转发，还可</span><br><span class="line">避免请求回环的发生，所以必须在经过代理时附加该首部字段内容）</span><br><span class="line">2.请求首部字段；</span><br><span class="line">3.响应首部字段；</span><br><span class="line">4.实体首部字段。</span><br></pre></td></tr></table></figure>
<ul>
<li>指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">缓存指令类型：</span><br><span class="line">no-cache指令：不缓存过期的资源</span><br><span class="line">no-store指令：是真正的不进行缓存</span><br><span class="line"></span><br><span class="line">no-transform指令：使用no-transform指令规定无论是在请求还是响应</span><br><span class="line">中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图</span><br><span class="line">片等类似操作</span><br></pre></td></tr></table></figure>
<ul>
<li><code>HTTP/1.1</code>特性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1版本的默认连接都是持久连接</span><br><span class="line"></span><br><span class="line">HTTP/1.1的传输编码方式仅对分块传输编码有效</span><br></pre></td></tr></table></figure>
<ul>
<li>Warning首部的格式如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning:[警告码] [警告的主机:端口号] “[警告内容]” ([日期时间])</span><br></pre></td></tr></table></figure>
<h5 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h5><p>Accept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。若想要给显示的媒体类型增加优先级，则使用q=来额外表示权重值，用分号（；）进行分隔。权重值q的范围是0~1（可精确到小数点后3位），且1为最大值。不指定权重q值时，默认权重为q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。（q是指qvalue，即quality factor）</p>
<p>首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号。<strong>Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。</strong>首部字段Host和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段Host必须存在的意义。</p>
<p>请求被发送至服务器时，请求中的主机名会用IP地址直接替换解决。在GET或HEAD方法中使用首部字段If-None-Match可获取最新的资源。只要查看Referer就能知道请求的URI是从哪个Web页面发起的。首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>
<ul>
<li>响应首部字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首部字段ETag能告知客户端实体标识。它是一种可将资源以字符串形式做唯</span><br><span class="line">一性标识的方式。服务器会为每份资源分配对应的ETag值。当资源更新时，</span><br><span class="line">ETag值也需要更新。生成ETag值时，并没有统一的算法规则，而仅仅是由</span><br><span class="line">服务器来分配。</span><br><span class="line"></span><br><span class="line">若在下载过程中出现连接中断、再连接的情况，都会依照ETag值来指定资源。</span><br><span class="line"></span><br><span class="line">强ETag值，不论实体发生多么细微的变化都会改变其值；弱ETag值只用于</span><br><span class="line">提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag</span><br><span class="line">值，此时会在字段值最开始处附加W/。</span><br><span class="line"></span><br><span class="line">首部字段Server告知客户端当前服务器上安装的HTTP服务器应用程序的信息。</span><br></pre></td></tr></table></figure>
<ul>
<li>实体首部字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内容编码是指在不丢失实体信息的前提下所进行的压缩。</span><br><span class="line"></span><br><span class="line">Content-MD5过程处理：由于HTTP首部无法记录二进制值，所以要通过Base64编码处理。</span><br></pre></td></tr></table></figure>
<ul>
<li>其他首部字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首部字段P3P属于HTTP响应首部，通过利用P3P（The Platform for </span><br><span class="line">Privacy Preferences，在线隐私偏好平台）技术，可以让Web网站上的</span><br><span class="line">个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的</span><br></pre></td></tr></table></figure>
<h5 id="Cookie用于管理服务器与客户端之间的状态"><a href="#Cookie用于管理服务器与客户端之间的状态" class="headerlink" title="Cookie用于管理服务器与客户端之间的状态"></a>Cookie用于管理服务器与客户端之间的状态</h5><p>Cookie的工作机制是用户识别及状态管理。Web网站（服务器端）为了管理用户的状态会通过Web浏览器（客户端），把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie。</p>
<ul>
<li>Cookie的安全性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，</span><br><span class="line">所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。</span><br></pre></td></tr></table></figure>
<p>一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显示删除Cookie的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie的实质性删除操作。</p>
<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>在HTTP协议中有可能存在信息窃听或身份伪装等安全问题。HTTPS通信机制可以有效地防止这些问题（确保Web安全的HTTPS）。</p>
<ul>
<li>环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP是可能被窃听的网络。</span><br><span class="line">如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后</span><br><span class="line">的报文信息本身还是会被看到的。</span><br></pre></td></tr></table></figure>
<ul>
<li>策略</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加密处理防止被窃听。</span><br><span class="line">目前加密技术，是应对如何防止窃听保护信息的对策中最为普及的技术。</span><br></pre></td></tr></table></figure>
<ul>
<li>加密对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.通信的加密（HTTP协议中没有加密机制，但可以通过和SSL（Secure </span><br><span class="line">Socket Layer，安全套接层）或TLS（Transport Layer Security，</span><br><span class="line">安全传输层协议）的组合使用，加密HTTP的通信内容）。</span><br><span class="line"></span><br><span class="line">与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协</span><br><span class="line">议）或HTTP over SSL。</span><br><span class="line"></span><br><span class="line">SSL提供认证和加密处理及摘要功能。</span><br><span class="line"></span><br><span class="line">2.内容的加密。</span><br></pre></td></tr></table></figure>
<p>HTTP协议中的请求和响应不会对通信方进行确认。通信过程中校验所使用的证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。<strong>HTTP通信过程中防止篡改的方法：常用MD5和SHA-1等散列值校验，数字签名等方法。</strong></p>
<h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>HTTP+加密+认证+完整性保护=HTTPS（HTTP加上加密处理和认证以及完整性保护后即是HTTPS）。HTTPS是身披SSL外壳的HTTP。<strong>要进行HTTPS通信，证书是必不可少的，而使用的证书必须向认证机构（CA）购买。</strong></p>
<ul>
<li>HTTPS的解释</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协</span><br><span class="line">议代替而已。通常HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL</span><br><span class="line">通信，再由SSL和TCP通信了。</span><br><span class="line"></span><br><span class="line">SSL是独立于HTTP的协议，SSL是当前应用最广泛的网络安全技术。</span><br></pre></td></tr></table></figure>
<ul>
<li>加密</li>
</ul>
<p>近代的加密方法中加密算法是公开的，而密钥却是保密的。加密和解密都会用到密钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.共享密钥加密：</span><br><span class="line">加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto </span><br><span class="line">system），也被叫做对称密钥加密</span><br><span class="line"></span><br><span class="line">2.公开密钥加密：</span><br><span class="line">公开密钥加密方式很好地解决了共享密钥加密的困难。公开密钥加密使用一</span><br><span class="line">对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。（公开密钥加</span><br><span class="line">密，私有密钥解密）（公开密钥和私有密钥是配对的一套密钥）</span><br><span class="line"></span><br><span class="line">3.混合加密机制：</span><br><span class="line">将公开密钥加密和共享密钥加密组合起来使用。公开密钥加密用于传递在稍</span><br><span class="line">后共享密钥加密中会用到的密钥。公开密钥加密处理起来较共享密钥加密复</span><br><span class="line">杂，通信过程中会影响效率。</span><br></pre></td></tr></table></figure>
<ul>
<li>SSL的慢</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SSL的慢分两种：</span><br><span class="line">一种是指通信慢；</span><br><span class="line">另一种是指由于大量消耗CPU及内存等资源（因SSL必须进行加密处理），</span><br><span class="line">导致处理速度变慢（加密处理会消耗硬件资源，导致负载增强）。速度慢可</span><br><span class="line">通过SSL加速器（专用服务器（硬件））进行改善。</span><br></pre></td></tr></table></figure>
<h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><p>某些Web页面只想让特定的用户浏览，或者干脆仅本人可见。为达到这个目标，必不可少的就是<strong>认证功能</strong>。</p>
<ul>
<li>核对认证</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">核对认证的原则基于：</span><br><span class="line">登录者本人才知道的信息；</span><br><span class="line">登录者本人才会有的信息。</span><br></pre></td></tr></table></figure>
<ul>
<li>核对的信息通常有</li>
</ul>
<p><code>密码；动态令牌；数字证书；生物认证；IC卡</code></p>
<ul>
<li>HTTP使用的认证方式：（四种）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、BASIC认证：基本认证，采用Base64编码方式（这不是加密处理），安</span><br><span class="line">全等级不高</span><br><span class="line"></span><br><span class="line">2、DIGEST认证：摘要认证，使用质询/响应的方式进行认证（认证过程中</span><br><span class="line">涉及质询码，响应码）</span><br><span class="line"></span><br><span class="line">3、SSL认证：SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。</span><br><span class="line">为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客</span><br><span class="line">户端必须安装此证书（客户端证书需要支付一定费用才能使用）。</span><br><span class="line">SSL客户端认证采用双因素认证（证书认证、基于表单认证）：第一个认证</span><br><span class="line">因素的SSL客户端证书用来认证客户端计算机，另一个认证因素的密码则用</span><br><span class="line">来确定这是用户本人的行为。</span><br><span class="line"></span><br><span class="line">4、FormBase认证：基于表单认证，运用到Session管理（应用场景：服</span><br><span class="line">务器端对认证状态和SessionID进行关联并管理）及Cookie应用。</span><br><span class="line">过程：客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以</span><br><span class="line">POST方法把请求发送给服务器。这时会使用HTTPS通信来进行HTML表单画</span><br><span class="line">面的显示和用户输入数据的发送。</span><br></pre></td></tr></table></figure>
<p>加盐措施，即通信双方约定随机串的规则，用该随机串对指定的对象进行加工，使对象的特征模糊化。</p>
<h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><h5 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h5><p>SPDY：开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）（对Web本身的速度提升，还可通过如改善Web内容的编写方式等进行优化）。</p>
<p>现有Web实现尽可能实时地显示内容的更新，即服务器上一有内容更新，就需要直接把更新的内容反馈到客户端的界面上，以下HTTP标准会成为瓶颈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、一条连接上只可发送一个请求。</span><br><span class="line">2、请求只能从客户端开始。客户端不可以接收除响应以外的指令。</span><br><span class="line">3、请求/响应首部未经压缩就发送。首部信息越多延迟越大。</span><br><span class="line">4、发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</span><br><span class="line">5、可任意选择数据压缩格式。非强制压缩发送。</span><br></pre></td></tr></table></figure>
<p>SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与运输层之间通过新加会话层的形式运作。考虑到安全性问题，SPDY规定通信中使用SSL。SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。<br>使用SPDY后，HTTP协议额外获得以下功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、多路复用流；</span><br><span class="line">2、赋予请求优先级；</span><br><span class="line">3、压缩HTTP首部；</span><br><span class="line">4、推送功能；</span><br><span class="line">5、服务器提示功能。</span><br></pre></td></tr></table></figure>
<h5 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h5><p><code>WebSocket</code>，即Web浏览器与Web服务器之间全双工通信标准<br>一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行（可互相发送JSON、XML、HTML或图片等任意格式的数据）。由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p>
<p>成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。</p>
<ul>
<li>WebSocket协议的主要特点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、推送功能；</span><br><span class="line">2、减少通信量。</span><br></pre></td></tr></table></figure>
<p>（补充：Web是基于HTTP协议运作的，因此在构建Web服务器或访问Web站点时，需事先设置防火墙HTTP(80/tcp)和HTTPS(443/tcp)的权限。防火墙的基本功能就是禁止非指定的协议和端口号的数据包通过。）</p>
<h3 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h3><p>Web页面几乎全由HTML构建（平时我们浏览的Web页面几乎全是使用HTML写成的。由HTML构成的文档经过浏览器的解析、渲染后，呈现出来的结果就是Web页面）。</p>
<p><strong>构建Web内容的技术</strong></p>
<ul>
<li><code>HTML、CSS</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTML（HyperText Markup Language ，超文本标记语言）</span><br><span class="line">HTML文档中被&lt;&gt;包围着的文字就是标签。</span><br><span class="line"></span><br><span class="line">设计应用CSS</span><br><span class="line">CSS（Cascading Style Sheets，层叠样式表）</span><br><span class="line">CSS可以指定如何展现HTML内的各种元素，属于样式表标准之一。</span><br><span class="line">CSS的理念就是让文档的结构和设计分离，达到解耦的目的。</span><br><span class="line"></span><br><span class="line">XML（eXtensible Markup Language，可扩展标记语言）</span><br></pre></td></tr></table></figure>
<ul>
<li>DOM（Document Object Model，文档对象模型）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOM是用以操作HTML文档和XML文档的API（Application Programming Interface，应用编程接口）。</span><br><span class="line">通过调用JavaScript等脚本语言对DOM的操作，可以以更为简单的方式控制HTML的改变。</span><br></pre></td></tr></table></figure>
<ul>
<li>CGI（Common Gateway Interface，通用网关接口）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGI，是指Web服务器在接收到客户端发送过来的请求后转发给程序的一组</span><br><span class="line">机制。在CGI的作用下，程序会对请求内容做出相应的动作，如创建HTML等</span><br><span class="line">动态内容。使用CGI的程序叫做CGI程序，通常是用Perl、PHP、Ruby和C</span><br><span class="line">等编程语言编写而成。（CGI是将请求转给CGI程序处理的一种机制）</span><br></pre></td></tr></table></figure>
<ul>
<li>Servlet</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Servlet是一种能在服务器上创建动态内容的程序。Servlet是用Java语</span><br><span class="line">言实现的一个接口。Servlet的运行环境叫做Web容器或Servlet容器。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>RSS（简易信息聚合，也叫聚合内容）</p>
</li>
<li><p>JSON（JavaScript Object Notation）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSON（JavaScript Object Notation）是一种以</span><br><span class="line">JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语</span><br><span class="line">言。能够处理的数据类型有：false/null/true/对象/数组/数字/字符</span><br><span class="line">串，这7种类型。JSON让数据更轻更纯粹。</span><br></pre></td></tr></table></figure>
<p>由程序创建的内容称为动态内容，事先准备好的内容称为静态内容（Web应用作用于动态内容之上）。动态HTML，是指使用客户端脚本语言将静态的HTML内容变成动态的技术的总称。</p>
<h3 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h3><ul>
<li>针对Web应用的攻击模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主动攻击：主要攻击服务器上的资源</span><br><span class="line">被动攻击：主要攻击用户的资源和权限；利用被动攻击对企业内网发动攻击（利用用户身份的攻击）</span><br></pre></td></tr></table></figure>
<ul>
<li>实施Web应用的安全对策可大致分为以下两部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、客户端的验证</span><br><span class="line">2、Web应用端（服务器端）的验证</span><br><span class="line">     2.1输入值验证</span><br><span class="line">     2.2输出值转义</span><br></pre></td></tr></table></figure>
<p>多数情况下采用JavaScript在客户端验证数据，但JavaScript存在被篡改或关闭的可能，不适合将JavaScript验证作为安全的防范对策。保留客户端验证只是为了尽早地辨识输入错误，起到提高UI体验的作用。</p>
<p>从数据库或文件系统、HTML、邮件等输出Web应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。</p>
<ul>
<li>OS命令注入攻击</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OS命令注入攻击（OS Command Injection）是指通过Web应用，执行非</span><br><span class="line">法的操作系统命令达到攻击的目的。只要在能调用shell函数的地方就有存</span><br><span class="line">在被攻击的风险。</span><br><span class="line">可以从Web应用中通过Shell来调用操作系统命令。倘若调用Shell时存在</span><br><span class="line">疏漏，就可以执行插入非法的OS命令。</span><br><span class="line">通过OS注入攻击可执行OS上安装着的各种程序。</span><br></pre></td></tr></table></figure>
<ul>
<li>DoS攻击（服务停止攻击或拒绝服务攻击）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DoS攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。</span><br><span class="line"></span><br><span class="line">主要有以下两种DoS攻击方式：</span><br><span class="line">1、集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态。</span><br><span class="line">2、通过攻击安全漏洞使服务停止。</span><br></pre></td></tr></table></figure>
<ul>
<li>其它</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%0D%0A代表HTTP报文中的换行符</span><br><span class="line"></span><br><span class="line">会话管理是用来管理用户状态的必备功能</span><br><span class="line"></span><br><span class="line">彩虹表：预先已收集的明文与散列值的匹配表</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/数据结构与算法图表（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/23/数据结构与算法图表（一）/" class="post-title-link" itemprop="url">数据结构与算法图表（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-23 20:12:27" itemprop="dateCreated datePublished" datetime="2019-01-23T20:12:27+08:00">2019-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>常用数据结构和算法知识结构图</p>
<p><img src="/2019/01/23/数据结构与算法图表（一）/数据结构和算法知识结构图.jpg" alt="数据结构和算法知识结构图"></p>
<p>（来源：《数据结构与算法之美》）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/数据结构与算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/23/数据结构与算法/" class="post-title-link" itemprop="url">数据结构与算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-23 10:02:48" itemprop="dateCreated datePublished" datetime="2019-01-23T10:02:48+08:00">2019-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">知识需要沉淀，不要想试图一下子掌握所有</span><br><span class="line">学习知识的过程是反复迭代、不断沉淀的过程</span><br></pre></td></tr></table></figure>
<h3 id="数据结构和算法的概念"><a href="#数据结构和算法的概念" class="headerlink" title="数据结构和算法的概念"></a>数据结构和算法的概念</h3><ul>
<li>广义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据结构就是指一组数据的存储结构。</span><br><span class="line">算法就是操作数据的一组方法。</span><br></pre></td></tr></table></figure>
<ul>
<li>狭义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等具体的使用场景。</span><br></pre></td></tr></table></figure>
<h3 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据结构和算法是相辅相成的。</span><br><span class="line">数据结构是为算法服务的，算法要作用在特定的数据结构之上。</span><br><span class="line">数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。</span><br><span class="line">因此，无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">因为数组具有随机访问的特点，</span><br><span class="line">常用的二分查找算法需要用数组来存储数据。</span><br><span class="line">但如果我们选择链表这种数据结构，二分查找算法就无法工作了，</span><br><span class="line">因为链表并不支持随机访问。</span><br></pre></td></tr></table></figure>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>常用的数据结构和算法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据结构：</span><br><span class="line">数组、链表、栈、队列、散列表</span><br><span class="line">二叉树、堆、跳表、图、Trie树</span><br><span class="line"></span><br><span class="line">算法：</span><br><span class="line">递归、排序、二分查找、搜索、哈希算法</span><br><span class="line">贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</span><br></pre></td></tr></table></figure>
<p><a href="https://88benxiaoyang.github.io/2019/01/23/数据结构与算法图表（一）/" target="_blank" rel="noopener">数据结构和算法知识点图</a></p>
<ul>
<li>学习理解数据结构和算法，可从下面几个点进行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. 来历</span><br><span class="line">b. 自身特点</span><br><span class="line">c. 适合解决的问题</span><br><span class="line">d. 实际的应用场景</span><br></pre></td></tr></table></figure>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ul>
<li>复杂度分析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复杂度分析，是数据结构与算法中最重要的概念，是数据结构和算法学习的精髓。</span><br></pre></td></tr></table></figure>
<p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。</p>
<p>判断算法的优劣：从时间、空间复杂度进行分析。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>如何分析、统计算法的执行效率和资源消耗</li>
</ul>
<p>数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以<strong>执行效率</strong>是算法一个非常重要的考量指标。</p>
<p>通过<code>时间、空间复杂度分析</code>衡量你编写的算法代码的执行效率。只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。</p>
<p><strong>算法的优劣（即算法执行效率的好坏），体现到实现算法的代码执行完成所用的时间长短和所占用的内存大小上。</strong></p>
<p>算法的执行效率，粗略地讲，就是算法代码执行的时间。</p>
<p><strong>所有代码的执行时间<code>T(n)</code>与每行代码的执行次数<code>n</code>成正比。</strong></p>
<p>时间复杂度，即衡量算法代码执行时间的长短。</p>
<ul>
<li>大<code>O</code>时间复杂度表示法</li>
</ul>
<p>公式： <code>T(n) = O(f(n))</code><br>解释： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T(n):表示代码执行的时间；</span><br><span class="line">n:表示数据规模的大小；</span><br><span class="line">f(n):表示每行代码执行的次数总和；</span><br><span class="line">O:表示代码的执行时间T(n)与f(n)表达式成正比。</span><br></pre></td></tr></table></figure>
<p>大<code>O</code>时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度。</strong></p>
<p>因为时间复杂度表示的是一个变化趋势，所以当<code>n</code>很大时，公式中的<strong>低阶、常量、系数</strong>三部分并左右增长趋势，所以都可以忽略，只需要记录一个最大量级就可以了。</p>
<p>渐进时间复杂度，即大<code>O</code>时间复杂度，简称时间复杂度。</p>
<p><strong>在采用大<code>O</code>标记复杂度的时候，可以忽略系数，即<code>O(Cf(n)) = O(f(n))</code>。</strong></p>
<h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>如何分析一段代码的时间复杂度（三个常用的方法）</p>
<ul>
<li><ol>
<li>只关注循环执行次数最多的一段代码</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大 O 这种复杂度表示方法只是表示一种变化趋势。通常会忽略掉公式中的</span><br><span class="line">常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以在分析一</span><br><span class="line">个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一</span><br><span class="line">段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代</span><br><span class="line">码的时间复杂度。</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
</ol>
</li>
</ul>
<p><strong>就时间复杂度的概念来说，时间复杂度表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，都可以忽略掉，因为常量本身对增长趋势并没有影响。</strong>所以当常量很大时，虽然对代码的执行时间会有很大影响，但是从时间复杂度的概念来说，常量的执行时间可以忽略掉。</p>
<p><strong>时间复杂度，描述趋势的一个概念。</strong></p>
<ul>
<li><ol start="3">
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
</li>
</ul>
<h5 id="常见的复杂度量级"><a href="#常见的复杂度量级" class="headerlink" title="常见的复杂度量级"></a>常见的复杂度量级</h5><p><img src="/2019/01/23/数据结构与算法/复杂度量级.jpg" alt="复杂度量级"></p>
<p>常见的复杂度量级粗略地可以分为两类：<code>多项式量级</code>和<code>非多项式量级</code>。当数据规模<code>n</code>越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以<strong>非多项式时间复杂度</strong>的算法其实是非常低效的算法。</p>
<ul>
<li><ol>
<li><code>O(1)</code></li>
</ol>
</li>
</ul>
<p>首先必须明确一个概念，<code>O(1)</code>只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。只要代码的执行时间不随<code>n</code>的增大而增长，这样代码的时间复杂度都记作<code>O(1)</code>。</p>
<p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是<code>O(1)</code>。</p>
<ul>
<li><ol start="2">
<li><code>O(logn)</code>、<code>O(nlogn)</code></li>
</ol>
</li>
</ul>
<p><code>O(nlogn)</code>是一种非常常见的算法时间复杂度。如，归并排序、快速排序的时间复杂度都是<code>O(nlogn)</code>。</p>
<ul>
<li><ol start="3">
<li><code>O(m+n)</code>、<code>O(m*n)</code></li>
</ol>
</li>
</ul>
<p>对于<code>m</code>、<code>n</code>表示两个数据规模的这种情况，由于无法事先评估<code>m</code>和<code>n</code>谁的量级大，所以在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中的一个。所以时间复杂度为<code>O(m+n)</code>的算法对应的公式为：<code>T1(m) + T2(n) = O(f(m) + g(n))</code>。乘法法则继续有效：<code>T1(m)*T2(n) = O(f(m)*f(n))</code>。</p>
<h5 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h5><p><strong>空间复杂度全程是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</strong></p>
<p>常见的数据结构和算法的复杂度趋势</p>
<p><img src="/2019/01/23/数据结构与算法/常见的数据结构和算法的复杂度趋势.jpg" alt="常见的数据结构和算法的复杂度趋势"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：表示内存的消耗；</span><br><span class="line">时间复杂度：表示执行的快慢。</span><br></pre></td></tr></table></figure>
<h5 id="最好、最坏、平均、均摊时间复杂度"><a href="#最好、最坏、平均、均摊时间复杂度" class="headerlink" title="最好、最坏、平均、均摊时间复杂度"></a>最好、最坏、平均、均摊时间复杂度</h5><p>为了表示代码在不同情况下的不同时间复杂度，需要引入三个概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最好情况时间复杂度；</span><br><span class="line">最坏情况时间复杂度；</span><br><span class="line">平均情况时间复杂度。</span><br></pre></td></tr></table></figure>
<p>通常，最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。</p>
<p>平均情况时间复杂度（简称：平均时间复杂度）的全称叫“加权平均时间复杂度”或“期望时间复杂度”。</p>
<p>运用最好、最坏、平均时间复杂度，是只有在同一块代码在不同的情况下，时间复杂度有量级的差别，才会使用最好、最坏、平均这三种复杂度表示法来区分。</p>
<p>摊还分析法分析出来的算法复杂度称为均摊时间复杂度。</p>
<p>摊还分析法分析出来的均摊时间复杂度的使用场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，就可以将这一组操作放在一块分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</span><br></pre></td></tr></table></figure>
<p>引入最好、最坏、平均、均摊时间复杂度这几个复杂度概念，是因为，同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。引入这几个概念之后，可以更加全面地表示一段代码的执行效率。</p>
<p>Tip:<a href="https://share.weiyun.com/5D2VFqS" target="_blank" rel="noopener">复杂度学习图谱参考</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/数据持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/10/数据持久化/" class="post-title-link" itemprop="url">数据持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-10 18:46:41" itemprop="dateCreated datePublished" datetime="2019-01-10T18:46:41+08:00">2019-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端/" itemprop="url" rel="index"><span itemprop="name">移动端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="plist文件存储数据"><a href="#plist文件存储数据" class="headerlink" title="plist文件存储数据"></a><code>plist</code>文件存储数据</h3><ul>
<li>生成<code>plist</code>文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.建立文件管理</span><br><span class="line">NSFileManager *fm = [NSFileManager defaultManager];</span><br><span class="line"></span><br><span class="line">2.找到 Documents 文件所在的路径</span><br><span class="line">NSArray *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line"></span><br><span class="line">3.取得第一个 Documents 文件夹的路径</span><br><span class="line">NSString *filePath = [path objectAtIndex:0];</span><br><span class="line"></span><br><span class="line">4.把要生成的 plist 文件名称(xxx.plist)添加到文件夹路径后面</span><br><span class="line">NSString *plistPath = [filePath stringByAppendingPathComponent:@&quot;xxx.plist&quot;];</span><br><span class="line"></span><br><span class="line">5.创建文件</span><br><span class="line">[fm createFileAtPath:plistPath contents:nil attributes:nil];</span><br><span class="line"></span><br><span class="line">//操作过程中如需删除文件，用以下代码</span><br><span class="line">[fm removeItemAtPath:plistPath error:nil];</span><br></pre></td></tr></table></figure>
<ul>
<li>往<code>plist</code>文件中写入数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注：将数据存入 plist 文件之前，先确定所存储的数据类型，根据所存储的数据类型构建对应的对象。</span><br><span class="line">以存储的数据类型为字典为例，在写入数据之前，需要把数据先存入字典中。</span><br><span class="line"></span><br><span class="line">1.创建字典并把数据存入字典中</span><br><span class="line">NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;key1&quot;,@&quot;value1&quot;,@&quot;key2&quot;,@&quot;value2&quot;, nil];</span><br><span class="line"></span><br><span class="line">2.把字典写入 plist 文件</span><br><span class="line">[dic writeToFile:plistPath atomically:YES];</span><br></pre></td></tr></table></figure>
<ul>
<li>从<code>plist</code>文件中读取数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.根据“生成`plist`文件”的过程，获取 plist 文件所在的路径</span><br><span class="line"></span><br><span class="line">2.读取plist文件，用 plist 所存储的数据类型对应的对象接收所读出的数据（如：存储的是字典用字典接收；存储的是数组用数组接收），以字典为例。</span><br><span class="line">NSDictionary *dic2 = [NSDictionary dictionaryWithContentsOfFile:plistPath];</span><br><span class="line"></span><br><span class="line">3.根据字典的取值规则，取到所需数据</span><br></pre></td></tr></table></figure>
<ul>
<li>示例（将从服务器请求到的数据存入<code>plist</code>文件）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.解析请求到的数据</span><br><span class="line">NSMutableArray *dataArr = [responseDictionary objectForKey:@&quot;dataList&quot;];</span><br><span class="line"></span><br><span class="line">2.建立文件夹管理</span><br><span class="line">NSFileManager *fm = [NSFileManager defaultManager];</span><br><span class="line"></span><br><span class="line">3.找到Documents文件所在的路径</span><br><span class="line">NSArray *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line"></span><br><span class="line">4.取得第一个Documents文件夹的路径</span><br><span class="line">NSString *filePath = [path objectAtIndex:0];</span><br><span class="line"></span><br><span class="line">5.把要存储数据的 plist 文件名称追加到路径后面</span><br><span class="line">NSString *plistPath = [filePath stringByAppendingPathComponent:@&quot;xxx.plist&quot;];</span><br><span class="line"></span><br><span class="line">6.开始创建文件</span><br><span class="line">[fm createFileAtPath:plistPath contents:nil attributes:nil];</span><br><span class="line"></span><br><span class="line">7.往 plist 文件中写入数据</span><br><span class="line">[dataArr writeToFile:plistPath atomically:YES];</span><br></pre></td></tr></table></figure>
<h3 id="归档-解档"><a href="#归档-解档" class="headerlink" title="归档/解档"></a>归档/解档</h3><p>要将一个自定义的类进行归档，那么类里面的每个属性都必须是可以被归档的，如果是不能归档的类型，可以把他转化为<code>NSValue</code>进行归档，然后在读出来的时候再转化为相应的类。</p>
<p>自定义的类需要实现：</p>
<ul>
<li>归档方法，<code>encodeWithCoder</code></li>
<li>解档方法，<code>decodeObjectForKey</code>，通常在<code>initWithCoder</code>中调用</li>
<li>拷贝方法，<code>copyWithZone</code>，实现字符串的<code>copy</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/Mac快捷键/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/10/Mac快捷键/" class="post-title-link" itemprop="url">Mac快捷键</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-10 10:00:59" itemprop="dateCreated datePublished" datetime="2019-01-10T10:00:59+08:00">2019-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>隐藏所有窗口并显示桌面：<code>Fn + F11</code></p>
</li>
<li><p>显示/隐藏 隐藏文件：<code>Command + Shift + .</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/Xcode快捷键/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/10/Xcode快捷键/" class="post-title-link" itemprop="url">Xcode快捷键</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-10 09:37:00" itemprop="dateCreated datePublished" datetime="2019-01-10T09:37:00+08:00">2019-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端/" itemprop="url" rel="index"><span itemprop="name">移动端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">缩写说明:</span><br><span class="line">cmd:command;  ctr:control;  sft:shift</span><br><span class="line"></span><br><span class="line">cmd + r: 运行</span><br><span class="line">cmd + .: Stop Run</span><br><span class="line">cmd + [: 左缩进</span><br><span class="line">cmd + ]: 右缩进</span><br><span class="line">cmd + /: 注释或取消注释</span><br><span class="line">cmd + \: 设置或取消断点</span><br><span class="line">Esc : 显示代码提示菜单</span><br><span class="line">cmd ＋ ←: 移动光标到本行行首  </span><br><span class="line">cmd ＋ →: 移动光标到本行行尾</span><br><span class="line">sft ＋ cmd ＋ ←: 选择到行首</span><br><span class="line">sft ＋ cmd ＋ →: 选择到行尾</span><br><span class="line">ctr + K: 删除本行</span><br><span class="line">ctr + cmd + 上下箭头: 切换.h和.m文件</span><br><span class="line">ctr + cmd + ←: 回到上一级界面</span><br><span class="line">ctr + cmd + →: 回到下一级界面</span><br><span class="line">cmd + sft + F: 项目中查找</span><br><span class="line">sft + 左右箭头: 向左或向右选择一个字符</span><br><span class="line">ctr + sft + 左右箭头: 向左或向右选择一个词汇</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/10/Xcode快捷键/Xcode快捷键.jpeg" alt="Xcode快捷键"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
