<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ben&#39;Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Ben&#39;Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ben&#39;Blog">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Ben'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ben'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工欲善其事，必先利其器</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/应用优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/08/应用优化/" class="post-title-link" itemprop="url">应用优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-08 13:35:03" itemprop="dateCreated datePublished" datetime="2019-10-08T13:35:03+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><ol>
<li><p>分析解决内存泄漏</p>
<ul>
<li>设置僵尸(<code>Zombie</code>)拦截获取更详细的崩溃异常信息</li>
<li>分析检查是否存在内存泄漏(静态、动态)<ul>
<li>静态分析方式:(<code>shift + command + b</code>)或(<code>Xcode -&gt; product -&gt; analyze</code>)</li>
<li>动态分析方式:(因有些内存泄漏需要在应用使用过程中才产生。如：图片资源加载)使用工具:<code>Instruments</code> -&gt; <code>Leaks</code>(开启工具:<code>command + I</code>或<code>Xcode -&gt; product -&gt; profile</code>)</li>
</ul>
</li>
</ul>
</li>
<li><p>使用懒加载方式进行优化(懒加载能实现延迟加载的效果)</p>
</li>
</ol>
<h5 id="调试会用到的LLDB命令"><a href="#调试会用到的LLDB命令" class="headerlink" title="调试会用到的LLDB命令"></a>调试会用到的<code>LLDB</code>命令</h5><ul>
<li>在控制台里打印<code>view</code>的层级<ul>
<li><code>po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]</code></li>
</ul>
</li>
<li>输出整个视图的层次结构<ul>
<li><code>po [[UIWindow keyWindow] _autolayoutTrace]</code></li>
</ul>
</li>
<li>检查视图控制器<ul>
<li><code>po [[[UIWindow keyWindow] rootViewController] _printHierarchy]</code></li>
</ul>
</li>
<li>查看<code>xcode</code>的栈帧信息(打印栈帧信息)<ul>
<li><code>bt</code></li>
</ul>
</li>
<li><code>image</code>命令可用于寻址，有多个组合命令，在控制台输入<code>help image</code>可查看<code>image</code>的用法</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/不同编码标准的编码与解码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/30/不同编码标准的编码与解码/" class="post-title-link" itemprop="url">不同编码标准的编码与解码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-30 10:03:41" itemprop="dateCreated datePublished" datetime="2019-09-30T10:03:41+08:00">2019-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="常用的编码标准"><a href="#常用的编码标准" class="headerlink" title="常用的编码标准"></a>常用的编码标准</h3><ul>
<li>常用的编码标准<ol>
<li><code>GBK</code></li>
<li><code>UTF-8</code></li>
<li><code>ISO8859-1</code></li>
</ol>
</li>
</ul>
<h3 id="编码基础知识"><a href="#编码基础知识" class="headerlink" title="编码基础知识"></a>编码基础知识</h3><p>为方便表示各种各样的语言，逐渐出现很多标准编码。最早的编码是<code>ISO8859-1</code>和<code>ASCII</code>编码相似。重要的有如下几个：</p>
<ul>
<li><p><code>ISO8859-1</code>(通常称为<code>Latin-1</code>)</p>
<ul>
<li>属于<strong>单字节编码</strong>(一字节八位)，最多能表示的字符范围是<code>0～255</code></li>
<li>应用于英文系列，如，字母<code>a</code>的编码为<code>0x61=97</code></li>
<li><code>ISO8859-1</code>编码表示的字符范围很窄，无法表示中文字符</li>
<li>由于是单字节编码，和计算机最基础的表示单位一致，因此多数时候仍旧使用<code>ISO8859-1</code>编码来表示。在很多协议上，默认使用该编码</li>
<li>如，虽然“中文”两个字不存在<code>ISO8859-1</code>编码。以<code>GB2312</code>编码为例，对应的是“<code>d6d0 cec4</code>”两个字符，使用<code>ISO8859-1</code>编码时，则将它拆开为<code>4</code>个字节来表示“<code>d6 d0 ce c4</code>”。事实上，在进行存储的时候，是以字节为单位处理的。而如用<code>UTF</code>编码来对“中文”进行编码，使用<code>ISO8859-1</code>对其编码时，则是将它拆开为<code>6</code>个字节“<code>e4 b8 ad e6 96 87</code>”来表示。因此可以看出，通过<code>ISO8859-1</code>进行编码表示的方法，需要以另一种编码为基础。</li>
</ul>
</li>
<li><p><code>GB2312/GBK</code></p>
<ul>
<li>这是汉字的国标码，专门用来表示汉字，是双字节编码。</li>
<li>英文字母和<code>ISO8859-1</code>一致，即英文字母兼容<code>ISO8859-1</code>编码</li>
<li><code>GBK</code>编码能够用来同时表示繁体字和简体字，而<code>GB2312</code>只能表示简体字，<code>GBK</code>是兼容<code>GB2312</code>编码的</li>
</ul>
</li>
<li><p><code>unicode</code></p>
<ul>
<li>这是最统一的编码，可以用来表示所有语言的字符</li>
<li>是定长双字节，也有四字节的编码</li>
<li>包括英文字母在内</li>
<li>它是不兼容<code>ISO8859-1</code>编码的，也不兼容其他编码</li>
<li>相对于<code>ISO8859-1</code>编码来说，<code>unicode</code>编码只是在前面增加了一个<code>0</code>字节，如字母<code>a</code>对应的<code>unicode</code>编码为“<code>00 61</code>”</li>
<li>注：定长编码便于计算机处理，<code>GB2312/GBK</code>不是定长编码。因<code>unicode</code>可以用来表示所有字符，所以在很多软件内部是使用<code>unicode</code>编码来处理的，如<code>java</code></li>
</ul>
</li>
<li><p><code>UTF</code></p>
<ul>
<li><code>unicode</code>编码不兼容<code>ISO8859-1</code>编码，而且容易占用更多的空间，因对于英文字母<code>unicode</code>也需要两个字节来表示，所以<code>unicode</code>不便于传输和存储，因此产生了<code>UTF</code>编码</li>
<li><code>UTF</code>编码兼容<code>ISO8859-1</code>编码，同时也可以用来表示所有语言的字符</li>
<li><code>UTF</code>编码是不定长编码，每一个字符的长度从<code>1～6</code>个字节不等</li>
<li><code>UTF</code>编码自带简单的校验功能</li>
<li>通常英文字母都是用一个字节表示，汉字用三个字节</li>
<li>注：虽说<code>UTF</code>是为了使用更少的空间而使用的，这只是相对于<code>unicode</code>编码来说的，如果已知是汉字，则使用<code>GB2312/GBK</code>无疑是最节省的。虽然<code>UTF</code>编码对汉字使用三个字节，但即使对于汉字网页，<code>UTF</code>编码也会比<code>unicode</code>编码节省，因网页中包含了很多的英文字符</li>
</ul>
</li>
</ul>
<h3 id="常用编码的区别"><a href="#常用编码的区别" class="headerlink" title="常用编码的区别"></a>常用编码的区别</h3><p><code>unicode</code>、<code>UTF-8</code>、<code>ISO8859-1</code>的区别，通过对字符的编码来体现。以对“中文”进行编码为例(查询对应的编码表得到下面结果)：</p>
<ul>
<li><code>GB2312</code> 编码为 “<code>d6d0 cec4</code>”</li>
<li><code>unicode</code> 编码为 “<code>4e2d 6587</code>”</li>
<li><code>UTF</code> 编码为 “<code>e4b8ad e69687</code>”</li>
<li>这两个汉字没有<code>ISO8859-1</code>编码，但可以用<code>ISO8859-1</code>编码来表示</li>
</ul>
<h3 id="编码的使用"><a href="#编码的使用" class="headerlink" title="编码的使用"></a>编码的使用</h3><p>字符串在<code>java</code>内存中总是按<code>unicode</code>编码存储的。</p>
<p><code>UTF-8</code>可以用来表示/编码所有字符。</p>
<p>在<code>java</code>中，使用<code>setCharacterEncoding</code>来设置<code>HTTP</code>请求时相应的编码，如果不指定提交内容的编码，则默认使用<code>ISO8859-1</code>编码，这样在处理时需要做进一步的处理。值得注意的是在执行<code>setCharacterEncoding()</code>之前，不能执行任何<code>getParameter()</code>。而且，该指定只对<code>POST</code>方法有效，对<code>GET</code>方法无效。因，<code>POST</code>方法在执行第一个<code>getParameter()</code>的时候，<code>java</code>将会按照编码分析所有的提交内容，而后续的<code>getParameter()</code>不再进行分析，所以<code>setCharacterEncoding()</code>无效。对于<code>GET</code>方法提交表单，提交的内容在<code>URL</code>中，一开始就已经按照编码分析所有的提交内容，<code>setCharacterEncoding()</code>自然就无效。</p>
<p>注：<code>ISO8859-1</code>是<code>java</code>网络传输使用的标准字符集，<code>GB2312</code>是标准中文字符集，当需要进行提交表单等网络传输操作的时候，需要把<code>ISO8859-1</code>转换为<code>GB2312</code>字符集显示，否则如果按浏览器的<code>GB2312</code>格式来解析<code>ISO8859-1</code>字符集的话，由于两者不兼容，所以会出现乱码。</p>
<ul>
<li><p>规律</p>
<ul>
<li><code>UTF-8</code>编码可以用<code>GBK</code>和<code>ISO8859-1</code>解码后编回去</li>
<li><code>GBK</code>编码后只能用<code>ISO8859-1</code>解码后编回去</li>
</ul>
</li>
<li><p>在<code>JSP</code>页面获取表单的值时会出现乱码，有两种解决方法</p>
<ol>
<li>在调用<code>getParameter</code>之前通过<code>request.setCharacterEncoding</code>设置字符编码</li>
<li>调用<code>new String(str.getBytes(&quot;iso8859-1&quot;), &quot;UTF-8&quot;);</code>编码后解码</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/27/Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/27/Block/" class="post-title-link" itemprop="url">Block</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-27 15:53:28" itemprop="dateCreated datePublished" datetime="2019-09-27T15:53:28+08:00">2019-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Block简介"><a href="#Block简介" class="headerlink" title="Block简介"></a><code>Block</code>简介</h3><p><code>Block</code>作为<code>C</code>语言的扩展，和其他语言的闭包或<code>lambda</code>表达式是一回事。由于<code>OC</code>在<code>iOS</code>中不支持<code>GC</code>机制，使用<code>Block</code>必须自己管理内存。内存管理正是使用<code>Block</code>坑最多的地方，错误的内存管理要么导致<code>return cycle</code>内存泄漏，要么内存被提前释放导致<code>crash</code>。</p>
<p><code>lambda</code>表达式是一个匿名函数，即没有函数名的函数，<code>lambda</code>表达式可以表示闭包。</p>
<p><code>Block</code>包含的两个部分：</p>
<ol>
<li><code>Block</code>执行的代码，这是在编译的时候已经生成好的</li>
<li>一个包含<code>Block</code>执行时需要的所有外部变量值的数据结构。<code>Block</code>将使用到的、作用域捕获到的变量的值建立一份快照拷贝到栈上。</li>
</ol>
<ul>
<li><code>block</code>与函数的区别<ol>
<li><code>Block</code>的使用很像函数指针，不过与函数最大的不同是：<code>Block</code>可以访问函数以外、词法作用域以内的外部变量的值。即，<code>Block</code>不仅实现函数的功能，还能携带函数的执行环境。</li>
<li><code>Block</code>与函数另一个不同是，<code>Block</code>类似<code>OC</code>的对象，可以使用自动释放池管理内存(但<code>Block</code>并不完全等同于<code>OC</code>对象)</li>
</ol>
</li>
</ul>
<h3 id="Block基本语法"><a href="#Block基本语法" class="headerlink" title="Block基本语法"></a><code>Block</code>基本语法</h3><p><code>Block</code>语法结构如下图</p>
<p><img src="/2019/09/27/Block/block语法结构图.png" alt="block语法结构图"></p>
<h3 id="Block在内存中的位置"><a href="#Block在内存中的位置" class="headerlink" title="Block在内存中的位置"></a><code>Block</code>在内存中的位置</h3><p>根据<code>Block</code>在内存中的位置分为三种类型<code>NSGlobalBlock</code>，<code>NSStackBlock</code>, <code>NSMallocBlock</code></p>
<ul>
<li><code>NSGlobalBlock</code>：类似函数，位于<code>text</code>段<ul>
<li>当使用<code>Block</code>时，没有使用<code>Block</code>以外的任何外部变量，<code>Block</code>不需要建立局部变量值的快照。这种情况下，使用的<code>Block</code>与函数没有任何区别，此时编译器把使用的<code>Block</code>放到了<code>text</code>代码段。</li>
</ul>
</li>
<li><code>NSStackBlock</code>：位于栈内存，函数返回后<code>Block</code>将无效<ul>
<li>当使用的<code>Block</code>内部捕获了外部局部变量，此时在定义(注：是定义，不是运行)所使用的<code>Block</code>时，所捕获到的局部变量的当前值被<code>copy</code>到栈上，作为常量供当前的<code>Block</code>使用。此时在<code>Block</code>内，被捕获的变量是只读的，如果想在<code>Block</code>内改变被捕获的变量的值，在定义局部变量时要用<code>__block</code>修饰。</li>
<li><code>Block</code>中使用<code>__block</code>修饰的变量时，将取变量此刻运行时的值，而不是定义时的快照。</li>
</ul>
</li>
<li><code>NSMallocBlock</code>：位于堆内存</li>
</ul>
<h3 id="Block的copy、retain、release操作"><a href="#Block的copy、retain、release操作" class="headerlink" title="Block的copy、retain、release操作"></a><code>Block</code>的<code>copy</code>、<code>retain</code>、<code>release</code>操作</h3><p>不同于<code>NSObject</code>的<code>copy</code>、<code>retain</code>、<code>release</code>操作，对<code>Block</code>进行<code>copy</code>、<code>retain</code>、<code>release</code>有以下特性：</p>
<ul>
<li><code>Block_copy</code>与<code>copy</code>等效，<code>Block_release</code>与<code>release</code>等效</li>
<li>对<code>Block</code>不管是<code>retain</code>、<code>copy</code>、<code>release</code>都不会改变引用计数<code>retainCount</code>，<code>retainCount</code>始终是<code>1</code></li>
<li><strong><code>NSGlobalBlock</code>：<code>retain</code>、<code>copy</code>、<code>release</code>操作都无效</strong></li>
<li><code>NSStackBlock</code><ul>
<li><code>retain</code>、<code>release</code>操作无效。必须注意的是，<code>NSStackBlock</code>在函数返回后，<code>Block</code>内存将被回收，即使<code>retain</code>也没用</li>
<li>容易犯的错误是<code>[[mutableArray addObject:stackBlock]</code>，在函数出栈后，从<code>mutableArray</code>中取到的<code>stackBlock</code>已经被回收，变成了野指针。正确的做法是先将<code>stackBlock`</code>copy<code>到堆上，然后加入数组：</code>[mutableArray addObject:[[stackBlock copy] autorelease]]`</li>
<li>支持<code>copy</code>，<code>copy</code>之后生成新的<code>NSMallocBlock</code>类型对象</li>
</ul>
</li>
<li><strong><code>NSMallocBlock</code>支持<code>retain</code>、<code>release</code>，虽然<code>retainCount</code>始终是<code>1</code>，但内存管理器中仍然会增加、减少计数。<code>copy</code>之后不会生成新的对象，只是增加了一次引用，类似<code>retain</code></strong></li>
<li>尽量不要对<code>Block</code>使用<code>retain</code>操作</li>
</ul>
<h3 id="Block对不同类型的变量的存取"><a href="#Block对不同类型的变量的存取" class="headerlink" title="Block对不同类型的变量的存取"></a><code>Block</code>对不同类型的变量的存取</h3><ul>
<li><strong>局部自动变量</strong>，在<code>Block</code>中只读。<code>Block</code>定义时<code>copy</code>变量的值，在<code>Block</code>中作为常量使用，所以即使变量的值在<code>Block</code>外改变，也不影响它在<code>Block</code>中的值</li>
<li><strong><code>static</code>变量、全局变量</strong>。如果把变量定义成全局的、或<code>static</code>类型的变量，<code>Block</code>就可以对它进行读写了。因为全局变量或静态变量在内存中的地址是固定的，<code>Block</code>在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时<code>copy</code>的常量。这种情况下，<code>Block</code>外部对变量的更新会影响<code>Block</code>中已被捕获的变量的取值，同样在<code>Block</code>内对捕获到的变量的更新也会影响到<code>Block</code>外部对应的变量的值</li>
<li><code>Block</code>变量，被<code>__block</code>修饰的变量称作<code>Block</code>变量。基本类型的<code>Block</code>变量等效于全局变量或静态变量</li>
</ul>
<p><code>Block</code>被另一个<code>Block</code>使用时，另一个<code>Block</code>被<code>copy</code>到堆上时，被使用的<code>Block</code>也会被<code>copy</code>。但<strong>作为参数的<code>Block</code>是不会发生<code>copy</code>的</strong>。无论<code>Block</code>在堆上还是在栈上，作为参数的<code>Block</code>不会发生<code>copy</code>。</p>
<ul>
<li><p><code>OC</code>对象，不同于基本类型，<code>Block</code>会引起对象的引用计数变化</p>
<ul>
<li>全局对象、静态对象，在内存中的位置是确定的，所以<code>Block copy</code>时不会<code>retain</code>对象</li>
<li>实例对象，在<code>Block copy</code>时也没有直接<code>retain</code>实例对象本身，但会<code>retain self</code>，所以在<code>Block</code>中可以直接读写实例对象变量</li>
<li>局部对象，在<code>Block copy</code>时，系统自动<code>retain</code>对象，增加其引用计数</li>
<li><code>block</code>对象，在<code>Block copy</code>时，不会<code>retain</code></li>
</ul>
</li>
<li><p>非<code>OC</code>对象，如<code>GCD</code>队列<code>dispatch_queue_t</code>，<code>Block copy</code>时并不会自动增加其引用计数，这点要非常小心</p>
</li>
</ul>
<h3 id="retain-cycle"><a href="#retain-cycle" class="headerlink" title="retain cycle"></a><code>retain cycle</code></h3><ul>
<li><p>产生原因：<code>retain cycle</code>问题的根源在于<code>Block</code>和<code>obj</code>可能会互相强引用，互相<code>retain</code>对方，这样就导致了<code>retain cycle</code>，最后这个<code>Block</code>和<code>obj</code>就变成了孤岛，谁也释放不了谁</p>
</li>
<li><p>解决办法：解决这个问题的办法是使用<strong>弱引用</strong>打断<code>retain cycle</code>。使用<code>__block</code>修饰<code>obj</code>。</p>
</li>
</ul>
<p>在<code>Block</code>中使用成员变量，<code>retain</code>的不是这个变量，而会<code>retain self</code>。</p>
<p>注：<code>MRC</code>中<code>__block</code>是不会引起<code>retain</code>；但在<code>ARC</code>中<code>__block</code>则会引起<code>retain</code>。<code>ARC</code>中应该使用<code>__weak</code>或<code>__unsafe_unretained</code>弱引用。<code>__weak</code>只能在<code>iOS5</code>以后使用。</p>
<p>避免<code>Block</code>使用对象被提前释放，此时必须要注意对象和<code>Block</code>的生命周期。</p>
<h5 id="错误使用-block的场景"><a href="#错误使用-block的场景" class="headerlink" title="错误使用__block的场景"></a>错误使用__block的场景</h5><p>因担心<code>retain cycle</code>错误的使用<code>__block</code></p>
<p>将<code>Block</code>作为参数传给<code>dispatch_async</code>时，系统会将<code>Block</code>拷贝到堆上，如果<code>Block</code>中使用了实例变量，还将<code>retain self</code>，因为<code>dispatch_async</code>并不知道<code>self</code>会在什么时候被释放，为了确保系统调度执行<code>Block</code>中的任务时<code>self</code>没有被意外释放掉，<code>dispatch_async</code>必须自己<code>retain</code>一次<code>self</code>，任务完成后再<code>release self</code>。但这里使用<code>__block</code>，使<code>dispatch_async</code>没有增加<code>self</code>的引用计数，这使得在系统在调度执行<code>Block</code>之前，<code>self</code>可能已被销毁，但系统并不知道这个情况，导致<code>Block</code>被调度执行时<code>self</code>已经被释放导致<code>crash</code>。</p>
<p>上述情况下不要使用<code>__block</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/Mac上给移动硬盘分区方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/26/Mac上给移动硬盘分区方法/" class="post-title-link" itemprop="url">Mac上给移动硬盘分区方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-26 17:21:30" itemprop="dateCreated datePublished" datetime="2019-09-26T17:21:30+08:00">2019-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>不兼容：一直在<code>Windows</code>上使用的移动硬盘居然在<code>Mac</code>上只读<br>原因：因为<code>Mac</code>与<code>PC</code>移动硬盘的存储格式不一样</p>
<h3 id="格式化选择"><a href="#格式化选择" class="headerlink" title="格式化选择"></a>格式化选择</h3><ul>
<li><p>移动硬盘格式化通常有三种选择</p>
<ol>
<li><p><code>MS-DOS(FAT)</code>格式</p>
<ul>
<li>这种格式，<code>Mac</code>和<code>PC</code>都能读写，限制是不能存放大于<code>4GB</code>的东西。适合在<code>Mac</code>和<code>PC</code>之间共享文件</li>
</ul>
</li>
<li><p><code>NTFS</code>格式</p>
<ul>
<li>这种格式是微软编的，但是在<code>Mac</code>上只读。在<code>Mac</code>上不能将硬盘格式化为<code>NTFS</code></li>
<li>在<code>MS-DOS(FAT)</code>格式下无法存储的<code>&gt;4GB</code>的文件可以在这种格式下存储</li>
</ul>
</li>
<li><p><code>Mac OS Extended</code>格式</p>
<ul>
<li><code>Mac</code>专有的格式，这种格式的硬盘/<code>U</code>盘在<code>PC</code>上不可见</li>
<li>可以用来做<code>Time Machine</code>备份。<a href="https://support.apple.com/zh-cn/HT201250" target="_blank" rel="noopener">Time Machine的使用</a></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><p>以为<code>500GB</code>的移动硬盘分区为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">150 GB ”Shared” MS-DOS(FAT) </span><br><span class="line">100 GB ”Huge Files” NTFS </span><br><span class="line">250 GB ”Time Machine Disk” Mac OS Extended </span><br><span class="line"></span><br><span class="line">每个分区的大小根据实际使用情况来确定</span><br></pre></td></tr></table></figure>
<ul>
<li>操作步骤<ol>
<li>把移动硬盘接到<code>Mac</code>上</li>
<li>打开<code>Disk Utility</code>(磁盘工具)这个<code>app</code></li>
<li>选择你的移动硬盘，点击右侧的<code>erase</code>标签</li>
<li>把移动硬盘擦除为<code>MS-DOS(FAT)</code>格式 </li>
<li>点击<code>Partition</code>(分割)标签</li>
<li>更改<code>Partition Layout</code>为<code>3 partitions</code>，也就是重新划分为三个分区</li>
<li>给每个分区起名，最好是能见名知义的名字</li>
<li>为每个分区选择容量和格式</li>
<li>点击“应用”，等待</li>
<li>弹出硬盘，换到一台<code>Windows PC</code>上，接入移动硬盘</li>
<li>右键点击<code>Huge Files</code>(<code>Mac</code>上分出来的分区)这个硬盘，选择“格式化” </li>
<li>把这个分区的格式改成<code>NTFS</code>然后等待完成，大约数分钟</li>
<li>完成！现在这个<code>500GB</code>的移动硬盘就有三个分区了，可以应付各种情况。</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/iOS生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/26/iOS生命周期/" class="post-title-link" itemprop="url">iOS生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-26 16:27:12" itemprop="dateCreated datePublished" datetime="2019-09-26T16:27:12+08:00">2019-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>iOS</code>系统的资源是有限的，应用程序在前台和后台的状态是不一样的。在后台时，程序会受到系统的很多限制，这样可以提高电池的使用和用户体验。</p>
<h3 id="应用程序生命周期"><a href="#应用程序生命周期" class="headerlink" title="应用程序生命周期"></a>应用程序生命周期</h3><h5 id="应用程序的状态"><a href="#应用程序的状态" class="headerlink" title="应用程序的状态"></a>应用程序的状态</h5><ul>
<li><code>Not Running</code> -&gt; 未运行，程序没有启动</li>
<li><code>Inactive</code> -&gt; 未激活，程序在前台运行，不过没有接收到事件。在没有事件处理的情况下程序通常停留在这个状态</li>
<li><code>Active</code> -&gt; 激活，程序在前台运行而且接收到了事件。</li>
<li><code>Background</code> -&gt; 后台，程序在后台而且能执行代码。大多数程序进入这个状态后会在这个状态上停留一会，时间到之后进入挂起状态(<code>Suspended</code>)。</li>
<li><code>Suspened</code> -&gt; 挂起，程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。挂起时，程序还是停留在内存中，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</li>
<li>程序状态变化图如下</li>
</ul>
<p><img src="/2019/09/26/iOS生命周期/程序状态变化图.png" alt="程序状态变化图"></p>
<h5 id="程序状态对应的代理方法如下"><a href="#程序状态对应的代理方法如下" class="headerlink" title="程序状态对应的代理方法如下"></a>程序状态对应的代理方法如下</h5><ul>
<li><code>willFinishLaunchingWithOptions</code> - 告诉代理进程启动但还没进入状态保存</li>
<li><code>didFinishLaunchingWithOptions</code> - 告诉代理启动基本完成程序准备开始运行</li>
<li><code>applicationWillResignActive</code> - 当应用程序将要进入非活动状态执行(在此期间，应用程序不接收消息或事件。如来电话了会进入这种状态)</li>
<li><code>applicationDidBecomeActive</code> - 当应用程序进入活动状态执行这个代理方法</li>
<li><code>applicationDidEnterBackground</code> - 当应用程序被推送到后台的时候调用(所以要设置后台继续运行，则在这个函数里面设置即可)</li>
<li><code>applicationWillEnterForeground</code> - 当应用程序从后台将要重新回到前台的时候调用</li>
<li><code>applicationWillTerminate</code> - 当应用程序将要退出时被调用(通常是用来保存数据和一些退出前的清理工作。需要设置<code>UIApplicationExitsOnSuspend</code>的键值)</li>
<li><code>applicationDidFinishLaunching</code> - 当应用程序载入后执行</li>
</ul>
<h5 id="应用程序使用过程中，代理方法的执行顺序"><a href="#应用程序使用过程中，代理方法的执行顺序" class="headerlink" title="应用程序使用过程中，代理方法的执行顺序"></a>应用程序使用过程中，代理方法的执行顺序</h5><ul>
<li><p>启动程序时：</p>
<ul>
<li><code>willFinishLaunchingWithOptions</code></li>
<li><code>didFinishLaunchingWithOptions</code></li>
<li><code>applicationDidBecomeActive</code></li>
</ul>
</li>
<li><p>按下<code>home</code>键：</p>
<ul>
<li><code>applicationWillResignActive</code></li>
<li><code>applicationDidEnterBackground</code></li>
</ul>
</li>
<li><p>双击<code>home</code>键，再打开程序：</p>
<ul>
<li><code>applicationWillEnterForeground</code></li>
<li><code>applicationDidBecomeActive</code></li>
</ul>
</li>
<li><p>加载应用程序进入前台，所执行的代理方法如下图</p>
</li>
</ul>
<p><img src="/2019/09/26/iOS生命周期/加载应用程序进入前台代理方法的执行.png" alt="加载应用程序进入前台代理方法的执行"></p>
<ul>
<li>加载应用程序进入后台，所执行的代理方法如下图</li>
</ul>
<p><img src="/2019/09/26/iOS生命周期/加载应用程序进入后台代理方法的执行.png" alt="加载应用程序进入后台代理方法的执行"></p>
<h5 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h5><p><code>main</code>函数是程序启动的入口，在<code>iOS app</code>中，<code>main</code>函数的功能被最小化，它的主要工作都交给了<code>UIKit framework</code>。<code>iOS</code>中<code>main</code>类中的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>UIApplicationMain</code>函数有四个参数，不需要改变这些参数值。每个参数的意义和作用：</p>
<ol>
<li><code>argc</code>和<code>argv</code>参数包含了系统带过来的启动时间；</li>
<li>第三个参数确定了主要应用程序类的名称，这个参数指定为<code>nil</code>，这样<code>UIKit</code>就会使用默认的程序类<code>UIApplication</code>；</li>
<li>第四个参数是程序自定义的代理类名，这个类负责系统和代码之间的交互。它一般在<code>Xcode</code>新建项目时会自动生成。</li>
</ol>
</li>
<li><p><code>UIApplicationMain</code>函数加载了程序主界面的文件。虽然这个函数加载了界面文件，但是没有放到应用程序的<code>windows</code>上，需要在<code>Delegate</code>的<code>willFinishLaunchingWithOptions</code>方法中加载它。一个应用程序可以有一个主的<code>storyboard</code>文件或者有一个主的<code>nib</code>文件，但不能同时有两个存在。如果程序在启动时没有自动加载主要的故事板或<code>nib</code>文件，可以在<code>willFinishLaunchingWithOptions</code>方法里准备<code>windows</code>的展示。</p>
</li>
</ul>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>当一个基于警告式的中断发生时，如有电话打进来时，这时程序会临时进入<code>inactive</code>状态，用户可选择如何处理这个中断，如下图：</p>
<p><img src="/2019/09/26/iOS生命周期/程序中断流程.png" alt="程序中断流程"></p>
<p>除电话打进来时，应用程序会发生响应中断。还有以下情况发生时应用程序也会发生响应中断：</p>
<ol>
<li>在<code>iOS5</code>,通知不会把程序变成为激活状态，通知会显示在状态栏上，如果你；拉下状态栏，程序会变成<code>inactive</code>，把状态栏放回去，程序变回<code>active</code>；</li>
<li>按锁屏键也是另外一种程序的中断，当你按下锁屏键，系统屏蔽了所有触摸事件，把<code>app</code>放到了后台，这时<code>app</code>状态是<code>inactive</code>，并进入后台。</li>
</ol>
<p>当应用程序响应中断时，应在<code>applicationWillResignActive</code>代理方法中，进行以下操作：</p>
<ul>
<li>停止<code>timer</code>和其他周期性的任务</li>
<li>停止任何正在运行的请求</li>
<li>暂停视频的播放</li>
<li>如果是游戏那就暂停它</li>
<li>减少<code>OpenGL ES</code>的帧率</li>
<li>挂起任何分发的队列和不重要的操作队列(你可以继续处理网络请求或其他时间敏感的后台任务)<br>当程序回到<code>active</code>状态时，根据情况，在<code>applicationDidBecomeActive</code>代理方法中恢复响应中断时暂停的任务。如重新开始<code>timer</code>，继续分发队列，提高<code>OpenGL ES</code>的帧率。不过游戏要回到暂停状态，不能自动开始。</li>
</ul>
<ul>
<li>应用程序转到后台运行，流程图如下</li>
</ul>
<p><img src="/2019/09/26/iOS生命周期/应用程序转到后台运行流程图.png" alt="应用程序转到后台运行流程图"></p>
<p>只有在<code>iOS4</code>以上系统或者支持多任务的设备，应用程序才能在后台运行，不然会直接结束状态。</p>
<p>应用程序进入后台时，应执行以下操作：</p>
<ol>
<li>保存用户数据或状态信息，所有没写到磁盘的文件或信息，在进入后台时，最后都写到磁盘去，因为程序可能在后台被杀死；</li>
<li>释放尽可能释放的内存。</li>
</ol>
<p><code>applicationDidEnterBackgound:</code>方法有大概<code>5</code>秒的时间让你完成这些任务。如果超过时间还有未完成的任务，你的程序就会被终止而且从内存中清除。如果还需要长时间的运行任务，可以调用  <code>beginBackgroundTaskWithExpirationHandler</code>方法去请求后台运行时间和启动线程来运行长时间运行的任务。</p>
<p>在后台时，每个应用程序都应该释放最大的内存。系统努力的保持更多的应用程序在后台同时运行。不过当内存不足时，会终止一些挂起的程序来回收内存，那些内存最大的程序首先被终止。因此在程序进入后台时，像下面类型的对象应该去掉强引用：</p>
<ol>
<li>可以重新加载的 大的视频或数据文件；</li>
<li>任何没用而且可以轻易创建的对象。</li>
</ol>
<p>在后台时，为了减少程序占用的内存，系统会自动再回收一些系统帮助你开辟的内存。如：</p>
<ol>
<li>系统回收<code>Core Animation</code>的后备存储；</li>
<li>去掉任何系统引用的缓存图片；</li>
<li>去掉系统管理数据缓存强引用。</li>
</ol>
<ul>
<li>程序从后台返回前台的流程如下图：</li>
</ul>
<p><img src="/2019/09/26/iOS生命周期/程序从后台返回前台的流程图.png" alt="程序从后台返回前台的流程图"></p>
<p>当<code>app</code>处于挂起状态时，它是不能执行任何代码的。因此它不能处理在挂起期间发过来的通知，比如方向改变，时间改变，设置的改变还有其他影响程序展现或状态的通知。在程序进入后台或返回前台时，程序都要正确的处理这些通知。</p>
<p><code>app</code>如果终止了，系统会调用<code>app</code>的代理的方法<code>applicationWillTerminate</code>这样可以让你做一些清理工作。你可以保存一些数据或<code>app</code>的状态。这个方法也有<code>5</code>秒钟的限制。</p>
<p>程序终止的情况：</p>
<ol>
<li>设备不支持多任务；</li>
<li>在<code>Info.plist</code>文件中，程序包含了<code>UIApplicationExitsOnSuspend</code>键；</li>
<li>用户手动关闭应用程序。</li>
</ol>
<h5 id="Main-Run-Loop"><a href="#Main-Run-Loop" class="headerlink" title="Main Run Loop"></a><code>Main Run Loop</code></h5><p><code>Main Run Loop</code>负责处理用户相关的事件。<code>UIApplication</code>对象在程序启动时启动<code>main run Loop</code>，它处理事件和更新视图的界面。看<code>Main Run Loop</code>就知道，它是运行在程序的主线程上的。这样保证了接收到用户相关操作的事件是按顺序处理的。</p>
<ul>
<li><code>Main Run Loop</code>处理事件的流程图如下</li>
</ul>
<p><img src="/2019/09/26/iOS生命周期/MainRunLoop处理事件流程图.png" alt="MainRunLoop处理事件流程图"></p>
<p>用户操作设备，相关的操作事件被系统生成并通过<code>UIKit</code>的指定端口进行分发。事件在内部排成队列，一个个的分发到<code>Main run loop</code>去做处理。<code>UIApplication</code>对象是第一个接收到事件的对象，它决定事件如何被处理。触摸事件分发到主窗口，窗口再分发到对应触发触摸事件的<code>View</code>。</p>
<h3 id="VC生命周期"><a href="#VC生命周期" class="headerlink" title="VC生命周期"></a><code>VC</code>生命周期</h3><ul>
<li><p><code>VC</code>生命周期中涉及的函数有</p>
<ul>
<li><code>alloc</code> - 创建对象，分配空间</li>
<li><code>init</code> - 初始化对象，初始化数据</li>
<li><code>loadView</code> - 此时<code>VC</code>还未初始化，可以重写该方法自定义控制器的<code>View</code>，若重写逻辑，就不能调用<code>[super loadView]</code></li>
<li><code>viewDidLoad</code> - 在<code>VC</code>的生命周期中，该函数只会被调用一次。此时<code>view</code>已经初始化好，可以做一些页面初始化任务，由于此时<code>view</code>的<code>bounds</code>尚未确定，所以不适合写<code>frame</code>类型的布局代码，但是给视图添加约束没有影响</li>
<li><code>viewWillAppear</code> - <code>VC</code>的视图将要出现时调用，这个一般在<code>view</code>被添加到<code>superview</code>之前，切换动画之前调用，在这里可以进行一些显示前的处理，这个函数可能会调用多次，适合做一些与视图及视图出现相关联的任务，例如改变状态栏的方向、风格，键盘弹出</li>
<li><code>viewWillLayoutSubviews</code> - <code>view</code>的子视图即将布局，触发条件是<ul>
<li><code>view</code>被添加到视图层次中</li>
<li><code>view</code>的<code>bounds</code>发生了改变</li>
<li>调用了<code>- setNeedsLayout</code>方法</li>
<li>调用了<code>- layoutIfNeeded</code>方法</li>
</ul>
</li>
<li><code>viewDidLayoutSubviews</code> - 当<code>view</code>的子视图已经布局时，此方法会被调用，触发条件同<code>viewWillLayoutSubviews</code>的触发条件</li>
<li><code>viewDidAppear</code> - 视图完全出现在屏幕中后触发</li>
<li><code>viewWillDisappear</code> - 视图即将从屏幕中消失时触发</li>
<li><code>viewDidDisappear</code> - 视图从屏幕中消失后触发</li>
<li><code>dealloc</code> - 视图被销毁，此处需要对你在<code>init</code>和<code>viewDidLoad</code>中创建的对象进行释放。如果应用程序异常中止，<code>dealloc</code>没有机会被调用</li>
</ul>
</li>
<li><p><code>VC</code>各生命周期函数的调用时机</p>
<ul>
<li>项目创建有<code>A</code>、<code>B</code>两个<code>VC</code>，<code>tag</code>分别为<code>1</code>、<code>2</code></li>
<li>加载<code>A</code>的时候，生命周期函数的调用顺序如下：<ul>
<li><code>1 initWithCoder</code></li>
<li><code>1 loadView</code></li>
<li><code>1 viewDidLoad</code></li>
<li><code>1 viewWillAppear</code></li>
<li><code>1 viewWillLayoutSubviews</code></li>
<li><code>1 viewDidLayoutSubviews</code></li>
<li><code>1 viewDidAppear</code></li>
</ul>
</li>
<li>切换至<code>B</code>的时候，调用顺序依次如下：<ul>
<li><code>2 initWithCoder</code>     //先将2初始化</li>
<li><code>1 prepareForSegue</code>   //调用1的准备过度的函数，所以在该函数中可以对界面B的一些相关属性进行赋值</li>
<li><code>2 loadView</code>          //如果这里进行了重写</li>
<li><code>2 viewDidLoad</code>       //2界面加载</li>
<li><code>1 viewWillDisappear</code></li>
<li><code>2 viewWillAppear</code></li>
<li><code>2 viewWillLayoutSubviews</code></li>
<li><code>2 viewDidLayoutSubviews</code></li>
<li><code>2 viewDidAppear</code></li>
<li><code>1 viewDidDisappear</code></li>
</ul>
</li>
<li>从B切换回A的时候依次调用<ul>
<li><code>2 viewWillDisappear</code></li>
<li><code>1 viewWillAppear</code></li>
<li><code>1 viewDidAppear</code></li>
<li><code>2 viewDidDisappear</code></li>
<li><code>2 dealloc</code></li>
</ul>
</li>
<li>总结<ul>
<li>加载依次为：加载 - 显示 - 布局</li>
<li>完成顺序依次为：完成布局 - 完成显示  - 完成加载</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/25/数据存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/25/数据存储/" class="post-title-link" itemprop="url">数据存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-25 17:26:17" itemprop="dateCreated datePublished" datetime="2019-09-25T17:26:17+08:00">2019-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>谈到数据存储，首先要明确区分两个概念，<strong>数据结构</strong>和<strong>存储方式</strong>。</p>
<ul>
<li><p>数据结构，就是数据存在的形式。除了基本的<code>NSDictionary</code>、<code>NSArray</code>和<code>NSSet</code>这些对象，还有更复杂的如：关系模型、对象图和属性列表多种结构。</p>
</li>
<li><p>存储方式，则简单的分为两种：内存与闪存。内存存储是临时的，运行时有效的，但效率高，而闪存则是一种持久化存储，但产生<code>I/O</code>消耗，效率相对低。把内存数据转移到闪存中进行持久化的操作称为归档。</p>
</li>
</ul>
<p>数据结构和存储方式，二者结合起来才是完整的数据存储方案。如常说的<code>SQLite</code>、<code>CoreData</code>、<code>NSUserDefaults</code>等都是数据存储方案。这些存储方案侧重不同，支持的形式和方式也各不相同，在不同的使用场景下表现也是各有优劣。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存按照保存位置可以分为两类：内存缓存、硬盘缓存</span><br><span class="line">硬盘缓存，即常说的把数据保存在本地，如：FMDB、CoreData、归档、NSUserDefaults、NSFileManager</span><br></pre></td></tr></table></figure>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>万变不离其宗，无论什么数据存储方案都可以用下图来解释</p>
<p><img src="/2019/09/25/数据存储/数据存储本质过程.png" alt="数据存储本质过程"></p>
<h3 id="常用数据存储方案的介绍"><a href="#常用数据存储方案的介绍" class="headerlink" title="常用数据存储方案的介绍"></a>常用数据存储方案的介绍</h3><h4 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a><code>NSUserDefaults</code></h4><ul>
<li><code>NSUserDefaults</code>是一个单例，在整个程序中只有一个实例对象，可用于数据的永久保存，这是它可以让数据自由传递的一个前提。因此常用它保存简单数据。</li>
<li><code>NSUserDefaults</code>支持的数据类型有：<code>NSNumber</code>（<code>NSInteger、float、double</code>），<code>NSString</code>，<code>NSDate</code>，<code>NSData</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>BOOL</code></li>
<li>使用<code>NSUserDefaults</code>进行数据存储操作时，对相同的<code>Key</code>赋值约等于一次覆盖，所以要保证每一个<code>Key</code>的唯一性</li>
<li><code>NSUserDefaults</code>存储的对象全是不可变的，取出的对象也是不可变的</li>
<li>使用<code>NSUserDefaults</code>存储自定义对象<ul>
<li>将自定义类型转换为<code>NSData</code>类型<ul>
<li><code>NSUserDefaults</code>本身不支持自定义对象的存储，不过它支持<code>NSData</code>的类型</li>
<li>场景：当数据重复且多的时候，不想使用<code>SQLite</code>，不想使用<code>NSFileManage</code>的时候，可以通过将数据转换为<code>NSData</code>类型，使用<code>NSUserDefaults</code>存储</li>
<li>但大量重复数据的操作，最好还是使用<code>SQLite</code>存储</li>
<li><code>NSFileManage</code>的使用是，先使用归档，再将文件写入本地</li>
<li>将自定义类型对象转换为<code>NSData</code>类型时，自定义类型需要遵循并实现<code>NSCoding</code>协议中的<code>encodeWithCoder</code>和<code>initWithCoder</code>方法，通过这种方式就可以将自定义类型转换为<code>NSData</code>类型了。将自定义类型的对象转换为<code>NSData</code>类型时，会用到<code>NSKeyedArchiver</code>类进行操作；将<code>NSData</code>转换为自定义类型的对象时，会用到<code>NSKeyedUnarchiver</code>类进行操作。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>NSUserDefaults</code>，用于存储配置信息</p>
<ul>
<li><code>NSUserDefaults</code>被设计用来存储设备和应用的配置信息</li>
<li>它通过一个工厂方法返回默认的、也是最常用到的实例对象</li>
<li>这个对象中储存了系统中用户的配置信息</li>
<li>开发者可以通过这个实例对象对这些已有的信息进行修改，也可以按照自己的需求创建新的配置项</li>
<li><p><code>NSUserDefaults</code>数据组织形式</p>
<ul>
<li><code>NSUserDefaults</code>把配置信息以字典的形式组织起来</li>
<li>支持字典的项包括：字符串或者是数组，除此之外还支持数字等基本格式</li>
<li><code>NSUserDefaults</code>是基础类型的小数据的字典</li>
<li><p>可以通过指定返回类型的方法获取到指定类型的返回值。如下图</p>
<p><img src="/2019/09/25/数据存储/NSUserDefaults字典取值.png" alt="NSUserDefaults字典取值"></p>
</li>
</ul>
</li>
<li><p><code>NSUserDefaults</code>的所有数据都放在内存里，因此操作速度很快</p>
</li>
<li><code>NSUserDefaults</code>提供了一个归档方法：<code>+ (void)synchronize</code>。开发者自定义的配置项，会以<code>plist</code>格式的文件归档在相应应用目录<code>/Library/Preferences/[App_Bundle_Identifier].plist</code>的下面。</li>
</ul>
</li>
</ul>
<h4 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a><code>SQLite</code></h4><ul>
<li><code>SQLite</code>，用于存储查询需求较多的数据<ul>
<li><code>iOS</code>的<code>SDK</code>里预置了<code>SQLite</code>的库，开发者可以自建<code>SQLite</code>数据库</li>
<li><code>SQLite</code>每次写入数据都会产生<code>IO</code>消耗，把数据归档到相应的文件</li>
<li>一般来说应用中格式化的文本类数据可以存放在数据库中，尤其是类似聊天记录、<code>Timeline</code>等这些具有条件查询和排序需求的数据</li>
<li>每一个数据库的句柄都会在内存中被分配一段缓存，用于提高查询效率</li>
<li>由于查询缓存，当产生大量句柄或数据量较大时，会出现缓存过大，造成内存浪费</li>
<li>对复杂的<code>SQLite</code>操作进行封装，可参考<a href="https://github.com/gaosboy/SQLight" target="_blank" rel="noopener">SQLight</a></li>
</ul>
</li>
</ul>
<h4 id="CoreData"><a href="#CoreData" class="headerlink" title="CoreData"></a><code>CoreData</code></h4><ul>
<li><code>CoreData</code>，用于规划应用中的对象<ul>
<li>官方给出的定义是，一个支持持久化的，对象图和生命周期的自动化管理方案</li>
<li>严格意义上说<code>CoreData</code>是一个管理方案，它的持久化可以通过<code>SQLite</code>、<code>XML</code>或二进制文件储存</li>
<li>如官方定义所说，<code>CoreData</code>的作用远远不止储存数据这么简单，它可以把整个应用中的对象建模并进行自动化的管理</li>
<li>从归档文件还原模型时<code>CoreData</code>并不是一次性把整个模型中的所有数据都载入内存，而是根据运行时状态，把被调用到的对象实例载入内存。框架会自动控制这个过程，从而达到控制内存消耗，避免浪费</li>
<li><code>CoreData</code>的使用场景在于：整个应用使用<code>CoreData</code>规划，把应用内的数据通过<code>CoreData</code>建模，完全基于<code>CoreData</code>架构应用</li>
</ul>
</li>
</ul>
<h4 id="定制化方案"><a href="#定制化方案" class="headerlink" title="定制化方案"></a>定制化方案</h4><ul>
<li><p>使用基本对象类型定制的个性化缓存方案</p>
<ul>
<li>案例分析 - <code>Kache</code></li>
<li>这个定制方案适用于互联网应用中对远程数据的缓存，几个限制条件缺一不可</li>
<li>从需求出发分析缓存数据有以下要求：按<code>Key</code>查找，快速读取，写入不影响正常操作，不浪费内存，支持归档。这些都是基本需求，那么再进一步或许还需要固定缓存项数量，支持队列缓存，缓存过期等</li>
<li><p><code>Kache</code>架构分析</p>
<ul>
<li><code>Kache</code>扮演的是一个典型缓存角色。应用加载远程数据生成应用数据对象的同时，通过<code>Kache</code>把数据缓存起来，再次请求则直接通过<code>Kache</code>获取数据</li>
<li>缓存对象可以是<code>NSDictionary</code>、<code>NSArray</code>、<code>NSSet</code>或<code>NSData</code>这些可直接归档的类型，每个缓存对象对应一个<code>Key</code>。缓存对象包括数据和过期时间，内存中存放在一个单例字典中，闪存中每个对象存为一个文件。<code>Key</code>空间按照各种顺序存放缓存对象的<code>Key</code>集合，<code>Pool</code>为固定大小的数组，当数量达到上限，最早过期的一个<code>Key</code>将被删除，对应的缓存对象也被清除。<code>Queue</code>也是固定大小的数组，以先进先出的规则管理<code>Key</code>的增删。每一次有新的缓存对象存入，自动检测<code>Key</code>空间中过期的集合并清除</li>
<li>框架提供<code>save</code>和<code>load</code>方法支持持久化和重新载入</li>
<li>框架由于使用了过期和归档相结合的逻辑，可以保证大部分命中的缓存对象都在内存中，从而获取了较高的效率</li>
<li><a href="https://github.com/gaosboy/kache" target="_blank" rel="noopener">Kache框架源码</a></li>
<li><p><code>Kache</code>结构图</p>
<p><img src="/2019/09/25/数据存储/Kache架构图.png" alt="Kache架构图"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h3><h5 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h5><ul>
<li>给一个变量赋值后在内存里的表示<ul>
<li>如果是<strong>值类型</strong>则直接在<code>stack</code>(堆栈)中分配一块空间。<code>stack</code>的内存区域是由操作系统去管理的</li>
<li>如果是<strong>引用类型</strong>的话会保存成两部分，在<code>heap</code>(<strong>托管堆</strong>)分配一块内存保存<strong>变量的实际值</strong>，再在<code>stack</code>中分配一块内存保存<code>heap</code>中分配的那块内存的地址</li>
<li>基于上述区别，引用类型赋值为<code>null</code>，表示还没在<code>heap</code>中分配内存，只是在<code>stack</code>中分配一块内存，但里面的内容为空，没有保存哪块<code>heap</code>的地址。基于此引用类型可以给赋值为<code>null</code>，而值类型不能赋值为<code>null</code></li>
</ul>
</li>
<li><code>stack</code>中的内存块有多大<ul>
<li>所有引用类型在<code>stack</code>中内存块的大小都一样。具体大小要看操作系统，<code>32</code>位的系统是<code>4</code>个字节，<code>64</code>位系统是<code>8</code>个字节</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/30/消息推送/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/30/消息推送/" class="post-title-link" itemprop="url">消息推送</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-30 09:57:47" itemprop="dateCreated datePublished" datetime="2019-07-30T09:57:47+08:00">2019-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Notification</code>是移动端应用编程中非常常用的一种传递信息的机制，而且可以非常好的节省资源，不用消耗资源来不停地检查信息状态(<code>Poolin</code>g)，在<code>iOS</code>下应用分为两种不同的<code>Notification</code>种类，本地和远程。</p>
<h3 id="本地消息推送"><a href="#本地消息推送" class="headerlink" title="本地消息推送"></a>本地消息推送</h3><p>本地通知(<code>LocalNotification</code>)，实际上是由<code>iOS</code>系统管理的一个功能</p>
<p>应用程序的本地通知是由用户的<code>iOS</code>设备生成并发布的，无论这个应用程序是否运行在前台。就像一个日历应用，或者是一个<code>to-do list</code>应用，可以发出一条本地通知提醒用户计划的日常事务要开始了。</p>
<p>对本地通知的数量限制，<code>iOS</code>最多允许最近本地通知数量是<code>64</code>个，超过限制的本地通知将被<code>iOS</code>忽略。</p>
<p>想让我们的<code>APP</code>实现本地通知功能，必须得到用户的授权。</p>
<ul>
<li><p>本地的<code>Notification</code>由<code>iOS</code>下<code>NotificationManager</code>统一管理，只需要将封装好的本地<code>Notification</code>对象加入到系统<code>Notification</code>管理机制队列中，系统会在指定的时间激发本地<code>Notification</code>，应用程序中只需设计好处理<code>Notification</code>的方法就完成了整个<code>Notification</code>的流程了。</p>
</li>
<li><p>本地<code>Notification</code>所使用的对象是<code>UILocalNotification</code>。<code>UILocalNotification</code>的属性涵盖了所有处理<code>Notification</code>需要的内容</p>
</li>
<li><p><code>UILocalNotification</code>的属性有<code>fireDate</code>、<code>timeZone</code>、<code>repeatInterval</code>、<code>repeatCalendar</code>、<code>alertBody</code>、 <code>alertAction</code>、<code>hasAction</code>、<code>alertLaunchImage</code>、<code>applicationIconBadgeNumber</code>、<code>soundName和userInfo</code></p>
<ul>
<li>其中<code>fireDate</code>、<code>timeZone</code>、<code>repeatInterval</code>和<code>repeatCalendar</code>是用于<code>UILocalNotification</code>的调度<ul>
<li><code>fireDate</code>是<code>UILocalNotification</code>激发的确切时间</li>
<li><code>timeZone</code>是<code>UILocalNotification</code>激发时间是否根据时区改变而改变，如果设置为<code>nil</code>的话，那么<code>UILocalNotification</code>将在一段时间后被激发，而不是某一个确切时间被激发。</li>
<li><code>repeatInterval</code>是<code>UILocalNotification</code>被重复激发之间的时间差，不过时间差是完全根据日历单位(<code>NSCalendarUnit</code>)的，例如每周激发的单位<code>NSWeekCalendarUnit</code>，如果不设置的话，将不会重复激发</li>
<li><code>repeatCalendar</code>是<code>UILocalNotification</code>重复激发所使用的日历单位需要参考的日历，如果不设置的话，系统默认的日历将被作为参考日历</li>
</ul>
</li>
<li><code>UILocalNotification</code>的提醒内容<ul>
<li><code>alertBody</code>、<code>alertAction</code>、<code>hasAction</code>和<code>alertLaunchImage</code>是当应用不在运行时，系统处理</li>
</ul>
</li>
</ul>
</li>
<li><p>如果已经注册了本地通知，当客户端响应通知时：</p>
<ul>
<li><code>APP</code>在前台或者后台收到通知进入前台时会调用<code>didReceiveLocalNotification</code>方法。应用程序正在运行中，设备不会收到提醒</li>
<li>如<code>APP</code>在关闭状态，本地通知会给设备送达一个和远程通知一样的提醒。只能从函数<code>didFinishLaunchingWithOptions</code>的<code>launchOptions</code>中取到我们想要的参数</li>
</ul>
</li>
</ul>
<p><strong>‘UILocalNotification’ is deprecated: first deprecated in iOS 10.0 - Use UserNotifications Framework’s UNNotificationRequest</strong></p>
<h3 id="远程消息推送-APNs"><a href="#远程消息推送-APNs" class="headerlink" title="远程消息推送 - APNs"></a>远程消息推送 - <code>APNs</code></h3><p><code>Apple Push Notification service(APNs)</code>，即苹果推送通知服务，是苹果为<code>APP</code>开发商提供「间接的」推送通知到指定设备的一种服务。官方介绍可见<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html" target="_blank" rel="noopener">APNs Overview</a></p>
<h5 id="原理流程"><a href="#原理流程" class="headerlink" title="原理流程"></a>原理流程</h5><p>通过<code>APNs</code>实现消息推送的过程如下图：</p>
<p><img src="/2019/07/30/消息推送/APNs消息推送的过程.jpg" alt="APNs消息推送的过程"></p>
<p>上图可以分为三个阶段：</p>
<ul>
<li>第一阶段：<code>Push</code>服务器应用程序把要发送的消息、目的<code>iPhone</code>的标识打包，发给<code>APNs</code></li>
<li>第二阶段：<code>APNs</code>在自身的已注册<code>Push</code>服务的<code>iPhone</code>列表中，查找有相应标识的<code>iPhone</code>，并把消息发到<code>iPhone</code></li>
<li>第三阶段：<code>iPhone</code>把发来的消息传递给相应的应用程序， 并且按照设定弹出<code>Push</code>通知</li>
<li><code>Provider</code>是指某个<code>iPhone</code>软件的<code>Push</code>服务器</li>
</ul>
<p><code>APNs</code>实现流程如下图：</p>
<p><img src="/2019/07/30/消息推送/APNs实现流程图.jpg" alt="APNs实现流程图"></p>
<ol>
<li>首先是应用程序注册消息推送</li>
<li><code>iOS</code>跟<code>APNs Server</code>要<code>deviceToken</code>，应用程序接受<code>deviceToken</code></li>
<li>应用程序将<code>deviceToken</code>发送给<code>PUSH</code>服务端程序</li>
<li>服务端程序向<code>APNs</code>服务发送消息</li>
<li><code>APNs</code>服务将消息发送给<code>iPhone</code>应用程序</li>
</ol>
<p>上述流程如下图形象所示：</p>
<p><img src="/2019/07/30/消息推送/推送流程.jpg" alt="推送流程"></p>
<ol>
<li>首先，安装了具有推送功能的应用，我们的设备在有网络的情况下会连接苹果推送服务器，连接过程中，<code>APNs</code>会验证<code>device_token</code>，连接成功后维持一个长连接</li>
<li><code>Provider</code>(我们自己的服务器)收到需要被推送的消息并结合被推送设备的<code>device_token</code>一起打包发送给<code>APNs</code>服务器</li>
<li><code>APNs</code>服务器将推送信息推送给指定<code>device_token</code>的设备</li>
<li>设备收到推送消息后通知我们的应用程序并显示和提示用户(声音、弹出框)</li>
</ol>
<p>推送的前提是装有我们应用的设备需要向<code>APNs</code>服务器注册，注册成功后<code>APNs</code>服务器会返给我们一个<code>device_token</code>，拿到这个<code>token</code>后我们将这个<code>token</code>发给我们自己的应用服务器，当有需要被推送的消息时，我们的应用服务器会将消息按指定的格式打包，然后结合设备的<code>device_token</code>一并发给<code>APNs</code>服务器，由于我们的应用和<code>APNs</code>维持一个基于<code>TCP</code>的长连接，<code>APNs</code>将新消息推送到我们设备上，然后在屏幕上显示出新消息来。</p>
<ul>
<li>设备注册<code>APNs</code>的流程如下图</li>
</ul>
<p><img src="/2019/07/30/消息推送/设备注册APNs的流程图.jpg" alt="设备注册APNs的流程图"></p>
<ul>
<li>注册<code>APNs</code>的执行顺序如下图</li>
</ul>
<p><img src="/2019/07/30/消息推送/注册执行顺序.jpg" alt="注册执行顺序"></p>
<ol>
<li><code>Device</code>连接<code>APNs</code>服务器并携带设备序列号</li>
<li>连接成功，<code>APNs</code>经过打包和处理产生<code>device_token</code>并返回给注册的<code>Device</code></li>
<li><code>Device</code>携带获取的<code>device_token</code>向我们自己的应用服务器注册</li>
</ol>
<p>经过上述流程，完成需要被推送的<code>Device</code>在<code>APNs</code>服务器和我们自己的应用服务器注册。</p>
<p>我们的设备和<code>APNs</code>服务器之间的通讯是基于<code>SSL</code>协议的<code>TCP</code>流通讯，二者之间维持一个长连接，当从<code>APNs</code>服务器注册成功后，一定要将<code>device_token</code>发送给我们的应用服务器。</p>
<p>Tips:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使deviceToken值不一样的情况：重装iOS或更换设备</span><br><span class="line"></span><br><span class="line">无论是iPhone客户端跟APNs，还是Provider和APNs都需要通过证书进行连接</span><br><span class="line"></span><br><span class="line">如何维护消息队列和如何保证消息能被推送到指定的设备上，这些都由苹果APNs给我们做完了</span><br><span class="line"></span><br><span class="line">与用户的交互是弹框提示是否允许推送通知，用户点击“好”iOS操作系统会继续往下走与APNs服务的流程，用户点击“不允许”iOS操作系统不会走与APNs交流的流程</span><br></pre></td></tr></table></figure>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><h6 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h6><p>实现<code>APNs</code>过程中，所需的证书有4个：</p>
<ol>
<li><code>.certSigningRequest</code>(<code>CSR</code>文件)</li>
<li><code>.cer</code>(<code>SSL certificate</code>文件)</li>
<li><code>.mobileprovision</code>(<code>profile</code>证书)(因为推送消息只能在真机上测试)</li>
<li><code>.p12</code>(<code>p12</code>证书)(<code>Provider</code>(<code>JAVA</code>)后台用于连接<code>APNs</code>的证书)</li>
</ol>
<p>上述证书的制作过程如下：</p>
<ul>
<li><p><code>CSR</code>文件(<code>Certificate Signing Request</code>)</p>
<ul>
<li>通过<strong>钥匙串</strong>在本地制作<ul>
<li>钥匙串访问 - 证书助理 - 从证书颁发机构请求证书</li>
<li>邮箱&amp;常用名称 - 存储到磁盘 - 存储到桌面</li>
<li>执行完上述操作后，本地桌面上就生成了一个<code>xxx.certSigningRequest</code>文件</li>
</ul>
</li>
</ul>
</li>
<li><p><code>SSL Certificate</code>文件</p>
<ul>
<li>通过付费账号登录<a href="https://developer.apple.com" target="_blank" rel="noopener">苹果开发者平台</a><ul>
<li>创建<code>Certificate</code>，会需要前面生成的<code>CSR</code>文件，<code>Submit</code>后，创建<code>Certificate</code>完成</li>
<li>新建一个<code>App ID</code>，输入<code>Description</code>、<code>Bundle Identifier</code>，<code>Submit</code>后，新建<code>App ID</code>完成<ul>
<li>新建<code>App ID</code>完成后，对应的<code>App ID</code>下会有相应的<code>SSL Certificate</code>文件，对<code>SSL Certificate</code>进行<code>Configure</code></li>
<li>进行<code>Configure</code>时，需要用到前面生成的<code>CSR</code>文件</li>
<li><code>Configure</code>完成后，<code>SSL Certificate</code>文件就能<code>Download</code>了</li>
<li><code>Download`</code>SSL<code>证书，命名为</code>xxx.cer<code>(双击</code>.cer`文件将其安装到钥匙串中)</li>
<li>执行完上述操作后，<code>App ID</code>下对应的<code>SSL</code>证书状态会变成<code>Enabled</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>准备<code>profile</code>证书，因为推送消息只能在真机上测试，所以要建一个<code>profile</code>证书</p>
<ul>
<li>在之前创建<code>SSL</code>证书的账号下，创建<code>Provisioning Profile</code>证书</li>
<li>选择之前的<code>App ID</code>，并添加测试设备的<code>ID</code></li>
<li><code>Submit</code>后，创建<code>xxx.mobileprovision</code>完成</li>
<li><code>Download`</code>.mobileprovision<code>证书，双击将其加入到</code>Xcode<code>的</code>Provisioning Profiles`中</li>
</ul>
</li>
<li><p>生成后台用于连接<code>APNs</code>的证书</p>
<ul>
<li>打开钥匙串，找到之前安装的<code>.cer</code>证书文件，右键将其导出</li>
<li>导出存储为用于<code>JAVA</code>后台连接<code>APNs</code>的<code>.p12</code>证书。导出存储时输入<code>.p12</code>证书的密码，这个密码<code>JAVA</code>后台使用<code>.p12</code>证书的时候要用到</li>
<li>进行上述操作后，导出<code>xxx.p12</code>证书完成</li>
</ul>
</li>
</ul>
<p>Tips：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">App ID下不同SSL证书的区别：</span><br><span class="line">Development Push SSL Certificate ，与Production Push SSL Certificate</span><br><span class="line">区别在于一个是用于开发的推送证书，一个是用于发布产品的推送证书。</span><br><span class="line">两个证书获取到的终端deviceToken是不一样的。因Development是develop的mobileprovision下获取的；Production是production的mobileprovision获取的。</span><br><span class="line"></span><br><span class="line">Development Push SSL Certificate和Production Push SSL Certificate是有有效时间的：</span><br><span class="line">Development Push SSL Certificate有效期是四个月</span><br><span class="line">Production Push SSL Certificate有效期是一年</span><br><span class="line"></span><br><span class="line">用两个证书生成的P12证书用于JAVA后台连接APNS的服务器地址也是不同的，</span><br><span class="line">Development Push SSL Certificate 对应连接的服务器地址是：gateway.sandbox.push.apple.com。</span><br><span class="line">Production Push SSL Certificate  对应连接的服务器地址是：gateway.push.apple.com。</span><br></pre></td></tr></table></figure>
<h5 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h5><ul>
<li>涉及的操作方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//注册远程通知，在didFinishLaunchingWithOptions中添加下面代码</span><br><span class="line">//通过registerForRemoteNotifications方法，告诉APNs，应用程序能接受push来的通知</span><br><span class="line">[[UIApplication sharedApplication] registerForRemoteNotifications];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">当客户端注册远程通知时，会回调下面两个方法：</span><br><span class="line">如果成功，则回调第一个，客户端把deviceToken取出来发给服务端，push消息的时候要用，发送通知的后台应用程序除了需要知道deviceToken之外，还需要一个与APNs连接的证书；</span><br><span class="line">如果失败，则回调第二个，可以从error参数中看一下失败原因。</span><br><span class="line">**/</span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;&#125;</span><br><span class="line">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error &#123;&#125;</span><br><span class="line"></span><br><span class="line">//处理收到的消息推送</span><br><span class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>应每次程序启动的时候都调用<code>registerForRemoteNotifications</code>来重新获取设备相关的<code>deviceToken</code>，因重装<code>iOS</code>或更换设备，都会使<code>deviceToken</code>的值不一样</p>
</li>
<li><p>当<code>iOS</code>收到远程消息时</p>
<ul>
<li>如果应用程序处于后台，<code>iOS</code>会处理这个消息，比如弹出一个框、在应用程序的<code>icon</code>上显示红色数字<ul>
<li>如果用户通过点击弹框进入程序，<code>iOS</code>会启动程序并调用<code>application:didFinishLaunchingWithOptions</code>并且拿远程消息的<code>payload</code>进行传参，<code>payload</code>的详细格式可见<a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification" target="_blank" rel="noopener">JSON payload</a></li>
<li>如果用户直接点击<code>app icon</code>进入程序，<code>iOS</code>会启动程序并同样调用<code>application:didFinishLaunchingWithOptions</code>，但是传参将不会有远程消息的任何信息</li>
</ul>
</li>
<li>如果应用程序处于前台(即当前正在使用应用程序)，就会调用<code>application:didReceiveRemoteNotification</code></li>
</ul>
</li>
</ul>
<h5 id="APNs"><a href="#APNs" class="headerlink" title="APNs"></a><code>APNs</code></h5><ul>
<li><p><code>APNs</code>的特点</p>
<ul>
<li><code>APNs</code>提供的连接接口是二进制的、<code>streaming TCP socket</code>、异步的。</li>
<li><code>Production</code>环境是<code>gateway.push.apple.com:2195</code></li>
<li><code>Development</code>环境是<code>gateway.sandbox.push.apple.com:2195</code></li>
</ul>
</li>
<li><p><code>APNs</code>与<code>iOS</code>终端</p>
</li>
</ul>
<p><code>iOS</code>设备会持久连接<code>APNs</code>以接受远程消息</p>
<p><code>iOS</code>与<code>APNs</code>连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们的应用和APNs维持一个基于TCP的长连接，APNs将新消息推送到我们设备上，然后在屏幕上显示出新消息来。</span><br><span class="line">我们的设备和APNs服务器之间的通讯是基于SSL协议的TCP流通讯，二者之间维持一个长连接。</span><br><span class="line">我们的设备在有网络的情况下会连接苹果推送服务器，连接过程中，APNs会验证device_token，连接成功后维持一个长连接。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>APNs</code>与<code>Provider</code></li>
</ul>
<p><code>provider</code>发送消息到<code>APNs</code>，然后<code>APNs</code>再发送到目标<code>iOS</code>设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个传输是单向的</span><br><span class="line">这个消息的内容含两部分：设备token和payload</span><br></pre></td></tr></table></figure>
<ul>
<li><p>反馈服务</p>
<ul>
<li>使用场景：有时候<code>APNs</code>发送消息到某设备(<code>deviceToken</code>)某程序(<code>bundle identifier</code>)但是该设备并没有这个程序，多次这种情况之后，<code>APNs</code>会通知<code>provider</code>，通过其连接的一个<strong>反馈服务(<code>a feedback service</code>)</strong></li>
<li><strong>反馈服务</strong>为每一个程序维护了一个失效设备列表，<code>provider</code>应该获取这个列表从而停止向<code>APNs</code>发送以这些设备为目的地的某程序的远程消息</li>
<li><code>Provider</code>应该定期查询这个列表，并且作出对应处理，如:停止向这些的设备发送消息</li>
<li><code>provider</code>访问<code>feedback server</code>通过一个与发送消息类似的二进制接口<ul>
<li><code>Production</code>环境通过<code>feedback.push.apple.com:2196</code>来建立连接</li>
<li><code>Development</code>环境通过<code>feedback.sandbox.push.apple.com:2196</code>来建立连接</li>
</ul>
</li>
<li><p><code>feedback service</code>和发送消息是不同的服务接口(但都属于<code>APNs</code>)，他的连接方式和发送消息是一样的。也要通过证书建立<code>SSL</code>连接，连接后不需要发送任何命令，直接开始读取流一直读完为止，然后<code>provider</code>要解析读到的数据</p>
<ul>
<li><p>数据是由多个如下格式数据项组成的</p>
<ul>
<li>|四字节时间|<code>2</code>字节的<code>token</code>长度|<code>32</code>字节的设备<code>token</code>|</li>
<li>四字节时间：<code>Provider</code>需要判断对应设备的这个<code>iOS</code>应用程序有没有在该时间之后重新向<code>provider</code>发送注册推送消息所获得的设备<code>token</code>。如果没有，就认为该设备失效了，需停止向该设备发送消息。如果有，那就是这个设备失效过，但是现在又有效了，只是<code>feedback service</code>还没来得及刷新列表<ul>
<li>从<code>Feedback service</code>读取的数据结构如下</li>
</ul>
</li>
</ul>
<p><img src="/2019/07/30/消息推送/从FeedbackService读取的数据结构.jpg" alt="从FeedbackService读取的数据结构"></p>
<p>结构中包含三个部分：</p>
<ol>
<li>第一部分是一个时间戳，记录的是设备失效后的时间信息</li>
<li>第二个部分是<code>device_token</code>的长度</li>
<li>第三部分就是失效的<code>device_token</code></li>
</ol>
<p>我们所要获取的就是第三部分，跟我们的数据库进行对比后，删除对应的<code>device_token</code>，下次不再向这些设备发送推送消息</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>APNs</code>的安全架构</p>
</li>
</ul>
<p><code>provider</code>需要一个有效证书才能和<code>APNs</code>连接(这个证书有目标程序的<code>Bundle identifier</code>信息)。与<code>APNs</code>连接后，<code>provider</code>向<code>APNs</code>发送的消息带有设备<code>token</code>(由目标程序连接<code>provider</code>然后发来<code>token</code>)，<code>APNs</code>以此找到目标设备，然后看目标设备里的目标程序是否有接受推送的证书，<code>APNs</code>以此验证给目标设备的目标程序发送的消息是合法的。</p>
<p><strong>注意：远程消息是不可靠的</strong></p>
<h5 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a><code>Provider</code></h5><ul>
<li><p><code>Payload</code>：最多<code>256bytes</code></p>
</li>
<li><p>本地化<code>alert</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg：&quot;alert&quot; : &#123;&quot;loc-key&quot;:&quot;GAME_PLAY_REQUEST_FORMAT&quot;,&quot;loc-args&quot;:[&quot;Jenna&quot;,&quot;Frank&quot;]&#125;,</span><br><span class="line">程序包里面的本地化字符串如下：</span><br><span class="line">&quot;GAME_PLAY_REQUEST_FORMAT&quot; = &quot;%@ and %@ have invited you to play Monopoly&quot;;</span><br><span class="line">这样，最后显示alert的字符串就是:</span><br><span class="line">&quot;Jenna and Frank have invited you to play Monopoly&quot;</span><br></pre></td></tr></table></figure>
<p>详情可见<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html#//apple_ref/doc/uid/TP40008194-CH10-SW1" target="_blank" rel="noopener">Creating the Remote Notification Payload</a></p>
<ul>
<li><code>provider</code>端部署<ul>
<li>需要来自苹果的SSL证书。服务器端，如果是<code>php</code>的，需要使用<code>.pem</code>的证书；如果是<code>java</code>的，需要使用<code>.p12</code>的证书</li>
<li>部署在<code>provider</code>端的证书，对应于特定的<code>iOS Application</code>(<code>Bundle identifier</code>)</li>
<li><code>provider</code>端证书分为<strong>开发测试</strong>和<strong>上线发布</strong>两种版本,对应于两种<code>APNs</code>环境：<ul>
<li><code>Sandbox</code>(<code>Development</code>)：可用模拟器测试。地址是<code>gateway.sandbox.push.apple.com: TCP 2195</code></li>
<li><code>Production</code>(<code>Distribution</code>)：<code>gateway.push.apple.com: TCP 2195</code></li>
</ul>
</li>
<li><code>provision profile</code>也对应了两个版本：<ul>
<li><code>Development</code></li>
<li><code>Distribution</code>.(<code>The Distribution provision profile is a requirement for submitting your application to the App Store.</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：尽管<code>SSL</code>证书(即<code>provider</code>端证书)没有放到<code>iOS application</code>的<code>provision profile</code>里，但是<code>iOS application</code>是否支持远程消息推送依然取决于<code>profile</code>，因为<code>profile</code>内含开发者证书、设备<code>ID</code>、<code>application ID</code>(<code>Bundle identifier</code>)、”是否支持推送”(在苹果开发者网站上配置证书的时候配置的)等信息。</p>
<p>以文本方式打开<code>*.mobileprovision</code>，会看到里面类似<code>xml</code>格式，其中<code>&lt;key&gt;Entitlements&lt;/key&gt;</code>里包含了<code>&lt;key&gt;aps-environment&lt;/key&gt;</code>，说明支持远程消息推送。<code>&lt;key&gt;aps- environment&lt;/key&gt;</code>下面的<code>&lt;string&gt;</code>说明是调试版本还是发布版本(对应于<code>Sandbox</code>环境和<code>Production</code>环境)</p>
<ul>
<li>安装证书到服务端(<code>provider</code>程序运行的服务器)，步骤如下：<ol>
<li>安装<code>.cer</code>证书到钥匙串(双击<code>.cer</code>即可)</li>
<li>导出证书为<code>.p12</code>文件(选中证书，右键)</li>
<li><code>provider</code>服务器程序最好用<code>Ruby</code>和<code>Perl</code>这类语言，以方便处理<code>.p12</code>的证书文件。打开终端输入以下命令以把证书转换为这类语言乐于交流的格式：<br><code>openssl pkcs12 -in CertificateName.p12 -out CertificateName.pem -nodes</code></li>
<li>把<code>.pem</code>文件安装到服务器上适当的位置(把<code>.pem</code>文件放到对应目录下即可)</li>
</ol>
</li>
</ul>
<h5 id="Provider与APNs连接"><a href="#Provider与APNs连接" class="headerlink" title="Provider与APNs连接"></a><code>Provider</code>与<code>APNs</code>连接</h5><p><code>Provider</code>可以建立多个与<code>APNs</code>的连接。每个都得用<code>TLS</code>(<code>or SSL</code>)来建立安全通道，需要用到<code>SSL</code>证书(即<code>provider</code>连接<code>APNs</code>用到的<code>.p12</code>(<code>SSL</code>)证书）。</p>
<p><code>Provider</code>到<code>APNs</code>的请求，可看<a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns" target="_blank" rel="noopener">Sending Notification Requests to APNs</a></p>
<p>Tips：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要建立与APNs的TLS会话，需要在provider服务器上安装Entrust </span><br><span class="line">Secure CA根证书。如服务器上未安装CA根证书，可以从Entrust SSL</span><br><span class="line"> Certificates的网站http://www.entrust.net/下载安装根证书。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>发送消息的二进制接口和消息的数据包格式</p>
<ul>
<li>消息须是网络字节顺序(即大尾顺序)，消息里面的<code>payload</code>部分不可以超过<code>256</code>字节，且不得以<code>\0</code>结尾，即服务器端发出的<code>json</code>包是有大小限制的，最大<code>256</code>字节，包括自定义字典集</li>
<li>消息的数据包格式</li>
</ul>
<p><img src="/2019/07/30/消息推送/消息的数据包格式.jpg" alt="消息的数据包格式"></p>
<p>这个结构体包括五个部分：</p>
<ol>
<li>命令标示符</li>
<li><code>device_token</code>的长度</li>
<li><code>device_token</code>字符串</li>
<li>推送消息体(<code>Payload</code>)的长度</li>
<li>真正的消息内容，里面包含了推送消息的基本信息，比如消息内容，应用<code>Icon</code>右上角显示多少数字以及推送消息到达时所播放的声音等</li>
</ol>
<p><code>APNs</code>验证这个结构正确并提取其中的信息后，再将消息推送到指定的设备</p>
</li>
</ul>
<h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><ul>
<li>测试证书是否有效</li>
</ul>
<p>终端输入：<br>//开发证书验证<br><code>openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert 下载证书生成的.pem -key p12生成的.pem</code></p>
<p>//发布证书验证<br><code>openssl s_client -connect gateway.push.apple.com:2195 -cert 下载证书生成的.pem -key p12生成的.pem</code></p>
<p>终端输出正常<code>Log</code>，并且当在终端任意输入几个字符时，服务器会提示断开，则说明所验证证书没问题</p>
<ul>
<li>收到推送通知调用的函数</li>
</ul>
<p>如果是程序正在运行或者说程序正在后台，那么这个时候处理推送消息的工作都是在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo</span><br><span class="line">或者：</span><br><span class="line"></span><br><span class="line">//推荐使用这个函数</span><br><span class="line">-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br></pre></td></tr></table></figure>
<p> 中完成。但是如果用户点击推送通知的时候程序还没有被启动，这个时候以上两个函数都是接收不到用户的推送通知的，这个时候需要在<code>application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>函数里面进行处理。而推送消息的相关信息就存储在<code>launchOptions</code>这个字典里。</p>
<ul>
<li>客户端需要注意的<ul>
<li><code>bundle ID</code>与<code>App Id</code>一致</li>
<li>设备Token能正常获取</li>
</ul>
</li>
</ul>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><ul>
<li>通配符<code>ID</code>不能用于推送通知服务</li>
<li>在发送各<code>payload</code>时频繁连接和断开，<code>APNs</code>有可能会封锁你的<code>IP</code></li>
</ul>
<h3 id="总结整理"><a href="#总结整理" class="headerlink" title="总结整理"></a>总结整理</h3><ul>
<li><code>APNs</code></li>
</ul>
<p>无论是<code>iPhone</code>客户端跟<code>APNs</code>，还是<code>Provider</code>和<code>APNs</code>都需要通过证书进行连接的。</p>
<ul>
<li>四个文件：<ol>
<li><code>certSigningRequest</code>(<code>CSR</code>文件)</li>
<li><code>cer</code>(<code>SSL certificate</code>文件)</li>
<li><code>mobileprovision</code>(<code>profile</code>证书)(因为推送消息只能在真机上测试)</li>
<li><code>p12</code>(<code>p12</code>证书)(<code>Provider</code>(<code>JAVA</code>)后台用于连接<code>APNs</code>的证书)</li>
</ol>
</li>
</ul>
<p><code>Provider</code>与<code>APNs</code>连接：(<code>TCP</code>连接)<br><code>APNs</code>提供的连接接口是二进制的、<code>streaming TCP socket</code>、异步的。<br><code>Provider</code>可以建立多个与<code>APNs</code>的连接。每个都得用<code>TSL</code>(<code>or SSL</code>)来建立安全通道，需要用到<code>SSL</code>证书。</p>
<p><code>iOS</code>与<code>APNs</code>连接：<br>我们的应用和<code>APNs</code>维持一个基于<code>TCP</code>的长连接，<code>APNs</code>将新消息推送到我们设备上，然后在屏幕上显示出新消息来。<br>我们的设备和<code>APNs</code>服务器之间的通讯是基于<code>SSL</code>协议的<code>TCP</code>流通讯，二者之间维持一个长连接。<br>我们的设备在有网络的情况下会连接苹果推送服务器，连接过程中，<code>APNs</code>会验证<code>device_token</code>，连接成功后维持一个长连接。</p>
<p>服务器端所需要的证书格式：<br>服务器端，如果是<code>php</code>的，需要使用<code>.pem</code>的证书；如果是<code>java</code>的，需要使用<code>.p12</code>的证书。</p>
<p>服务器端发出的<code>json</code>包是有大小限制的，最大<code>256</code>字节，包括自定义字典集。</p>
<hr>
<ul>
<li>本地通知</li>
</ul>
<p>对本地通知的数量限制，<code>iOS</code>最多允许最近本地通知数量是<code>64</code>个，超过限制的本地通知将被<code>iOS</code>忽略。</p>
<p>应用程序的本地通知是由用户的<code>iOS</code>设备生成并发布的，无论这个应用程序是否运行在前台。就像一个日历应用、闹钟应用，或<code>to-do list</code>应用，可以发出一条本地通知提醒用户计划的日常事项要开始了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/26/RunLoop/" class="post-title-link" itemprop="url">RunLoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-26 12:59:14" itemprop="dateCreated datePublished" datetime="2019-07-26T12:59:14+08:00">2019-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="RunLoop的概念"><a href="#RunLoop的概念" class="headerlink" title="RunLoop的概念"></a><code>RunLoop</code>的概念</h3><ul>
<li>背景：一般情况下，<strong>一个线程一次只能执行一个任务</strong>，执行完任务后线程就会退出。</li>
<li>目的：需要一个机制，让线程能随时处理事件但并不退出。</li>
</ul>
<p>为了实现上述目的，引入<code>Event Loop</code>模型(事件循环模型)。<code>Event Loop</code>在<code>OSX/iOS</code>里的实现是<code>RunLoop</code>。实现<strong><code>Event Loop</code>模型的关键点是：</strong>如何管理<strong>事件/消息</strong>，如何让<strong>线程</strong>在没有消息处理时休眠以避免资源占用，在有消息到来时立刻被唤醒(<code>Event Loop</code>的核心思想)。</p>
<p><code>Event Loop</code>模型的代码逻辑，通常是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模型思想的具体实现通过对象来体现。所以，<code>RunLoop</code>实际上就是一个对象，<code>RunLoop</code>对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行<strong><code>Event Loop</code>模型关键点</strong>的逻辑。线程执行了这个入口函数后，就会一直处于这个<strong>函数内部“接受消息 -&gt; 等待 -&gt; 处理”的循环</strong>中，直到这个循环结束(如传入<code>quit</code>消息)，函数返回，此时执行这个函数的线程就会退出。</p>
<p><code>OSX/iOS</code>系统中，提供了<code>NSRunLoop</code>和<code>CFRunLoopRef</code>两个实现了<code>Event Loop</code>模型思想的对象。</p>
<ul>
<li><code>CFRunLoopRef</code>是在<code>CoreFoundation</code>框架内的，它提供了纯<code>C</code>函数的<code>API</code>，所有这些<code>API</code>都是<strong>线程安全</strong>的。</li>
<li><code>NSRunLoop</code>是基于<code>CFRunLoopRef</code>的封装，提供了<strong>面向对象</strong>的<code>API</code>，但是这些<code>API</code>不是线程安全的。</li>
</ul>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a><code>RunLoop</code>与线程的关系</h3><p><code>iOS</code>开发中会遇到的两个线程对象：<code>pthread_t</code>和<code>NSThread</code>。<code>pthread_t</code>和<code>NSThread</code>是一一对应的，即<code>pthread_t</code>中有的方法，在<code>NSThread</code>中会有与之功能相同的对应方法。</p>
<p><code>CFRunLoop</code>是基于<code>pthread</code>来管理的。</p>
<p>苹果不允许直接创建<code>RunLoop</code>，只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code>和<code>CFRunLoopGetCurrent()</code>。两个函数内部的逻辑代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">/// 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">/// 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        /// 取不到时，创建一个</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析代码可知，线程和<code>RunLoop</code>之间是一一对应的，其关系是保存在一个全局的<code>Dictionary</code>里。线程刚创建时并没有<code>RunLoop</code>，如果不主动获取，那<code>RunLoop</code>一直都不会有。<code>RunLoop</code>的创建是发生在第一次获取时，<code>RunLoop</code>的销毁是发生在线程结束时。只能在一个线程的内部获取其<code>RunLoop</code>(主线程除外？)。</p>
<h3 id="RunLoop对外的接口"><a href="#RunLoop对外的接口" class="headerlink" title="RunLoop对外的接口"></a><code>RunLoop</code>对外的接口</h3><p>在<code>CoreFoundation</code>里面关于<code>RunLoop</code>有<code>5</code>个类：</p>
<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
<p>其中<code>CFRunLoopModeRef</code>类并没有对外暴露，只是通过<code>CFRunLoopRef</code>的接口进行了封装。</p>
<p>与<code>RunLoop</code>有关的<code>5</code>个类的关系如下：</p>
<p><img src="/2019/07/26/RunLoop/与RunLoop相关的类关系.png" alt="与RunLoop相关的类关系"></p>
<p>一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source/Timer/Observer</code>。每次调用<code>RunLoop</code>的主函数时，只能指定其中一个<code>Mode</code>，这个<code>Mode</code>被称作<code>CurrentMode</code>。<strong>如果需要切换<code>Mode</code>，只能退出<code>Loop</code>，再重新指定一个<code>Mode</code>进入。</strong>这样做主要是为了分隔开不同组的<code>Source/Timer/Observer</code>，让不同组的<code>Source/Timer/Observer</code>互不影响。</p>
<ul>
<li><p><code>CFRunLoopSourceRef</code>是事件产生的地方。<code>Source</code>有两个版本：<code>Source0</code>和<code>Source1</code></p>
<ul>
<li><code>Source0</code>只包含了一个回调(函数指针)，它并不能主动触发事件</li>
<li><code>Source1</code>包含了一个<code>mach_port</code>和一个回调(函数指针)，被用于<strong>通过内核</strong>和其他线程相互发送消息</li>
</ul>
</li>
<li><p><code>CFRunLoopTimerRef</code>是基于时间的触发器，它和<code>NSTimer</code>是<code>toll-free bridge</code>的，可以混用。<code>CFRunLoopTimerRef</code>包含一个时间长度和一个回调(函数指针)。当其加入到<code>RunLoop</code>时，<code>RunLoop</code>会注册对应的时间点，当时间点到时，<code>RunLoop</code>会被唤醒以执行那个回调</p>
</li>
<li><p><code>CFRunLoopObserverRef</code>是观察者，每个<code>Observer</code>都包含了一个回调(函数指针)，当<code>RunLoop</code>的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有以下几个：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠(RunLoop将从用户态切到内核态)</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Source/Timer/Observer</code>被统称为<code>mode item</code>，一个<code>item</code>可以被同时加入多个<code>mode</code>。但一个<code>item</code>被重复加入同一个<code>mode</code>时是不会有效果的。如果一个<code>mode</code>中一个<code>item</code>都没有，则<code>RunLoop</code>(里面的主函数)会直接退出，不进入循环</p>
<h3 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a><code>RunLoop</code>的<code>Mode</code></h3><p>从<code>CFRunLoopMode</code>和<code>CFRunLoop</code>的结构去分析理解</p>
<p><code>CFRunLoopMode</code>和<code>CFRunLoop</code>的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个<code>Mode</code>可以将自己标记为<code>Common</code>属性(通过将其<code>ModeName</code>添加到<code>RunLoop</code>的<code>commonModes</code>中）。每当<code>RunLoop</code>的内容发生变化时(即<code>RunLoop</code>的成员变量发生了变化)，<code>RunLoop</code>都会自动将<code>_commonModeItems</code>里的<code>Source/Observer/Timer</code>同步到具有<code>Common</code>标记的所有<code>Mode</code>里。<code>commonModes</code>的特殊性，是同步<code>Source/Timer/Observer</code>到多个<code>Mode</code>中的一种技术方案。</p>
<p>有时需要一个<code>Timer</code>，在两个<code>Mode</code>中都能得到回调，解决方法有两种：</p>
<ul>
<li>一种办法就是将这个<code>Timer</code>分别加入这两个<code>Mode</code></li>
<li>还有一种方式，就是将<code>Timer</code>加入到顶层的<code>RunLoop</code>的<code>commonModeItems</code>中，<code>commonModeItems</code>被<code>RunLoop</code>自动更新到所有具有<code>Common</code>属性的<code>Mode</code>里去</li>
</ul>
<h5 id="操作相关的API"><a href="#操作相关的API" class="headerlink" title="操作相关的API"></a>操作相关的<code>API</code></h5><ul>
<li><code>CFRunLoop</code>对外暴露的管理<code>Mode</code>的接口只有<code>2</code>个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Mode</code>暴露的管理<code>mode item</code>的接口有下面几个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>
<p>只能通过<code>mode name</code>来操作内部的<code>mode</code>，当你传入一个新的<code>mode name</code>但<code>RunLoop</code>内部没有对应<code>mode</code>时，<code>RunLoop</code>会自动帮你创建对应的<code>CFRunLoopModeRef</code>。对于一个<code>RunLoop</code>来说，其内部的<code>mode</code>只能增加不能删除</p>
<h3 id="RunLoop的内部逻辑"><a href="#RunLoop的内部逻辑" class="headerlink" title="RunLoop的内部逻辑"></a><code>RunLoop</code>的内部逻辑</h3><p><code>RunLoop</code>内部的逻辑大致如下</p>
<p><img src="/2019/07/26/RunLoop/RunLoop内部逻辑.png" alt="RunLoop内部逻辑"></p>
<p><code>RunLoop</code>内部主要函数(<code>CFRunLoopRunSpecific</code>)的内部是一个<code>do-while</code>循环。当调用<code>CFRunLoopRun()</code>时，线程就会一直停留在这个循环里，直到超时或被手动停止，该函数才会返回。</p>
<h3 id="RunLoop的底层实现"><a href="#RunLoop的底层实现" class="headerlink" title="RunLoop的底层实现"></a><code>RunLoop</code>的底层实现</h3><p><code>RunLoop</code>的核心是基于<code>mach port</code>的，其进入休眠时调用的函数是<code>mach_msg()</code>。要理解<code>RunLoop</code>底层实现的逻辑，从<code>OSX/iOS</code>系统架构和<code>Darwin</code>核心架构进行分析。</p>
<h6 id="OSX-iOS系统架构"><a href="#OSX-iOS系统架构" class="headerlink" title="OSX/iOS系统架构"></a><code>OSX/iOS</code>系统架构</h6><p><img src="/2019/07/26/RunLoop/OSX_iOS系统架构.png" alt="OSX_iOS系统架构"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">苹果官方将整个系统大致划分为上述4个层次：</span><br><span class="line">应用层包括用户能接触到的图形应用；</span><br><span class="line">应用框架层即开发人员接触到的Cocoa等框架；</span><br><span class="line">核心框架层包括各种核心框架、OpenGL等内容；</span><br><span class="line">Darwin即操作系统的核心，包括系统内核、驱动、Shell等内容。</span><br></pre></td></tr></table></figure>
<h6 id="Darwin核心架构"><a href="#Darwin核心架构" class="headerlink" title="Darwin核心架构"></a><code>Darwin</code>核心架构</h6><p><img src="/2019/07/26/RunLoop/Darwin核心架构.png" alt="Darwin核心架构"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在硬件层上面的三个组成部分：Mach、BSD、IOKit，共同组成了XNU内核</span><br><span class="line"></span><br><span class="line">XNU内核的内环被称作Mach，其作为一个微内核，仅提供了诸如处理器调</span><br><span class="line">度、IPC(进程间通信)等非常少量的基础服务</span><br><span class="line"></span><br><span class="line">BSD层可以看作围绕Mach层的一个外环，其提供了诸如进程管理、文件系统</span><br><span class="line">和网络等功能</span><br><span class="line"></span><br><span class="line">IOKit层是为设备驱动提供了一个面向对象(C++)的一个框架</span><br></pre></td></tr></table></figure>
<p>在<code>Mach</code>中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为“对象”。和其他架构不同，<code>Mach</code>的对象间不能直接调用，只能通过<strong>消息传递</strong>的方式实现<strong>对象间的通信</strong>。“消息”是<code>Mach</code>中最基础的概念，<strong>消息在两个端口(<code>port</code>)之间传递</strong>，这就是<code>Mach</code>的<code>IPC</code>(进程间通信)的核心。</p>
<p>一条<code>Mach</code>消息实际上就是一个二进制数据包(<code>BLOB</code>)，其头部定义了当前端口<code>local_port</code>和目标端口<code>remote_port</code>，发送和接受消息是通过同一个<code>API</code>进行的，其<code>option</code>标记了消息传递的方向。</p>
<p>为了实现消息的发送和接收，<code>mach_msg()</code>函数实际上是调用了一个<code>Mach</code>陷阱(<code>trap</code>)，即函数<code>mach_msg_trap()</code>，陷阱这个概念在<code>Mach</code>中等同于系统调用。当在用户态调用<code>mach_msg_trap()</code>时会触发陷阱机制，切换到内核态。内核态中内核实现的<code>mach_msg()</code>函数会完成实际的工作。状态切换流程图如下：</p>
<p><img src="/2019/07/26/RunLoop/状态切换流程.png" alt="状态切换流程"></p>
<p><code>RunLoop</code>的核心就是一个<code>mach_msg()</code>，<code>RunLoop</code>调用这个函数去接收消息，如果没有发送<code>port</code>消息过来，内核会将线程置于等待状态。</p>
<h3 id="RunLoop的应用"><a href="#RunLoop的应用" class="headerlink" title="RunLoop的应用"></a><code>RunLoop</code>的应用</h3><p>对监听者(<code>observers</code>)而言，线程即将进入<code>RunLoop</code>，此处有<code>Observer</code>会创建<code>AutoreleasePool:_objc_autoreleasePoolPush();</code>，线程即将休眠，会通知<code>Observers</code>，即将进入休眠，此处有<code>Observer</code>释放并新建<code>AutoreleasePool: _objc_autoreleasePoolPop();`</code>_objc_autoreleasePoolPush();<code>，线程即将退出</code>RunLoop<code>，通知</code>Observers<code>，即将退出</code>RunLoop<code>，此处有</code>Observer<code>释放</code>AutoreleasePool: _objc_autoreleasePoolPop();`</p>
<h5 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a><code>AutoreleasePool</code></h5><p>主线程中的自动释放池，首次创建时，优先级最高，保证创建释放池发生在其他所有回调之前；最后释放时，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、<code>Timer</code>回调内的。这些回调会被<code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>Pool</code>了。</p>
<h5 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h5><p>苹果注册了一个<code>Source1</code>(基于<code>mach port</code>的) 用来接收系统事件，其回调函数为<code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>当一个<strong>硬件事件(触摸/锁屏/摇晃等)</strong>发生后，首先由<code>IOKit.framework</code>生成一个<code>IOHIDEvent</code>事件并由<code>SpringBoard</code>接收。<strong><code>SpringBoard</code>只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种<code>Event</code></strong>，随后<strong>用<code>mach port</code>转发给需要的<code>App</code>进程</strong>。随后苹果注册的那个<code>Source1</code>就会触发回调，并调用<code>_UIApplicationHandleEventQueue()</code>进行<strong>应用内部的分发</strong>。</p>
<p><code>_UIApplicationHandleEventQueue()</code>会把<code>IOHIDEvent</code>处理并包装成<code>UIEvent</code>进行处理或分发，其中包括识别<code>UIGesture</code>/处理屏幕旋转/发送给<code>UIWindow</code>等。通常事件比如<code>UIButton</code>点击、<code>touchesBegin/Move/End/Cancel</code>事件都是在这个回调中完成的。</p>
<h5 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h5><p>当事件响应的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用<code>Cancel</code>将当前的<code>touchesBegin/Move/End</code>系列回调打断。随后系统将对应的<code>UIGestureRecognizer</code>标记为待处理。</p>
<p>苹果注册了一个<code>Observer</code>监测<code>BeforeWaiting</code>(<code>Loop</code>即将进入休眠)事件，这个<code>Observer</code>的回调函数是<code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的<code>GestureRecognizer</code>，并执行<code>GestureRecognizer</code>的回调。当有<code>UIGestureRecognizer</code>的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h5 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h5><p>当在操作<code>UI</code>时，比如改变了<code>Frame</code>、更新了<code>UIView/CALayer</code>的层次时，或者手动调用了<code>UIView/CALayer</code>的<code>setNeedsLayout/setNeedsDisplay</code>方法后，这个<code>UIView/CALayer</code>就被标记为待处理，并被提交到一个全局的容器中去。</p>
<p>苹果注册了一个<code>Observer</code>监听<code>BeforeWaiting</code>(即将进入休眠)和<code>Exit</code>(即将退出<code>Loop</code>)事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的<code>UIView/CAlayer</code>以执行实际的绘制和调整，并更新<code>UI</code>界面。</p>
<p><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>函数的内部调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>
<h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p><code>NSTimer</code>其实就是<code>CFRunLoopTimerRef</code>，他们之间是<code>toll-free bridged</code>的。一个<code>NSTimer</code>注册到<code>RunLoop</code>后，<code>RunLoop</code>会为其重复的时间点注册好事件。<code>RunLoop</code>为了节省资源，并不会在非常准确的时间点回调这个<code>Timer</code>。<code>Timer</code>有个属性叫做<code>Tolerance</code>(宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p><code>CADisplayLink</code>是一个和屏幕刷新率一致的定时器(但实际实现原理更复杂，和<code>NSTimer</code>并不一样，其内部实际是操作了一个<code>Sourc</code>)。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去(和<code>NSTimer</code>相似)，造成界面卡顿的感觉。在快速滑动<code>TableView</code>时，即使一帧的卡顿也会让用户有所察觉。</p>
<p><code>Facebook</code>开源的<code>AsyncDisplayLink</code>就是为了解决界面卡顿的问题，其内部也用到了<code>RunLoop</code>。</p>
<h5 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a><code>PerformSelecter</code></h5><p>当调用<code>NSObject</code>的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个<code>Timer</code>并添加到<strong>当前线程的<code>RunLoop</code>中</strong>。所以如果当前线程没有<code>RunLoop</code>，则这个方法会失效。</p>
<p>当调用<code>performSelector:onThread:</code>时，实际上其会创建一个<code>Timer</code>加到对应的线程去，同样的，如果对应线程没有<code>RunLoop</code>该方法也会失效。</p>
<h5 id="GCD和RunLoop的关系"><a href="#GCD和RunLoop的关系" class="headerlink" title="GCD和RunLoop的关系"></a><code>GCD</code>和<code>RunLoop</code>的关系</h5><p><code>GCD</code>提供的某些接口也用到了<code>RunLoop</code>， 例如<code>dispatch_async()</code>。</p>
<p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，<code>libDispatch</code>会向主线程的<code>RunLoop</code>发送消息，<code>RunLoop</code>会被唤醒，并从消息中取得这个<code>block</code>，并在回调<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code>里执行这个<code>block</code>。这个逻辑仅限于<code>dispatch</code>到主线程，<code>dispatch</code>到其他线程仍然是由<code>libDispatch</code>处理的。</p>
<h5 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h5><p><code>iOS</code>中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CFSocket</code>是最底层的接口，只负责<code>socket</code>通信</li>
<li><code>CFNetwork</code>是基于<code>CFSocket</code>等接口的上层封装<code>ASIHttpRequest</code>工作于这一层</li>
<li><code>NSURLConnection</code>是基于<code>CFNetwork</code>的更高层的封装，提供面向对象的接口，<code>AFNetworking</code>工作于这一层</li>
<li><code>NSURLSession</code>是<code>iOS7</code>中新增的接口，表面上是和<code>NSURLConnection</code>并列的，但底层仍然用到了<code>NSURLConnection</code>的部分功能(比如<code>com.apple.NSURLConnectionLoader</code>线程)，<code>AFNetworking2</code>和<code>Alamofire</code>工作于这一层</li>
</ul>
<p><code>NSURLConnection</code>的工作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通常使用NSURLConnection时，你会传入一个Delegate，当调用了</span><br><span class="line">[connection start]后，这个Delegate就会不停收到事件回调。实际</span><br><span class="line">上，start这个函数的内部会获取CurrentRunLoop，然后在其中的</span><br><span class="line">DefaultMode添加了4个Source0(即需要手动触发的Source)。</span><br><span class="line">CFMultiplexerSource是负责各种Delegate回调的，</span><br><span class="line">CFHTTPCookieStorage是处理各种Cookie的。</span><br><span class="line"></span><br><span class="line">当开始网络传输时，我们可以看到NSURLConnection创建了两个新线程：</span><br><span class="line">com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。</span><br><span class="line">其中CFSocket线程是处理底层socket连接的。</span><br><span class="line">NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层</span><br><span class="line">socket的事件，并通过之前添加的Source0通知到上层的Delegate。</span><br><span class="line"></span><br><span class="line">NSURLConnectionLoader中的RunLoop通过一些基于mach port的Source接收来自底层CFSocket的通知。当收到通知后，其会在合适的时机向CFMultiplexerSource等Source0发送通知，同时唤醒Delegate线程的RunLoop来让其处理这些通知。CFMultiplexerSource会在Delegate线程的RunLoop对Delegate执行实际的回调。</span><br></pre></td></tr></table></figure>
<p>上述工作流程图如下：</p>
<p><img src="/2019/07/26/RunLoop/NSURLConnection工作流程图.png" alt="NSURLConnection工作流程图"></p>
<h3 id="RunLoop应用举例"><a href="#RunLoop应用举例" class="headerlink" title="RunLoop应用举例"></a><code>RunLoop</code>应用举例</h3><h5 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a><code>AFNetworking</code></h5><p><code>AFURLConnectionOperation</code>这个类是基于<code>NSURLConnection</code>构建的，其希望能在后台线程接收<code>Delegate</code>回调。为此<code>AFNetworking</code>单独创建了一个线程，并在这个线程中启动了一个<code>RunLoop</code>。<code>RunLoop</code>启动前内部必须要有至少一个<code>Timer/Observer/Source</code>，所以<code>AFNetworking</code>在<code>[runLoop run]</code>之前先创建了一个新的<code>NSMachPort</code>添加进去了。</p>
<p>当需要这个后台线程执行任务时，<code>AFNetworking</code>通过调用<code>[NSObject performSelector:onThread:..]</code>将这个任务扔到了后台线程的<code>RunLoop</code>中。</p>
<h5 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a><code>AsyncDisplayKit</code></h5><p><code>UI</code>线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为<code>3</code>类：<strong>排版，绘制，<code>UI</code>对象操作。</strong></p>
<ul>
<li><strong>排版</strong>：通常包括计算视图大小、计算文本高度、重新计算子视图的排版等操作</li>
<li><strong>绘制</strong>：一般有<strong>文本绘制</strong>(例如<code>CoreText</code>)、<strong>图片绘制</strong>(例如预先解压)、<strong>元素绘制</strong>(<code>Quartz</code>)等操作</li>
<li><strong><code>UI</code>对象操作</strong>：通常包括<code>UIView/CALayer</code>等<code>UI</code>对象的创建、设置属性和销毁</li>
</ul>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果(例如<code>TextView</code>创建时可能需要提前计算出文本的大小)。</p>
<p><code>AsyncDisplayKit</code>是<code>Facebook</code>推出的用于保持界面流畅性的框架，<code>ASDK</code>所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟(例如视图的创建、属性的调整)，是针对上述情况的第三类进行处理，其原理大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ASDK创建了一个名为ASDisplayNode的对象，并在内部封装了UIView/CALayer，</span><br><span class="line">它具有和UIView/CALayer相似的属性，例如frame、backgroundColor等。</span><br><span class="line">所有这些属性都可以在后台线程更改，开发者可以只通过Node来操作其内部</span><br><span class="line">的UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论</span><br><span class="line">怎么操作，这些属性总需要在某个时刻同步到主线程的UIView/CALayer去。</span><br><span class="line"></span><br><span class="line">ASDK仿照QuartzCore/UIKit框架的模式，实现了一套类似的界面更新的</span><br><span class="line">机制：即在主线程的RunLoop中添加一个Observer，监听了</span><br><span class="line">kCFRunLoopBeforeWaiting和kCFRunLoopExit事件，在收到回调时，</span><br><span class="line">遍历所有之前放入队列的待处理的任务，然后一一执行。</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/技术文章-iOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/25/技术文章-iOS/" class="post-title-link" itemprop="url">技术文章-iOS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-25 09:56:20" itemprop="dateCreated datePublished" datetime="2019-07-25T09:56:20+08:00">2019-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><code>AppStore</code>审核指南，<a href="http://www.cocoachina.com/appstore/20140910/9574.html" target="_blank" rel="noopener">中文版</a>，<a href="https://developer.apple.com/app-store/review/guidelines/" target="_blank" rel="noopener">英文版</a></li>
</ul>
<h3 id="技术方向"><a href="#技术方向" class="headerlink" title="技术方向"></a>技术方向</h3><ul>
<li><p><a href="https://kevinhm.gitbooks.io/functionalreactiveprogrammingonios/content/index.html" target="_blank" rel="noopener">函数式响应编程</a></p>
</li>
<li><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="noopener">iOS应用架构谈</a></p>
</li>
</ul>
<h3 id="技术详解"><a href="#技术详解" class="headerlink" title="技术详解"></a>技术详解</h3><ul>
<li><p><code>emoji</code>表情符号兼容<a href="http://blog.csdn.net/qdkfriend/article/details/7576524" target="_blank" rel="noopener">方案</a></p>
</li>
<li><p><a href="http://blog.csdn.net/totogo2010/article/details/8233565" target="_blank" rel="noopener">内存检测</a></p>
</li>
<li><p>方法混合-<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">Method Swizzling</a></p>
</li>
<li><p><a href="http://blog.csdn.net/onlyou930/article/details/9299169" target="_blank" rel="noopener">关联</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/0cb81bf23d7a" target="_blank" rel="noopener">应用热修复(hot-fix)JSPatch</a></p>
</li>
<li><p><code>OC</code>与<code>JS</code>交互</p>
<ul>
<li><a href="https://www.jianshu.com/p/cdaf9bc3d65d" target="_blank" rel="noopener">使用JavaScriptCore实现OC与JS的交互</a></li>
<li><a href="https://www.cnblogs.com/oc-bowen/p/5547812.html" target="_blank" rel="noopener">OC与JS的交互详解</a></li>
</ul>
</li>
<li><p>核心动画</p>
<ul>
<li><a href="https://www.jianshu.com/p/8c1c1697c0ce" target="_blank" rel="noopener">Core Animation</a></li>
<li><a href="https://www.jianshu.com/p/85a568456b1f" target="_blank" rel="noopener">核心动画编程指南</a></li>
</ul>
</li>
<li><p><a href="http://www.jianshu.com/p/0bece5f27650" target="_blank" rel="noopener">事件穿透</a></p>
</li>
<li><p>SDWebImage解读</p>
<ul>
<li><a href="https://www.jianshu.com/p/be9a0a088feb" target="_blank" rel="noopener">SDWebImage解读</a></li>
<li><a href="http://www.2cto.com/kf/201604/500830.html" target="_blank" rel="noopener">你真的会用SDWebImage</a></li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/jiang314/article/details/51878797" target="_blank" rel="noopener">AFN解析</a></p>
</li>
<li><p><a href="http://www.mamicode.com/info-detail-877996.html" target="_blank" rel="noopener">Socket编程</a></p>
</li>
<li><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>
</li>
<li><p><a href="https://blog.csdn.net/cocoarannie/article/details/11857141" target="_blank" rel="noopener">回调机制-代理,通知中心以及Block</a></p>
</li>
<li><p><a href="https://blog.csdn.net/margin_zh/article/details/6062676" target="_blank" rel="noopener">MVC模式</a></p>
</li>
<li><p><a href="http://blog.sina.com.cn/s/blog_6d61743b01018v0u.html" target="_blank" rel="noopener">UIApplication代理方法的作用</a></p>
</li>
<li><p><a href="http://www.cocoachina.com/articles/11270" target="_blank" rel="noopener">保存app内容到手机桌面</a></p>
</li>
<li><p><a href="https://my.oschina.net/u/2340880/blog/405847" target="_blank" rel="noopener">使用原生API进行二维码和条形码的扫描</a></p>
</li>
<li><p><a href="http://blog.sina.com.cn/s/blog_8ded6a080102v4ux.html" target="_blank" rel="noopener">使用UIImageView实现加载GIF图片</a></p>
</li>
<li><p>线程</p>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_5f1a6dd401010st4.html" target="_blank" rel="noopener">线程 NSCondition NSThread</a></li>
</ul>
</li>
<li><p>设计模式</p>
<ul>
<li><a href="https://blog.csdn.net/hguisu/article/details/7558249" target="_blank" rel="noopener">策略模式</a></li>
</ul>
</li>
<li><p>网络相关</p>
<ul>
<li><a href="https://www.cnblogs.com/bizhu/archive/2012/05/12/2497493.html" target="_blank" rel="noopener">TCP与UDP的区别</a></li>
<li><a href="https://blog.csdn.net/dlutbrucezhang/article/details/8577810" target="_blank" rel="noopener">Socket通信原理和实践</a></li>
</ul>
</li>
<li><p>正则表达式</p>
<ul>
<li><a href="https://www.cnblogs.com/heyonggang/archive/2013/12/16/3476885.html" target="_blank" rel="noopener">正则表达式</a></li>
<li><a href="https://www.tuicool.com/articles/aAJRju" target="_blank" rel="noopener">正则表达式测试</a></li>
</ul>
</li>
<li><p>自定义键盘</p>
<ul>
<li><a href="http://www.cocoachina.com/articles/9661" target="_blank" rel="noopener">自定义表情键盘</a><ul>
<li><a href="http://blog.sina.com.cn/s/blog_6317728d0102vwjv.html" target="_blank" rel="noopener">自定义emoji表情键盘总结</a></li>
<li><a href="https://www.2cto.com/kf/201503/380192.html" target="_blank" rel="noopener">系统自带表情的获取</a></li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://www.jianshu.com/p/2ace1d3030a1?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq" target="_blank" rel="noopener">iOS多环境配置</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/LifeTechnologySupporter/p/5033852.html" target="_blank" rel="noopener">开发者相关的几种证书</a></p>
</li>
</ul>
<h4 id="UI处理"><a href="#UI处理" class="headerlink" title="UI处理"></a>UI处理</h4><ul>
<li><a href="http://www.cocoachina.com/articles/7401" target="_blank" rel="noopener">自定义Collection View布局</a></li>
</ul>
<h4 id="问题参考解决方案"><a href="#问题参考解决方案" class="headerlink" title="问题参考解决方案"></a>问题参考解决方案</h4><ul>
<li><a href="https://www.jianshu.com/p/bfb237f5c20c" target="_blank" rel="noopener">改变UITableView的headerView、footerView背景颜色</a></li>
</ul>
<h3 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h3><ul>
<li><a href="http://bbs.iosre.com" target="_blank" rel="noopener">iosre</a></li>
</ul>
<h3 id="源码推荐"><a href="#源码推荐" class="headerlink" title="源码推荐"></a>源码推荐</h3><ul>
<li><p><a href="http://www.cocoachina.com/articles/11223" target="_blank" rel="noopener">iOS录音和播放功能demo,多样式进度指示器</a></p>
</li>
<li><p><a href="http://www.code4app.com/forum.php?mod=viewthread&amp;tid=10405&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D1" target="_blank" rel="noopener">精巧顺滑的下载动画</a></p>
</li>
</ul>
<h3 id="工具-应用"><a href="#工具-应用" class="headerlink" title="工具/应用"></a>工具/应用</h3><ul>
<li><p>图片压缩</p>
<ul>
<li><a href="https://tinypng.com" target="_blank" rel="noopener">图片压缩tinypng</a></li>
<li><a href="https://www.macupdate.com/app/mac/28766/imageoptim/" target="_blank" rel="noopener">ImageOptim</a><ul>
<li>压图依据：图片文件中往往包含一些注释、颜色profile等多余信息，移除后图片质量不变，体积更小载入更快。<br>imageoptim：支持PNG/JPEG/GIF动画（PNG/JPEG/GIF是各种影像优化工具的图形前缀：AdvPNG、OptiPNG、Pngcrush、JpegOptim、Jpegtran、Gifsicle、PngOut）</li>
<li><a href="https://www.appinn.com/imageoptim/" target="_blank" rel="noopener">相关资料</a></li>
</ul>
</li>
</ul>
</li>
<li><p>XnConvert</p>
<ul>
<li>是一款简单易用的批量图像格式转换软件。你可以轻松的实现图像格式的转换、缩放图像比例、添加滤镜特效、水印等等</li>
<li><a href="https://www.xnview.com/en/xnconvert/" target="_blank" rel="noopener">官网</a></li>
</ul>
</li>
<li><p>bug统计</p>
<ul>
<li><a href="https://www.infoq.cn/article/crashlytics-crash-statistics-tools/" target="_blank" rel="noopener">Crashlytics</a></li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/weiming4219/p/7908668.html" target="_blank" rel="noopener">抓包工具Charles</a></p>
</li>
<li><p><a href="https://xclient.info" target="_blank" rel="noopener">Xclient</a></p>
</li>
<li><p><a href="http://www.sdifen.com" target="_blank" rel="noopener">史蒂芬周的博客</a></p>
</li>
<li><p><a href="https://lanhuapp.com" target="_blank" rel="noopener">蓝湖</a>(相同功能网站：标你妹啊)</p>
</li>
<li><p><a href="https://www.williamlong.info/archives/4319.html" target="_blank" rel="noopener">好用的MarkDown编辑器一览</a></p>
</li>
<li><p><a href="https://www.jb51.net/article/55442.htm" target="_blank" rel="noopener">git命令表</a></p>
</li>
<li><p><a href="https://bbs.feng.com/read-htm-tid-11181844.html" target="_blank" rel="noopener">传输工具-iTransfer</a></p>
</li>
<li><p><a href="https://github.com/sqlitebrowser/sqlitebrowser/releases/tag/v3.10.1" target="_blank" rel="noopener">DB工具</a></p>
</li>
</ul>
<h3 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a><code>GIT</code></h3><ul>
<li><p><a href="https://github.com/ibireme/YYKit" target="_blank" rel="noopener">YYKit</a></p>
</li>
<li><p><a href="https://github.com/Rita5969/afnetwork3.0-for-webservice" target="_blank" rel="noopener">webService相关</a></p>
</li>
<li><p><a href="https://github.com/TeamStuQ/skill-map" target="_blank" rel="noopener">技能图谱</a></p>
</li>
<li><p><a href="https://github.com/Tim9Liu9/TimLiu-iOS?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">iOS、Mac开源项目及库</a></p>
</li>
</ul>
<h3 id="技术大神"><a href="#技术大神" class="headerlink" title="技术大神"></a>技术大神</h3><ul>
<li><p><a href="http://blog.ibireme.com" target="_blank" rel="noopener">YYKit作者博客</a></p>
</li>
<li><p><a href="http://www.liaoxuefeng.com" target="_blank" rel="noopener">廖雪峰</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com" target="_blank" rel="noopener">阮一峰</a></p>
</li>
<li><p><a href="https://casatwy.com" target="_blank" rel="noopener">casatwy</a></p>
</li>
<li><p><a href="https://github.com/chenliming777/awesome-awesomeness-zh_CN" target="_blank" rel="noopener">陈立明</a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/音视频/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/14/音视频/" class="post-title-link" itemprop="url">音视频</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-14 11:53:19" itemprop="dateCreated datePublished" datetime="2019-07-14T11:53:19+08:00">2019-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
