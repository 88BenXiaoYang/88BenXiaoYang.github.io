<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ben&#39;Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ben&#39;Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ben&#39;Blog">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Ben'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ben'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工欲善其事，必先利其器</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/23/常用正则匹配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/常用正则匹配/" class="post-title-link" itemprop="url">常用正则匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-23 14:27:34 / Modified: 14:29:56" itemprop="dateCreated datePublished" datetime="2020-11-23T14:27:34+08:00">2020-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>匹配网址链接的正则表达式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (NSArray *)regexHttpFromText:(NSString *)text &#123;</span><br><span class="line">  //匹配网址链接</span><br><span class="line">  //    NSString *regex_http = @&quot;http(s)?://([a-zA-Z|\\d]+\\.)+[a-zA-Z|\\d]+(/[a-zA-Z|\\d|\\-|\\+|_./?%&amp;=]*)?&quot;;</span><br><span class="line">NSString *regex_http = @&quot;((http|ftp|https):\\/\\/)?[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;amp;/~\\+#])?&quot;;</span><br><span class="line">return  [text componentsMatchedByRegex:regex_http];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/14/Foundation构架秘籍-函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/14/Foundation构架秘籍-函数/" class="post-title-link" itemprop="url">Foundation构架秘籍-函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-14 19:20:51" itemprop="dateCreated datePublished" datetime="2020-09-14T19:20:51+08:00">2020-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数学运算-math-函数"><a href="#数学运算-math-函数" class="headerlink" title="数学运算(math)函数"></a>数学运算(math)函数</h1><h2 id="算术运算函数"><a href="#算术运算函数" class="headerlink" title="算术运算函数"></a>算术运算函数</h2><ul>
<li>rand()函数：产生随机数</li>
<li>abs()函数/labs()函数：整数的绝对值</li>
<li>fabs()/fabsf()/fabsl()函数：浮点数的绝对值</li>
<li>floor()/floorf()/floorl()函数：向下取整</li>
<li>ceil()/ceilf()/ceill()函数：向上取整</li>
<li>round()/roundf()/roundl()函数：四舍五入</li>
<li>sqrt()/sqrtf()/sqrtl()函数：求平方根</li>
<li>fmax()/fmaxf()/fmaxl()函数：求最大值</li>
<li>fmin()/fminf()/fminl()函数：求最小值</li>
<li>hypot()/hypotf()/hypotl()函数：求直角三角形斜边的长度</li>
<li>fmod()/fmodf()/fmodl()函数：求两数整除后的余数</li>
<li>modf()/modff()/modfl()函数：浮点数分解为整数和小数</li>
<li>frexp()/frexpf()/frexpl()函数：浮点数分解尾数和以二为底的指数</li>
</ul>
<h2 id="三角运算函数"><a href="#三角运算函数" class="headerlink" title="三角运算函数"></a>三角运算函数</h2><ul>
<li>sin()/sinf()/sinl()/函数：求正弦值</li>
<li>sinh()/sinhf()/sinhl()函数：求双曲正弦值</li>
<li>cos()/cosf()/cosl()函数：求余弦值</li>
<li>cosh()/coshf()/coshl()函数：求双曲余弦值</li>
<li>tan()/tanf()/tanl()函数：求正切值</li>
<li>tanh()/tanhf()/tanhl()函数：求双曲正切值</li>
</ul>
<h2 id="反三角运算"><a href="#反三角运算" class="headerlink" title="反三角运算"></a>反三角运算</h2><ul>
<li>asin()/asinf()/asinl()函数：求反正弦值</li>
<li>asinh()/asinhf()/asinhl()函数：求反双曲正弦值</li>
<li>acos()/acosf()/acosl()函数：求反余弦值</li>
<li>acosh()/acoshf()/acoshl()函数：求反双曲余弦值</li>
<li>atan()/atanf()/atanl()函数：求反正切值</li>
<li>atan2()/atan2f()/atanl()函数：求坐标值的反正切值</li>
<li>atanh()/atanhf()/atanhl()函数：求反双曲正切值</li>
</ul>
<h2 id="指数和对数运算"><a href="#指数和对数运算" class="headerlink" title="指数和对数运算"></a>指数和对数运算</h2><ul>
<li>pow()/powf()/powl函数：求n的m次方的值</li>
<li>exp()/expf()/expl()函数：求e的x次方的值</li>
<li>exp2()/exp2f()/exp2l()函数：2的x的次方的值</li>
<li>log()/logf()/logl()函数：求以e为底的对数值</li>
<li>log10()/log10f()/log10l()函数：求以10为底的对数值</li>
</ul>
<h1 id="数字对象-NSNumber"><a href="#数字对象-NSNumber" class="headerlink" title="数字对象(NSNumber)"></a>数字对象(NSNumber)</h1><h2 id="整型对象"><a href="#整型对象" class="headerlink" title="整型对象"></a>整型对象</h2><ul>
<li>numberWithShort:方法：创建短整型数字对象</li>
<li>numberWithUnsignedShort:方法：创建无符号短整型数字对象</li>
<li>numberWithInteger:方法：创建整型数字对象</li>
<li>numberWithUnsignedInteger:方法：创建无符号整型数字对象</li>
<li>numberWithInt:方法：创建整型数字对象</li>
<li>numberWithUnsignedInt:方法：创建无符号整型数字对象</li>
<li>numberWithLong:方法：创建并初始化长整型数字对象</li>
<li>numberWithUnsignedLong:方法：创建并初始化无符号长整型数字对象</li>
<li>numberWithLongLong:方法：创建并初始化长长整型数字对象</li>
<li>numberWithUnsignedLongLong:方法：创建并初始化无符号长长整型对象</li>
<li>initWithShort:方法：初始化短整型数字对象</li>
<li>initWithUnsignedShort:方法：初始化无符号短整型数字对象</li>
<li>initWithInteger:方法：初始化整型数字对象</li>
<li>initWithUnsignedInteger:方法：初始化无符号整型数字对象</li>
<li>initWithInt:方法：初始化整型数字对象</li>
<li>initWithUnsignedInt:方法：初始化无符号整型数字对象</li>
<li>initWithLong:方法：初始化长整型数字对象</li>
<li>initWithUnsignedLong:方法：初始化无符号长整型数字对象</li>
<li>initWithLongLong:方法：初始化长长整型数字对象</li>
<li>initWithUnsignedLongLong:方法：初始化无符号长长整型数字对象</li>
<li>shortValue:方法：取短整型数字对象的值</li>
<li>unsignedShortValue:方法：取无符号短整型数字对象的值</li>
<li>integerValue:方法：取整型数字对象的值</li>
<li>unsignedIntegerValue:方法：取无符号整型数字对象的值</li>
<li>intValue:方法：取整型数字对象的值</li>
<li>unsignedIntValue:方法：取无符号整型数字对象的值</li>
<li>longValue:方法：取长整型数字对象的值</li>
<li>unsignedLongValue:方法：取无符号长整型数字对象的值</li>
<li>longlongValue:方法：取长长整型数字对象的值</li>
<li>unsignedLongLongValue:方法：取无符号长长整型数字对象的值</li>
</ul>
<h2 id="字符型对象"><a href="#字符型对象" class="headerlink" title="字符型对象"></a>字符型对象</h2><ul>
<li>numberWithChar:方法：创建并初始化字符型数字对象</li>
<li>numberWithUnsignedChar:方法：创建并初始化无符号字符型数字对象</li>
<li>initWithChar:方法：初始化字符型对象</li>
<li>initWithUnsignedChar:方法：初始化无符号字符型对象</li>
<li>charValue:方法：取字符型数字对象的值</li>
<li>unsignedCharValue:方法：取无符号字符型数字对象的值</li>
</ul>
<h2 id="单精度型对象"><a href="#单精度型对象" class="headerlink" title="单精度型对象"></a>单精度型对象</h2><ul>
<li>numberWithFloat:方法：创建并初始化单精度型数字对象</li>
<li>initWithFloat:方法：初始化单精度型数字对象</li>
<li>floatValue:方法：取单精度型数字对象的值</li>
</ul>
<h2 id="双精度型对象"><a href="#双精度型对象" class="headerlink" title="双精度型对象"></a>双精度型对象</h2><ul>
<li>numberWithDouble:方法：创建并初始化一个双精度型数字对象</li>
<li>initWithDouble:方法：初始化双精度型数字对象</li>
<li>doubleValue:方法：取双精度型数字对象的值</li>
</ul>
<h2 id="布尔型对象"><a href="#布尔型对象" class="headerlink" title="布尔型对象"></a>布尔型对象</h2><ul>
<li>numberWithBool:方法：创建并初始化布尔型数字对象</li>
<li>initWithBool:方法：初始化布尔类型对象</li>
<li>boolValue:方法：取布尔型数字对象的值</li>
</ul>
<h2 id="数字对象通用方法"><a href="#数字对象通用方法" class="headerlink" title="数字对象通用方法"></a>数字对象通用方法</h2><ul>
<li>isEqualToNumber:方法：比较两对象值是否相等</li>
<li>compare:方法：比较值的大小</li>
</ul>
<h1 id="字符串对象-NSString"><a href="#字符串对象-NSString" class="headerlink" title="字符串对象(NSString)"></a>字符串对象(NSString)</h1><h2 id="创建及初始化"><a href="#创建及初始化" class="headerlink" title="创建及初始化"></a>创建及初始化</h2><ul>
<li>string:方法：创建字符串</li>
<li>stringWithstring:方法：用字符串来创建字符串</li>
<li>stringWithCstring:方法：创建C字符串</li>
<li>stringWithFormat:方法：创建NSLog()格式的字符串</li>
<li>stringWithContentsOfFile:方法：将创建的字符串设置为指定文件的内容</li>
<li>stringWithContentsOfURL:方法：将创建字符串设置为url的内容</li>
<li>stringWithUTF8String:方法：将创建的字符串转换为UTF8字符串</li>
<li>init:方法：初始化字符串</li>
<li>initWithString:方法：用字符串来初始化字符串</li>
<li>initWithCString:方法：初始化字符串</li>
<li>initWithFormat:方法：用NSLog()格式初始化字符串</li>
<li>initWithContentsOfFile:方法：将初始化的字符串设置为指定文件的内容</li>
<li>initWithContentsOfURL:方法：将初始化的字符串设置为url的内容</li>
<li>initWithUTF8String:方法：将初始化的字符串转换为UTF8字符串</li>
</ul>
<h2 id="判断和比较"><a href="#判断和比较" class="headerlink" title="判断和比较"></a>判断和比较</h2><ul>
<li>isEqualTostring:方法：比较字符串是否相等</li>
<li>hasPrefix:方法：判断字符串是否以某个字符开始</li>
<li>hasSuffix:方法：判断字符串是否以某个字符结束</li>
<li>compare:方法：比较字符串的大小</li>
<li>caseInsensitiveCompare:方法：不考虑大小写的比较大小</li>
</ul>
<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><ul>
<li>uppercaseString:方法：小写字母转为大写字母</li>
<li>lowercaseString:方法：大写字母转为小写字母</li>
<li>capitalizedString:方法：将每个单词的首字母大写</li>
</ul>
<h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><ul>
<li>substringToIndex:方法：从字符串的开头一直截取到指定的位置</li>
<li>substringFromIndex:方法：从指定位置开始截取字符串直到结束</li>
<li>substringWithRange:方法：根据指定范围返回子字符串</li>
<li>characterAtIndex:方法：返回索引号所在字符串中的字符</li>
</ul>
<h2 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h2><ul>
<li>doubleValue:/floatValue:方法：返回转换为浮点类型的值</li>
<li>intValue:方法：返回转换为整型的值</li>
<li>boolValue:方法：返回转换为布尔类型的值</li>
</ul>
<h2 id="对文件的处理"><a href="#对文件的处理" class="headerlink" title="对文件的处理"></a>对文件的处理</h2><ul>
<li>stringByAppendingPathExtension:方法：为文件添加扩展名</li>
<li>pathExtension:方法：获取文件扩展名</li>
<li>stringByDeletingPathExtension:方法：删除扩展名</li>
<li>writeToFile:方法：将字符串写入到文件</li>
<li>writeToURL:方法：将字符串写入到url中</li>
<li>stringByExpandingTildeInPath:方法：将“～”替换成系统的主目录</li>
<li>stringByAbbreviatingWithTildeInPath:方法：将系统主目录替换为“～”</li>
<li>lastPathComponent:方法：获取路径中的文件名</li>
<li>stringByDeletingLastPathComponent:方法：获取路径中文件所在的位置</li>
<li>stringByAppendingPathComponent:方法：组合位置和文件名</li>
<li>isAbsolutePath:方法：判断绝对路径</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>length:方法：求字符串的长度</li>
<li>stringByAppendingString:方法：字符串后面增加一个新字符串</li>
<li>rangeOfString:方法：查找字符串中是否包含其他字符串</li>
<li>stringByTrimmingCharactersInSet:方法：去除空格或回车</li>
</ul>
<h2 id="可变字符串-NSMutableString"><a href="#可变字符串-NSMutableString" class="headerlink" title="可变字符串 (NSMutableString)"></a>可变字符串 (NSMutableString)</h2><ul>
<li>stringWithCapacity:方法：按照固定长度生成空字符串</li>
<li>initWithCapacity:方法：初始化一个固定长度的字符串</li>
<li>appendString:方法：在字符串的末尾附加另一个字符串</li>
<li>appendFormat:方法：附加一个格式化字符串</li>
<li>SetString:方法：将字符串设置为规定的内容</li>
<li>insertString:方法：在指定位置插入字符串</li>
<li>deleteCharactersInRange:方法：删除指定范围的字符串</li>
<li>replaceCharactersInRange:方法：使用字符串代替指定范围的字符串</li>
<li>replaceOccurrencesOfString:方法：替换 将字符串中的某个字全部替换成别一个字</li>
<li>stringByReplacingOccurrencesOfString:方法；将字符串中的某个字全部替换成别一个字</li>
</ul>
<h1 id="数组对象-NSArray"><a href="#数组对象-NSArray" class="headerlink" title="数组对象(NSArray)"></a>数组对象(NSArray)</h1><h2 id="创建及初始化-1"><a href="#创建及初始化-1" class="headerlink" title="创建及初始化"></a>创建及初始化</h2><ul>
<li>array:方法：创建数组</li>
<li>arrayWithArray:方法：通过一个数组创建另一个数组</li>
<li>arrayWithContentsOfFile:方法：创建数组将内容设置为指定文件内容</li>
<li>arrayWithContentsOfURL:方法：创建数组将内容设置为url指定内容</li>
<li>arrayWithObject:方法：创建具有一个元素的数组</li>
<li>arrayWithObjects:方法：创建具有多个元素的数组</li>
<li>init:方法：初始化数组</li>
<li>initWithArray:方法：用数组初始化数组</li>
<li>initWithContentsOfFile:方法：初始化数组将内容设置为指定文件内容</li>
<li>initWithContentsOfURL:方法：初始化数组将内容设置为url指定内容</li>
<li>initWithObjects:方法：初始化具有多个元素的数组</li>
</ul>
<h2 id="数组元素的操作"><a href="#数组元素的操作" class="headerlink" title="数组元素的操作"></a>数组元素的操作</h2><ul>
<li>containsObject:方法：判断数组中是否包含某个元素</li>
<li>count:方法：计算元素个数</li>
<li>firstObjectCommonWithArray:方法：获取首元素</li>
<li>lastObject:方法：获取最后一个元素</li>
<li>objectAtIndex:方法：获取在某个位置的数组元素</li>
<li>objectAtIndexs:方法：获取数组元素</li>
<li>arrayByAddingObject:方法：在数组末尾添加元素</li>
<li>arrayByAddingObjectsFromArray:方法：在数组的末尾添加另一个数组</li>
<li>subarrayWithRange:方法：数组的一部分创建数组</li>
<li>isEqualToArray:方法：比较数组是否相等</li>
<li>indexOfObject:方法：返回元素所在的位置</li>
<li>indexOfObjectIdenticalTo:方法：返回元素所在的位置</li>
<li>componentsJoinedByString:方法：数组转换为字符串</li>
<li>componentsSeparatedByString:方法：字符串转换为数组</li>
<li>sortedArrayHint:方法：数组转换为数据对象</li>
<li>writeToFile:方法：将数组中的内容写入到文件</li>
<li>writeToUrl:方法：将数组中的内容写入到url</li>
<li>objectEnumerator:方法：数组元素从前向后访问</li>
<li>reverseObjectEnumerator:方法：数组元素从后向前访问</li>
<li>pathsMatchingExtensions:方法：查看某文件夹下的东西</li>
<li>sortedArrayUsingFunction:方法：实现数组元素的简单排序</li>
</ul>
<h2 id="可变数组-NSMutableArray"><a href="#可变数组-NSMutableArray" class="headerlink" title="可变数组 (NSMutableArray)"></a>可变数组 (NSMutableArray)</h2><ul>
<li>arrayWithCapacity:方法：创建一个具有固定长度的可变数组</li>
<li>initWithCapacity:方法：初始化一个具有固定长度的可变数组</li>
<li>addObject:方法：添加数组元素</li>
<li>addObjectsFromArray:方法：用数组创建可变数组</li>
<li>removeObject:方法：删除指定的元素</li>
<li>removeAllObjects:方法：删除可变数组中的所有元素</li>
<li>removeLastObject:方法：删除可变数组中的最后一个元素</li>
<li>removeObjectAtIndex:方法：删除指定位置的元素</li>
<li>removeObjectsAtIndex:方法：删除可变数组中的元素</li>
<li>removeObjectsInRange:方法：删除某个范围内的可变数组中的元素</li>
<li>removeObjectsInArray:方法：删除与另一个数组相同的元素</li>
<li>replaceObjectAtIndex:方法：替换可变数组中某一位置的元素</li>
<li>replaceObjectsAtIndexes:方法：替换可变数组中的多个元素</li>
<li>replaceObjectsInRange:方法：替换某一范围的数组元素</li>
<li>insertObject:方法：在某一位置插入数组元素</li>
<li>insertObjects:方法：在某一位置或范围插入另一数组元素</li>
<li>exchangeObjectAtIndex:方法：交换两个元素</li>
<li>setArray:方法：设置可变数组中内容</li>
</ul>
<h1 id="字典对象-NSDictionary"><a href="#字典对象-NSDictionary" class="headerlink" title="字典对象(NSDictionary)"></a>字典对象(NSDictionary)</h1><h2 id="创建及初始化-2"><a href="#创建及初始化-2" class="headerlink" title="创建及初始化"></a>创建及初始化</h2><ul>
<li>dictionary:方法：创建字典</li>
<li>dictionaryWithContentsOfFile:方法：将创建的字典内容设置为指定文件内容</li>
<li>dictionaryWithContentsOfURL:方法：将创建的字典内容设置为指定url内容</li>
<li>dictionaryWithDictionary:方法：用字典创建字典</li>
<li>dictionaryWithObject:方法：创建具有一个键-值的字典</li>
<li>dictionaryWithObjects:方法：创建具有多个键-值的字典</li>
<li>dictionaryWithObjectsAndKeys:方法：创建具有多个键-值的字典</li>
<li>init:方法：初始化字典</li>
<li>initWithContentsOfFile:方法：将初始化的字典内容设置为指定文件内容</li>
<li>initWithContentsOfURL:方法：将初始化的字典内容设置为指定url内容</li>
<li>initWithDictionary:方法：用字典初始化字典</li>
<li>initWithObjects:方法：初始化具有多个键-值的字典</li>
<li>initWithObjectsAndKeys:方法：初始化具有多个键-值的字典</li>
</ul>
<h2 id="访问键-值"><a href="#访问键-值" class="headerlink" title="访问键-值"></a>访问键-值</h2><ul>
<li>objectForKey:方法：返回键的值</li>
<li>allKeys:方法：返回所有的键</li>
<li>allValue:方法：返回所有的值</li>
<li>allKeysForObject:方法：返回值所对应的键</li>
<li>keyEnumerator:方法：将字典中所有的键放到NSEnumerator对象中</li>
<li>objectEnumerator:方法：将字典中所有的值放到一个NSEnumerator对象中</li>
</ul>
<h2 id="文件的处理"><a href="#文件的处理" class="headerlink" title="文件的处理"></a>文件的处理</h2><ul>
<li>fileCreationDate:方法：文件创建日期</li>
<li>fileModificationDate:方法：文件修改的日期</li>
<li>fileSize:方法：文件的大小</li>
<li>fileExtensionHidden:方法：扩展名是否隐藏</li>
<li>fileType:方法：文件的类型</li>
<li>fileGroupOwnerAccountID:方法：文件所属组标识</li>
<li>fileGroupOwnerAccountName:方法：文件所属组名</li>
<li>fileHFSCreatorCode:方法：文件分层系统创建者编码</li>
<li>fileHFSTypeCode:方法：文件分层系统类型编码</li>
<li>fileIsAppendOnly:方法：文件是否只读</li>
<li>fileIsImmutable:方法：文件是否可变</li>
<li>fileOwnerAccountID:方法：文件所属人标识</li>
<li>fileOwnerAccountName:方法：文件所属人</li>
<li>filePosixPermissions:方法：权限</li>
<li>fileSystemFileNumber:方法：文件系统的文件编号</li>
<li>fileSystemNumber:方法：文件系统编号</li>
<li>writeToFile:方法：字典内容写入文件中</li>
<li>writeToURL:方法：字典内容写入url中</li>
</ul>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li>count:方法：字典键-值个数</li>
<li>isEqualToDictionary:方法：判断字典是否相等</li>
</ul>
<h2 id="可变字典"><a href="#可变字典" class="headerlink" title="可变字典"></a>可变字典</h2><ul>
<li>dictionaryWithCapacity:方法：创建固定长度的可变字典</li>
<li>initWithCapacity:方法：初始化固定长度的可变字典</li>
<li>setObject:方法：设置键-值</li>
<li>setDictionary:方法：用字典设置可变字典中的内容</li>
<li>removeAllObjects:方法：删除所有的内容</li>
<li>removeObjectForKey:方法：删除键所对应的值</li>
<li>removeObjectsForKeys:方法：删除多个键所有的值</li>
<li>addEntriesFromDictionary:方法：将字典中的键-值添加到可变字典中</li>
</ul>
<h1 id="集合-NSSet"><a href="#集合-NSSet" class="headerlink" title="集合(NSSet)"></a>集合(NSSet)</h1><h2 id="创建以初始化"><a href="#创建以初始化" class="headerlink" title="创建以初始化"></a>创建以初始化</h2><ul>
<li>set:方法：创建集合</li>
<li>setWithArray:方法：用数组创建集合</li>
<li>setWithObject:方法：创建具有一个元素的集合</li>
<li>setWithObjects:方法：创建具有多个元素的集合</li>
<li>setWithSet:方法：集合创建集合</li>
<li>init:方法：初始化集合</li>
<li>initWithArray:方法：用数组初始化集合</li>
<li>initWithObjects:方法：初始化具有多个元素的集合</li>
<li>initWithSet:方法：集合初始化集合</li>
</ul>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><ul>
<li>objectEnumerator:方法：将所有集合中的元素放到NSEnumerator对象中</li>
<li>allObjects:方法：返回集合中所有的元素</li>
<li>anyObject:方法：返回任意一个元素</li>
<li>count:方法：返回元素个数</li>
</ul>
<h2 id="判断比较"><a href="#判断比较" class="headerlink" title="判断比较"></a>判断比较</h2><ul>
<li>containsObject:方法：判断集合中是否包含某个元素</li>
<li>member:方法：判断集合中是否包含某个元素并返回</li>
<li>isSubsetOfSet:方法：判断一个集合是否是一个集合的子集</li>
<li>intersectsSet:方法：判断交集</li>
<li>isEqualToSet:方法：判断集合是否相等</li>
</ul>
<h2 id="可变集合"><a href="#可变集合" class="headerlink" title="可变集合"></a>可变集合</h2><ul>
<li>setWithCapacity:方法：创建具有固定长度的可变集合</li>
<li>initWithCapacity:方法：初始化具有固定长度的可变集合</li>
<li>setSet:方法：通过集合设置可变集合的内容</li>
<li>addObject:方法：添加元素</li>
<li>addObjectsFromArray:方法：添加数组中的元素</li>
<li>removeAllObjects:方法：删除所有元素</li>
<li>removeObject:方法：删除指定的元素</li>
<li>unionSet:方法：添加集合元素</li>
<li>minusSet:方法：去除另一个集合中的元素</li>
<li>intersectSet:方法：做交集</li>
</ul>
<h1 id="文件-NSFileManager、NSFileHandle"><a href="#文件-NSFileManager、NSFileHandle" class="headerlink" title="文件(NSFileManager、NSFileHandle)"></a>文件(NSFileManager、NSFileHandle)</h1><h2 id="defaultManger-方法：创建文件管理器"><a href="#defaultManger-方法：创建文件管理器" class="headerlink" title="defaultManger:方法：创建文件管理器"></a>defaultManger:方法：创建文件管理器</h2><h2 id="文件与目录的操作"><a href="#文件与目录的操作" class="headerlink" title="文件与目录的操作"></a>文件与目录的操作</h2><ul>
<li>createFileAtPath:方法：创建文件</li>
<li>copyItemAtPath:方法：复制文件</li>
<li>moveItemAtPath:方法：移动文件</li>
<li>removeItemFileAtPath:方法：删除文件</li>
<li>attributesOfItemAtPath:方法：获取文件的属性</li>
<li>setAttributes:方法：更改属性</li>
<li>currentDirectoryPath:方法：获取当前的目录</li>
<li>changeCurrentDirectoryPath:方法：更改目录</li>
<li>createDirectoryAtPath:方法：创建目录</li>
</ul>
<h2 id="获取文件和目录信息"><a href="#获取文件和目录信息" class="headerlink" title="获取文件和目录信息"></a>获取文件和目录信息</h2><ul>
<li>contentsAtPath:方法：获取文件中的信息</li>
<li>enumeratorAtPath:方法：枚举目录</li>
<li>contentsOfDirectoryAtPath:方法：列举目录</li>
</ul>
<h2 id="判断文件"><a href="#判断文件" class="headerlink" title="判断文件"></a>判断文件</h2><ul>
<li>fileExistsAtPath:方法：判断文件是否存在</li>
<li>isReadableFile:方法：判断是否能进行读取操作</li>
<li>isWritableFileAtPath:方法：判断是否能进行写入操作</li>
<li>isDeletableFileAtPath:方法：判断是否可删除</li>
<li>isExecutableFileAtPath:方法：判断是否可以执行</li>
<li>contentsEqualAtPath:方法：判断是否相等</li>
</ul>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><ul>
<li>init:方法：初始化文件读写对象</li>
<li>fileHandleForReadingAtPath:方法：读取时打开文件</li>
<li>fileHandleForWritingAtPath:方法：写入时打开文件</li>
<li>fileHandleForUpdatingAtPath:方法：更新时打开文件</li>
<li>writeData:方法：数据写入文件</li>
<li>readDataToEndOfFile:方法：读取数据</li>
<li>readDataOfLength:方法：读取固定大小的内容</li>
<li>offsetInFile:方法：获取当前偏移量</li>
<li>seekToFileOffset:方法：设置当前的偏移量</li>
<li>seekToEndOfFile:方法：将偏移量定位到文件尾</li>
<li>truncateFileAtOffset:方法：设置字节</li>
<li>availableData:方法：返回可用数据</li>
<li>closeFile:方法：关闭文件</li>
</ul>
<h2 id="目录工具函数"><a href="#目录工具函数" class="headerlink" title="目录工具函数"></a>目录工具函数</h2><ul>
<li>NSUserName()函数：返回登录名</li>
<li>NSFullUserName()函数：返回完整用户名</li>
<li>NSHomeDirectory()函数：返回路径</li>
<li>NSHomeDirectoryForUser()函数：返回用户的主目录</li>
<li>NSTemporaryDirectory()函数：返回临时文件的路径目录</li>
</ul>
<h1 id="时间和日历-NSDate、NSDateFormatter、NSCalendarDate、NSCalendar、NSTimeZone、NSTimer"><a href="#时间和日历-NSDate、NSDateFormatter、NSCalendarDate、NSCalendar、NSTimeZone、NSTimer" class="headerlink" title="时间和日历(NSDate、NSDateFormatter、NSCalendarDate、NSCalendar、NSTimeZone、NSTimer)"></a>时间和日历(NSDate、NSDateFormatter、NSCalendarDate、NSCalendar、NSTimeZone、NSTimer)</h1><h2 id="时间的创建及初始化"><a href="#时间的创建及初始化" class="headerlink" title="时间的创建及初始化"></a>时间的创建及初始化</h2><ul>
<li>date:方法：创建时间</li>
<li>dateWithString:方法：用字符串创建时间</li>
<li>dateWithNaturalLanguageString:方法：用字符串创建时间</li>
<li>dateWithTimeInterval:方法：用时间间隔创建时间</li>
<li>dateWithTimeIntervalSince1970:方法：用时间间隔创建时间</li>
<li>dateWithTimeIntervalSinceNow:方法：用时间间隔创建时间</li>
<li>dateWithTimeIntervalSinceReferenceDate:方法：用时间间隔创建时间</li>
<li>init:方法：初始化时间</li>
<li>initWithString:方法：用字符串初始化时间</li>
<li>initWithTimeInterval:方法：用时间间隔初始化时间</li>
<li>initWithTimeIntervalSince1970:方法：用时间间隔初始化时间</li>
<li>initWithTimeIntervalSinceNow:方法：用时间间隔初始化时间</li>
<li>initWithTimeIntervalSinceReferenceDate:方法：用时间间隔初始化时间</li>
</ul>
<h2 id="时间的比较"><a href="#时间的比较" class="headerlink" title="时间的比较"></a>时间的比较</h2><ul>
<li>isEqualToDate:方法：比较是否相等</li>
<li>compare:方法：比较时间</li>
<li>earlierDate:方法：比较哪个时间早</li>
<li>laterDate:方法：比较哪个时间晚</li>
</ul>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><ul>
<li>dateByAddingTimeInterval:方法：获取经过时间间隔后的时间</li>
<li>distantPast:方法：获取过去的时间</li>
<li>distantFuture:方法：获取将来的时间</li>
<li>timeIntervalSinceDate:方法：获取两时间的差值</li>
<li>timeIntervalSinceNow:方法：获取两时间的差值</li>
<li>timeIntervalSince1970:方法：获取两时间的差值</li>
<li>timeIntervalSinceReferenceDate:方法：获取两时间的差值</li>
</ul>
<h2 id="时间和字符串的相互转换"><a href="#时间和字符串的相互转换" class="headerlink" title="时间和字符串的相互转换"></a>时间和字符串的相互转换</h2><ul>
<li>init:方法：初始化用于时间转换的对象</li>
<li>setDateFormat:方法：设置格式</li>
<li>initWithDateFormat:方法：初始化用于时间转换的对象</li>
</ul>
<h2 id="日历时间的创建及初始化"><a href="#日历时间的创建及初始化" class="headerlink" title="日历时间的创建及初始化"></a>日历时间的创建及初始化</h2><ul>
<li>calendarDate:方法：创建日历时间</li>
<li>dateWithYear:方法：创建日历时间并设置内容</li>
<li>dateWithString:方法：创建日历时间并设置内容及格式</li>
<li>init:方法：初始化日历时间</li>
<li>initWithYear:方法：初始化日历时间并设置内容</li>
<li>initWithString:方法：初始化日历时间并设置内容及格式</li>
</ul>
<h2 id="获取日历时间信息"><a href="#获取日历时间信息" class="headerlink" title="获取日历时间信息"></a>获取日历时间信息</h2><ul>
<li>dayOfWeek:方法：获取天数</li>
<li>dayOfMonth:方法：获取天数</li>
<li>dayOfYear:方法：获取天数</li>
<li>hourOfDay:方法：获取时间</li>
<li>minuteOfHour:方法：获取时间</li>
<li>secondOfMinute:方法：获取时间</li>
<li>monthOfYear:方法：获取时间</li>
<li>yearOfCommonEra:方法：获取年</li>
<li>dayOfCommonEra:方法：获取天数</li>
<li>calendarFormat:方法：获取日历的格式</li>
<li>timeZone:方法：获取时区</li>
<li>dateByAddingYears:方法：获取日期时间</li>
</ul>
<h2 id="设置日历时间"><a href="#设置日历时间" class="headerlink" title="设置日历时间"></a>设置日历时间</h2><ul>
<li>setCalendarFormat:方法：设置日历的格式</li>
<li>setTimeZone:方法：设置时区</li>
</ul>
<h2 id="日历的使用"><a href="#日历的使用" class="headerlink" title="日历的使用"></a>日历的使用</h2><ul>
<li>currentCalendar:方法：创建日历</li>
<li>autoupdatingCurrentCalendar:方法：获取日历</li>
<li>initWithCalendarIdentifier:方法：初始化日历</li>
<li>local:方法：获取区域</li>
<li>firstWeekday:方法：获取每周的第一天</li>
<li>minimumDaysInFirstWeek:方法：获取天数</li>
<li>calendarIdentifier:方法：获取日历</li>
<li>setFirstWeekday:方法：设置每周的第一天</li>
<li>setMinimumDaysInFirstWeek:方法：设置天数</li>
</ul>
<h2 id="时区的使用"><a href="#时区的使用" class="headerlink" title="时区的使用"></a>时区的使用</h2><ul>
<li>timeZoneWithName:方法：用已知时区创建时区</li>
<li>timeZoneWithAbbreviation:方法：用已知时区创建时区</li>
<li>timeZoneForSecondsFromGMT:方法：用偏移创建时区</li>
<li>initWithName:方法：用已知时区初始化时区</li>
<li>systemTimeZone:方法：获取系统的时区</li>
<li>localTimeZone:方法：获取本地时区</li>
<li>knownTimeZoneNames:方法：返回所有时区</li>
<li>name:方法：获取名称</li>
<li>abbreviation:方法：获取缩写</li>
<li>secondsFromGMT:方法：获取秒数</li>
</ul>
<h2 id="定时器的使用"><a href="#定时器的使用" class="headerlink" title="定时器的使用"></a>定时器的使用</h2><ul>
<li>timerWithTimeInterval:方法：创建定时器</li>
<li>initWithFireDate:方法：初始化定时器</li>
<li>setFireDate:方法：设置时间</li>
<li>fireDate:方法：返回时间</li>
<li>invalidate:方法：使定时器无效</li>
<li>isValid:方法：判断是否有效</li>
</ul>
<h1 id="进程、线程、锁-NSProcessInfo、NSThread、NSLock"><a href="#进程、线程、锁-NSProcessInfo、NSThread、NSLock" class="headerlink" title="进程、线程、锁(NSProcessInfo、NSThread、NSLock)"></a>进程、线程、锁(NSProcessInfo、NSThread、NSLock)</h1><h2 id="使用进程"><a href="#使用进程" class="headerlink" title="使用进程"></a>使用进程</h2><ul>
<li>processInfo:方法：创建进程</li>
<li>init:方法：初始化进程</li>
<li>processName:方法：获取进程的名称</li>
<li>environment:方法：获取变量/值</li>
<li>globallyUniqueString:方法：生成字符串</li>
<li>operatingSystem:方法：获取操作系统信息</li>
<li>operatingSystemName:方法：获取操作系统的名称</li>
<li>operatingSystemVersionString:方法：获取操作系统的版本信息</li>
<li>processIdentifier:方法：获取进程的标识符</li>
<li>arguments:方法：获取进程的参数</li>
<li>hostName:方法：获取主机名称</li>
<li>setProcessName:方法：设置进程的名称</li>
<li>processorCount:方法：获取CPU的数目</li>
</ul>
<h2 id="线程的创建及初始化"><a href="#线程的创建及初始化" class="headerlink" title="线程的创建及初始化"></a>线程的创建及初始化</h2><ul>
<li>detachNewThreadSelector:方法：创建线程</li>
<li>init:方法：初始化线程</li>
<li>initWithTarget:方法：初始化线程</li>
</ul>
<h2 id="执行线程"><a href="#执行线程" class="headerlink" title="执行线程"></a>执行线程</h2><ul>
<li>start:方法：开启线程</li>
<li>cancel:方法：取消线程</li>
<li>exit:方法：结束线程</li>
</ul>
<h2 id="获取与设置线程"><a href="#获取与设置线程" class="headerlink" title="获取与设置线程"></a>获取与设置线程</h2><ul>
<li>currentThread:方法：获取当前线程</li>
<li>threadPriority:方法：获取属性值</li>
<li>setThreadPriority:方法：设置属性值</li>
<li>name:方法：获取名称</li>
<li>setName:方法：设置名称</li>
<li>stackSize:方法：获取堆栈</li>
<li>setStackSize:方法：设置堆栈</li>
</ul>
<h2 id="判断线程"><a href="#判断线程" class="headerlink" title="判断线程"></a>判断线程</h2><ul>
<li>isMultiThreaded:方法：判断线程是否为主线程</li>
<li>isExecuting:方法：判断线程是否在执行</li>
<li>isCancelled:方法：判断线程是否取消</li>
<li>isFinished:方法：判断线程是否结束</li>
</ul>
<h2 id="使用互斥锁"><a href="#使用互斥锁" class="headerlink" title="使用互斥锁"></a>使用互斥锁</h2><ul>
<li>lock:方法：调用锁</li>
<li>unlock:方法：关闭锁</li>
<li>trylock:方法：锁定锁</li>
<li>lockBeforeDate:方法：在一定时间内获取锁</li>
</ul>
<h2 id="使用递归锁"><a href="#使用递归锁" class="headerlink" title="使用递归锁"></a>使用递归锁</h2><ul>
<li>lock:方法：调用锁</li>
<li>unlock:方法：关闭锁</li>
<li>tryLock:方法：获取锁</li>
<li>lockBeforeDate:方法：在一定时间内获取锁</li>
</ul>
<h2 id="使用条件锁"><a href="#使用条件锁" class="headerlink" title="使用条件锁"></a>使用条件锁</h2><ul>
<li>initWithCondition:方法：初始化条件锁</li>
<li>condition:方法：获取条件</li>
<li>lockWhenCondition:方法：在条件允许下调用锁</li>
<li>unlockWithCondition:方法：在条件允许下关闭锁</li>
<li>tryLockWhenCondition:方法：在条件允许下获取锁</li>
<li>lockWhenCondition:方法：在条件和时间允许下获取锁</li>
<li>tryLock:方法：获取锁</li>
<li>lockBeforeDate:方法：在一定时间下获取锁</li>
<li>lock:方法：调用锁</li>
<li>unlock:方法：关闭锁</li>
</ul>
<h1 id="数据对象及归档-NSData、NSKeyedArchiver"><a href="#数据对象及归档-NSData、NSKeyedArchiver" class="headerlink" title="数据对象及归档(NSData、NSKeyedArchiver)"></a>数据对象及归档(NSData、NSKeyedArchiver)</h1><h2 id="数据对象的创建及初始化"><a href="#数据对象的创建及初始化" class="headerlink" title="数据对象的创建及初始化"></a>数据对象的创建及初始化</h2><ul>
<li>data:方法：创建数据对象</li>
<li>dataWithBytes:方法：用已有数据创建数据对象</li>
<li>dataWithContentsOfFile:方法：将数据对象内容设置为指定文件内容</li>
<li>dataWithContentsOfURL:方法：将创建对象的内容设置为url指定的内容</li>
<li>dataWithData:方法：用已有数据对象创建新的数据对象</li>
<li>init:方法：初始化数据对象</li>
<li>initWithBytes:方法：用已有数据初始化数据对象</li>
<li>initWithContentsOfFile:方法：对数据对象初始化并将其设置为指定文件内容</li>
<li>initWithContentsOfURL:方法：对数据对象初始化并将其设置为指定url内容</li>
<li>initWithData:方法：用已有数据对象初始化新的数据对象</li>
</ul>
<h2 id="数据对象的使用"><a href="#数据对象的使用" class="headerlink" title="数据对象的使用"></a>数据对象的使用</h2><ul>
<li>bytes:方法：将数据对象转换为字符</li>
<li>dataUsingEncoding:方法：将字符串转换为数据对象</li>
<li>length:方法：计算数据对象的长度</li>
<li>isEqualToData:方法：判断两个数据对象是否相等</li>
<li>subdataWithRange:方法：截取数据对象</li>
<li>writeToFile:方法：写入文件</li>
<li>writeToURL:方法：写入url</li>
</ul>
<h2 id="可变数据对象"><a href="#可变数据对象" class="headerlink" title="可变数据对象"></a>可变数据对象</h2><ul>
<li>dataWithCapacity:方法：创建一个具有固定空间大小的可变数据对象</li>
<li>dataWithLength:方法：创建具有固定长度的可变数据对象</li>
<li>initWithCapacity:方法：初始化具有固定空间大小的可变数据对象</li>
<li>initWithLength:方法：初始化具有固定长度的可变数据对象</li>
<li>setData:方法：设置内容</li>
<li>setLength:方法：设置长度</li>
<li>appendBytes:方法：添加数据</li>
<li>appendData:方法：添加数据对象</li>
<li>mutableBytes:方法：可变数据对象转化为字符</li>
<li>replaceBytesInRange:方法：替换</li>
<li>resetBytesInRange:方法：删除</li>
</ul>
<h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><ul>
<li>archiveRootObject:方法：数据归档</li>
<li>unarchiveObjectWithFile:方法：取消归档</li>
<li>encodeBool:方法：对布尔类型的数据编码</li>
<li>decodeBoolForKey:方法：对布尔类型数据解码</li>
<li>encodeInt:方法：对整型数据编码</li>
<li>decodeIntForKey:方法：对整型数据解码</li>
<li>encodeFloat:/encodeDouble:方法：对浮点型数据编码</li>
<li>decodeFloatForKey:/decodeDoubleForKey:方法：对浮点型数据解码</li>
<li>encodeObject:方法：对对象进行编码</li>
<li>decodeObjectForKey:方法：对对象进行解码</li>
<li>archivedDataWithRootObject:方法：将其他类型的数据进行转换</li>
<li>initForWritingWithMutableData:方法：初始化</li>
<li>initForReadingWithData:方法：初始化</li>
</ul>
<h1 id="窗口和颜色-NSWindow、NSColor"><a href="#窗口和颜色-NSWindow、NSColor" class="headerlink" title="窗口和颜色(NSWindow、NSColor)"></a>窗口和颜色(NSWindow、NSColor)</h1><h2 id="获取窗口信息"><a href="#获取窗口信息" class="headerlink" title="获取窗口信息"></a>获取窗口信息</h2><ul>
<li>aspectRatio:方法：获取窗口的纵横比</li>
<li>orderedIndex:方法：获取索引</li>
<li>title:方法：获取窗口的标题</li>
<li>miniwindowTitle:方法：获取窗口最小化后的标题</li>
<li>frame:方法：获取窗口的位置和大小</li>
<li>minSize:方法：获取窗口的最小尺寸</li>
<li>maxSize:方法：获取窗口的最大尺寸</li>
<li>miniwindowImage:方法：获取窗口最小化后的图片</li>
<li>backgroundColor:方法：获取窗口的背景颜色</li>
<li>childWindows:方法：获取子窗口</li>
<li>alphaValue:方法：获取窗口的透明度值</li>
</ul>
<h2 id="设置窗口"><a href="#设置窗口" class="headerlink" title="设置窗口"></a>设置窗口</h2><ul>
<li>setAspectRatio:方法：设置窗口的纵横比</li>
<li>setIsVisible:方法：设置窗口是否可见</li>
<li>setTitle:方法：设置窗口标题</li>
<li>setMiniwindowTitle:方法：设置窗口最小化后的标题</li>
<li>setIsMiniaturized:方法：设置窗口是否最小化</li>
<li>setIsZoomed:方法：设置窗口是否最大化</li>
<li>setFrame:方法：设置窗口的位置和大小</li>
<li>setFrameOrigin:方法：设置窗口的位置</li>
<li>setFrameTopLeftPoint:方法：设置窗口的位置</li>
<li>setMinSize:方法：设置窗口的最小尺寸</li>
<li>setMaxSize:方法：设置窗口的最大尺寸</li>
<li>setMiniwindowImage:方法：设置窗口最小化后的图片</li>
<li>setBackgroundColor:方法：设置窗口的背景颜色</li>
<li>setCanHide:方法：设置窗口是否可以隐藏</li>
<li>setAlphaValue:方法：设置窗口的透明度值</li>
<li>disableFlushWindow:方法：将窗口设置为禁用的</li>
<li>setHasShadow:方法：设置窗口的阴影</li>
</ul>
<h2 id="判断窗口"><a href="#判断窗口" class="headerlink" title="判断窗口"></a>判断窗口</h2><ul>
<li>isVisible:方法：判断窗口是否可见</li>
<li>isMiniaturized:方法：判断窗口是否最小化</li>
<li>isZoomed:方法：判断窗口是否最大化</li>
<li>canHide:方法：判断窗口是否可以隐藏</li>
<li>hasShadow:方法：判断窗口是否有阴影</li>
<li>isMiniaturizable:方法：判断窗口是否有最小化按钮</li>
<li>hasTitleBar:方法：判断窗口是否有工具栏</li>
</ul>
<h2 id="创建自定义颜色对象"><a href="#创建自定义颜色对象" class="headerlink" title="创建自定义颜色对象"></a>创建自定义颜色对象</h2><ul>
<li>colorWithCalibratedRed:方法：用标准RGB分量创建颜色对象</li>
<li>colorWithCalibratedWhite:方法：用标准灰度分量创建颜色对象</li>
<li>colorWithCalibratedHue:方法：用标准HSB分量创建颜色对象</li>
<li>colorWithDeviceCyan:方法：用设备CMYB分量创建颜色对象</li>
<li>colorWithDeviceRed:方法：用设备RGB分量创建颜色对象</li>
<li>colorWithDeviceWhite:方法：用设备灰度分量创建颜色对象</li>
<li>colorWithDeviceHue:方法：用设备HSB分量创建颜色对象</li>
<li>colorWithPatternImage:方法：用图像创建颜色对象</li>
</ul>
<h2 id="创建颜色对象"><a href="#创建颜色对象" class="headerlink" title="创建颜色对象"></a>创建颜色对象</h2><ul>
<li>redColor:方法：用红色创建颜色对象</li>
<li>greenColor:方法：用绿色创建颜色对象</li>
<li>blueColor:方法：用蓝色创建颜色对象</li>
<li>cyanColor:方法：用青色创建颜色对象</li>
<li>magentaColor:方法：用紫红色创建颜色对象</li>
<li>yellowColor:方法：用黄色创建颜色对象</li>
<li>blackColor:方法：用黑色创建颜色对象</li>
<li>brownColor:方法：用棕色创建颜色对象</li>
<li>darkGrayColor:方法：用深灰色创建颜色对象</li>
<li>grayColor:方法：用灰色创建颜色对象</li>
<li>lightGrayColor:方法：用浅灰色创建颜色对象</li>
<li>orangeColor:方法：用橙色创建颜色对象</li>
<li>purpleColor:方法：用紫色创建颜色对象</li>
<li>whiteColor:方法：用白色创建颜色对象</li>
</ul>
<h2 id="获取颜色分量"><a href="#获取颜色分量" class="headerlink" title="获取颜色分量"></a>获取颜色分量</h2><ul>
<li>redComponent:方法：获取红色的分量</li>
<li>greenComponent:方法：获取绿色的分量</li>
<li>blueComponent:方法：获取蓝色的分量</li>
<li>cyanComponent:方法：获取青色的分量</li>
<li>magentaComponent:方法：获取紫红色分量</li>
<li>yellowComponent:方法：获取黄色分量</li>
<li>blackComponent:方法：获取黑色的分量</li>
<li>whiteComponent:方法：获取白色的分量</li>
<li>alphaComponent:方法：获取透明度分量</li>
<li>hueComponent:方法：获取色调的分量</li>
<li>saturationComponent:方法：获取饱和度的分量</li>
<li>brightnessComponent:方法：获取亮度分量</li>
<li>patternImage:方法：获取图像信息</li>
</ul>
<h1 id="自定义视图-NSView"><a href="#自定义视图-NSView" class="headerlink" title="自定义视图(NSView)"></a>自定义视图(NSView)</h1><h2 id="initWithFrame-方法：初始化自定义视图"><a href="#initWithFrame-方法：初始化自定义视图" class="headerlink" title="initWithFrame:方法：初始化自定义视图"></a>initWithFrame:方法：初始化自定义视图</h2><h2 id="获取与设置自定义视图信息"><a href="#获取与设置自定义视图信息" class="headerlink" title="获取与设置自定义视图信息"></a>获取与设置自定义视图信息</h2><ul>
<li>frame:方法：获取自定义视图的框架</li>
<li>setFrame:方法：设置自定义视图框架</li>
<li>frameRotation:方法：获取自定义视图的旋转度数</li>
<li>setFrameRotation:方法：设置自定义视图旋转度数</li>
<li>setFrameOrigin:方法：设置自定义视图的位置</li>
<li>setFrameSize:方法：设置自定义视图的大小</li>
<li>bounds:方法：获取自定义视图框架</li>
<li>setBounds:方法：设置自定义视图框架</li>
<li>boundsRotation:方法：获取自定义视图的旋转度数</li>
<li>setBoundsRotation:方法：设置自定义视图旋转的度数</li>
<li>setBoundsOrigin:方法：设置视图的位置</li>
<li>setBoundsSize:方法：设置视图的大小</li>
<li>subviews:方法：获取子视图</li>
<li>setPostsFrameChangedNotifications:方法：设置是否接收视图的变化</li>
<li>setPostsBoundsChangedNotifications:方法：设置是否接收视图的变化</li>
<li>printJobTitle:方法：获取输出标题</li>
</ul>
<h2 id="drawRect-方法：绘图"><a href="#drawRect-方法：绘图" class="headerlink" title="drawRect:方法：绘图"></a>drawRect:方法：绘图</h2><h2 id="判断自定义视图"><a href="#判断自定义视图" class="headerlink" title="判断自定义视图"></a>判断自定义视图</h2><ul>
<li>postsFrameChangedNotifications:方法：判断是否接收视图变换的消息</li>
<li>postsBoundsChangedNotifications:方法：判断是否接收视图变换的消息</li>
<li>isFlipped:方法：判断视图是否翻转</li>
<li>isRotatedFromBase:方法：判断视图是否旋转</li>
<li>isRotatedOrScaledFromBase:方法：判断视图是否旋转或缩放</li>
<li>canDraw:方法：判断视图是否绘制</li>
<li>isOpaque:方法：判断视图是否不透明</li>
</ul>
<h2 id="操作自定义视图"><a href="#操作自定义视图" class="headerlink" title="操作自定义视图"></a>操作自定义视图</h2><ul>
<li>addSubview:方法：添加视图</li>
<li>removeFromSuperview:方法：删除视图</li>
<li>replaceSubview:方法：替换视图</li>
</ul>
<h1 id="文本框和文本视图-NSTextField、NSTextView"><a href="#文本框和文本视图-NSTextField、NSTextView" class="headerlink" title="文本框和文本视图(NSTextField、NSTextView)"></a>文本框和文本视图(NSTextField、NSTextView)</h1><h2 id="获取与设置文本框信息"><a href="#获取与设置文本框信息" class="headerlink" title="获取与设置文本框信息"></a>获取与设置文本框信息</h2><ul>
<li>stringValue:方法：获取文本框的字符串</li>
<li>setStringValue:方法：设置文本框中的字符串</li>
<li>backgroundColor:方法：获取文本框的背景颜色</li>
<li>setBackgroundColor:方法：设置文本框的背景颜色</li>
<li>textColor:方法：获取字符串的颜色</li>
<li>setTextColor:方法：设置字符串的颜色</li>
<li>setImportsGraphics:方法：设置是否可以将图像拖到文本框</li>
<li>setEditable:方法：设置文本框是否可以编译</li>
<li>bezelStyle:方法：获取文本框边框的风格</li>
<li>setBezelStyle:方法：设置文本框边框的风格</li>
<li>setBezeled:方法：设置文本框是否接受bezeled边框</li>
<li>setBordered:方法：设置文本框是否接受黑边框</li>
</ul>
<h2 id="判断文本框信息"><a href="#判断文本框信息" class="headerlink" title="判断文本框信息"></a>判断文本框信息</h2><ul>
<li>importsGraphics:方法：判断是否可以将图像拖到文本框</li>
<li>isEditable:方法：判断文本框是否可以编辑</li>
<li>isBezeled:方法：判断文本框是否接受了bezeled边框</li>
<li>isBordered:方法：判断文本框是否接受了黑边框</li>
<li>acceptsFirstResponder:方法：判断文本框是否可以编辑</li>
</ul>
<h2 id="initWithFrame-方法：创建并初始化文本视图"><a href="#initWithFrame-方法：创建并初始化文本视图" class="headerlink" title="initWithFrame:方法：创建并初始化文本视图"></a>initWithFrame:方法：创建并初始化文本视图</h2><h2 id="获取与设置文本视图信息"><a href="#获取与设置文本视图信息" class="headerlink" title="获取与设置文本视图信息"></a>获取与设置文本视图信息</h2><ul>
<li>backgroundColor:方法：获取文本视图的颜色</li>
<li>setBackgroundColor:方法：设置文本视图的背景颜色</li>
<li>setImportsGraphics:方法：设置文件是否可以导入到文本视图</li>
<li>setAcceptsGlyphInfo:方法：设置文本视图是否接受字形信息</li>
<li>setAlignment:方法：设置文本视图内容的对齐方式</li>
<li>insertionPointColor:方法：获取插入点的颜色</li>
<li>setInsertionPointColor:方法：设置插入点的颜色</li>
<li>setAllowsUndo:方法：设置文本视图是否可以撤销</li>
<li>selectedTextAttributes:方法：获取用于指示选择的属性</li>
<li>setSelectedTextAttributes:方法：设置文本视图用于指示选择的属性</li>
<li>textContainer:方法：获取文本框的文本容器</li>
<li>acceptableDragTypes:方法：获取文本视图的数据类型</li>
<li>markedTextAttributes:方法：获取绘制标记的文本属性</li>
<li>setMarkedTextAttributes:方法：设置绘制标记的文本属性</li>
<li>setSmartInsertDeleteEnabled:方法：设置选择字符串周围的空间</li>
<li>markedRange:方法：获取被标记文本的范围</li>
<li>selectedRange:方法：获取选中文本的范围</li>
<li>setSelectedRange:方法：设置文本的选中范围</li>
<li>typingAttributes:方法：获取新文本的属性</li>
<li>setTypingAttributes:方法：设置新文本的属性</li>
</ul>
<h2 id="判断文本视图的信息"><a href="#判断文本视图的信息" class="headerlink" title="判断文本视图的信息"></a>判断文本视图的信息</h2><ul>
<li>importsGraphics:方法：判断文件是否可以导入到文本视图</li>
<li>acceptsGlyphInfo:方法：判断文本视图是否接受字形信息</li>
<li>allowsUndo:方法：判断文本视图是否启用撤销</li>
<li>smartInsertDeleteEnabled:方法：判断选择字符串周围的空间</li>
</ul>
<h1 id="图像、图像视图-NSImage、NSImageView"><a href="#图像、图像视图-NSImage、NSImageView" class="headerlink" title="图像、图像视图(NSImage、NSImageView)"></a>图像、图像视图(NSImage、NSImageView)</h1><h2 id="加载图像"><a href="#加载图像" class="headerlink" title="加载图像"></a>加载图像</h2><ul>
<li>imageNamed:方法：加载Supporting Files文件夹中的图片</li>
<li>initWithContentsOfURL:方法：加载URL中的图像</li>
<li>initWithContentsOfFile:方法：加载文件中的图片</li>
<li>initWithSize:方法：加载图像的大小</li>
</ul>
<h2 id="获取与设置图像信息"><a href="#获取与设置图像信息" class="headerlink" title="获取与设置图像信息"></a>获取与设置图像信息</h2><ul>
<li>size:方法：获取图像的大小</li>
<li>setSize:方法：设置图像的大小</li>
<li>setFlipped:方法：设置图像是否倒立</li>
<li>cacheMode:方法：获取图像的缓存模式</li>
<li>setCacheMode:方法：设置图像的缓存模式</li>
<li>backgroundColor:方法：获取图像的背景色</li>
<li>setBackgroundColor:方法：设置图像的背景色</li>
<li>name:方法：获取图像的名称</li>
<li>setName:方法：设置图像的名称</li>
<li>setTemplate:方法：设置图像是否表示一个模板图像</li>
<li>imageTypes:方法：获取图像类型</li>
<li>imageUnfilteredTypes:方法：获取图像类型</li>
<li>imageFileTypes:方法：获取文件类型</li>
<li>imageUnfilteredFileTypes:方法：获取文件类型</li>
<li>imagePasteboardTypes:方法：获取粘贴板类型</li>
<li>imageUnfilteredPasteboardTypes:方法：获取粘贴板类型</li>
<li>representations:方法：获取图像表示</li>
</ul>
<h2 id="判断图像信息"><a href="#判断图像信息" class="headerlink" title="判断图像信息"></a>判断图像信息</h2><ul>
<li>isFlipped:方法：判断图像是否倒立</li>
<li>prefersColorMatch:方法：判断图像颜色匹配</li>
<li>isTemplate:方法：判断图像是否为模板图像</li>
</ul>
<h2 id="获取与设置图像视图"><a href="#获取与设置图像视图" class="headerlink" title="获取与设置图像视图"></a>获取与设置图像视图</h2><ul>
<li>image:方法：获取显示图像的信息</li>
<li>setImage:方法：设置显示的图像</li>
<li>imageAlignment:方法：获取图像的对齐方式</li>
<li>setImageAlignment:方法：设置图像的对齐方式</li>
<li>imageFrameStyle:方法：获取框架的风格</li>
<li>setImageFrameStyle:方法：设置框架的风格</li>
<li>imageScaling:方法：获取图像缩放的方式</li>
<li>setImageScaling:方法：设置图像缩放方式</li>
<li>isEditable:方法：判断图像视图是否可以编辑</li>
<li>setEditable:方法：设置图像视图是否编辑</li>
<li>allowsCutCopyPaste:方法：判断图像是否可复制、粘贴等操作</li>
<li>setAllowsCutCopyPaste:方法：设置图像是否可复制、粘贴等操作</li>
<li>animates:方法：判断图像视图是否播放动画</li>
<li>setAnimates:方法：设置图像视图是否播放动画</li>
</ul>
<h1 id="表视图-NSTableView"><a href="#表视图-NSTableView" class="headerlink" title="表视图(NSTableView)"></a>表视图(NSTableView)</h1><h2 id="获取表视图信息"><a href="#获取表视图信息" class="headerlink" title="获取表视图信息"></a>获取表视图信息</h2><ul>
<li>rowHeight:方法：获取表视图的行高</li>
<li>headerView:方法：获取NSTableHeaderView对象</li>
<li>intercellSpacing:方法：获取表单元之间的间距</li>
<li>numberOfColumns:方法：获取表视图中的列数</li>
<li>numberOfRows:方法：获取表视图的行数</li>
<li>numberOfSelectedColumns:方法：获取选中的列数</li>
<li>numberOfSelectedRows:方法：获取选择的行数</li>
<li>rowSizeStyle:方法：获取行风格</li>
</ul>
<h2 id="设置表视图的信息"><a href="#设置表视图的信息" class="headerlink" title="设置表视图的信息"></a>设置表视图的信息</h2><ul>
<li>setRowHeight:方法：设置表视图的行高</li>
<li>setIntercellSpacing:方法：设置表单元之间的间距</li>
<li>setRowSizeStyle:方法：设置行风格</li>
<li>setAllowsColumnReordering:方法：设置用户是否可以重新排列列标题</li>
<li>setAllowsColumnResizing:方法：设置是否可以调整列标题</li>
<li>setAllowsColumnSelection:方法：设置是否可以选择一整列</li>
<li>setAllowsTypeSelect:方法：设置是否可以通过按键字符进行选择</li>
<li>setAllowsMultipleSelection:方法：设置是否允许选择多行或多列</li>
</ul>
<h2 id="判断表视图信息"><a href="#判断表视图信息" class="headerlink" title="判断表视图信息"></a>判断表视图信息</h2><ul>
<li>allowsColumnReordering:方法：判断用户是否可以重新排列列标题</li>
<li>allowsColumnResizing:方法：判断是否可以调整列标题</li>
<li>allowsColumnSelection:方法：判断是否可以选择一整列</li>
<li>allowsEmptySelection:方法：判断是否允许有0个行或列被选中</li>
<li>allowsTypeSelect:方法：判断是否可以通过按键字符进行选择</li>
<li>allowsMultipleSelection:方法：判断是否允许选择多行或多列</li>
</ul>
<h1 id="常见控件-NSButton、NSDatePicker、NSProgressIndicator、NSComboBox"><a href="#常见控件-NSButton、NSDatePicker、NSProgressIndicator、NSComboBox" class="headerlink" title="常见控件(NSButton、NSDatePicker、NSProgressIndicator、NSComboBox)"></a>常见控件(NSButton、NSDatePicker、NSProgressIndicator、NSComboBox)</h1><h2 id="按钮控件-NSButton"><a href="#按钮控件-NSButton" class="headerlink" title="按钮控件(NSButton)"></a>按钮控件(NSButton)</h2><ul>
<li>title:方法：获取按钮的标题</li>
<li>setTitle:方法：设置按钮的标题</li>
<li>image:方法：获取按钮的图像</li>
<li>setImage:方法：设置按钮的图像</li>
<li>isTransparent:方法：判断按钮是否透明</li>
<li>setTransparent:方法：设置按钮是否透明</li>
<li>showsBorderOnlyWhileMouseInside:方法：判断边框的显示</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/10/新电脑常用软件工具的安装配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/10/新电脑常用软件工具的安装配置/" class="post-title-link" itemprop="url">新电脑常用软件工具的安装配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-10 15:52:41" itemprop="dateCreated datePublished" datetime="2020-09-10T15:52:41+08:00">2020-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>查看软件工具是否已经安装，可以通过查看软件工具的版本信息进行检查。如能查询到软件的<strong>版本信息</strong>，则软件工具已经安装，反之则未安装。</p>
<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><p><a href="https://brew.sh" target="_blank" rel="noopener">Homebrew官网</a></p>
<ul>
<li><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p>
</li>
<li><p>安装</p>
<ul>
<li>安装过程中可能因为网络环境的改变，导致安装不能成功，提示各种错误信息。因软件的时效性，此时根据错误信息度娘、谷歌解决。</li>
</ul>
</li>
</ul>
<h1 id="Item2-oh-my-zsh"><a href="#Item2-oh-my-zsh" class="headerlink" title="Item2 + oh-my-zsh"></a>Item2 + oh-my-zsh</h1><p><a href="https://www.iterm2.com/downloads.html" target="_blank" rel="noopener">Item2官网</a></p>
<p>下载oh-my-zsh，如提示错误，根据错误信息，度娘、谷歌解决～</p>
<h1 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h1><p><a href="http://www.sublimetext.cn" target="_blank" rel="noopener">SublimeText官网</a></p>
<p>一款用于代码、标记和散文的精致文本编辑器</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/iOS知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/iOS知识点/" class="post-title-link" itemprop="url">iOS知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-21 16:22:19" itemprop="dateCreated datePublished" datetime="2020-04-21T16:22:19+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="UI视图"><a href="#UI视图" class="headerlink" title="UI视图"></a>UI视图</h2><h3 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h3><p>UITableView中数据源同步解决方案</p>
<ul>
<li>并发访问、数据拷贝，因为拷贝，对内存会有大量开销</li>
<li>串行访问，删除时会可能有延迟</li>
</ul>
<h3 id="事件传递-amp-视图响应"><a href="#事件传递-amp-视图响应" class="headerlink" title="事件传递&amp;视图响应"></a>事件传递&amp;视图响应</h3><p>UIView和CALayer之间的关系：UIView的成员属性中有layer，layer是CALayer类型的，UIView的显示部分，是由CALayer的contents来决定的，contents对应的是backing store，backing store是bitmap类型的一个位图，最后显示到屏幕上的UI控件都是位图</p>
<p>总结：</p>
<ul>
<li>UIView为CALayer提供内容，以及负责处理触摸等事件，参与视图的事件响应链</li>
<li>CALayer负责显示内容contents</li>
</ul>
<p>UIView和CALayer功能不同，却又相互联系，体现了设计原则上的单一职责原则，从职责上进行分工</p>
<hr>
<p><strong>事件传递</strong>与<strong>视图响应链</strong></p>
<p>与事件传递相关的两个主要方法：</p>
<ul>
<li>hitTest:withEvent:，返回响应事件的视图</li>
<li><p>pointInside:withEvent:，判断点击的位置，是否在当前视图的范围内</p>
</li>
<li><p>事件传递流程：</p>
<ul>
<li>事件传递流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/事件传递的流程.png" alt="事件传递的流程"></p>
<p>倒序遍历，即最后添加到当前View上的视图，最优先得到遍历</p>
<ul>
<li>hit系统实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/hit系统实现.png" alt="hit系统实现"></p>
</li>
<li><p>视图响应流程：(响应事件)</p>
<ul>
<li>视图响应流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/视图响应流程.png" alt="视图响应流程"></p>
</li>
</ul>
<p>与视图事件响应相关的方法：</p>
<ul>
<li>touchesBegan:withEvent:</li>
<li>touchesMoved:withEvent:</li>
<li>touchesEnded:withEvent:</li>
</ul>
<h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><ul>
<li>硬件<code>CPU</code>和<code>GPU</code>的关系</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/CPU_GPU的关系.png" alt="CPU_GPU的关系"></p>
<p>硬件<code>CPU</code>和<code>GPU</code>是通过总线连接起来的。<code>CPU</code>输出的结果通常是位图，在适当的时机，通过总线上传给<code>GPU</code>，<code>GPU</code>获得位图数据后进行纹理等渲染操作，将经渲染操作处理后的结果数据放在帧缓冲区内(Frame Buffer)，由视频控制器根据V-Sync信号，在指定时间之前去提取对应帧缓冲区内的屏幕显示内容，最终显示在手机屏幕上。</p>
<ul>
<li><p><code>UI</code>视图最终显示到屏幕上面的大致过程</p>
<ul>
<li>图像显示原理</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/图像显示原理.png" alt="图像显示原理"></p>
</li>
</ul>
<p>概述：</p>
<p>当创建一个<code>UIView</code>控件后，显示部分是由<code>CALayer</code>来负责的，<code>CALayer</code>中的<code>contents</code>属性负责存放要显示到屏幕上的内容的位图。系统在适当时机会回调给我们<code>drawRect</code>方法，在该方法内，我们可以做自定义的绘制，绘制好的位图，最终会经由<code>Core Animation</code>这个框架提交给<code>GPU</code>部分的<code>OpenGL(ES)</code>渲染管线，进行最终的位图渲染、纹理合成，最终显示到屏幕上面。</p>
<h3 id="卡顿-amp-掉帧"><a href="#卡顿-amp-掉帧" class="headerlink" title="卡顿&amp;掉帧"></a>卡顿&amp;掉帧</h3><p>为保证界面流畅性，需要在1/60s内(即16.67ms)，由<code>CPU</code>和<code>GPU</code>共同协同完成产生一帧所需要的数据。</p>
<p>卡顿原因：</p>
<p>在规定的<code>16.67ms</code>之内，在下一个<code>V-Sync</code>信号到来之前，并没有<code>CPU</code>和<code>GPU</code>共同完成下一帧画面的合成，于是就会导致卡顿/掉帧。</p>
<p>滑动优化方案：</p>
<p>优化依据：视图显示过程中，在准备下一帧画面之前，CPU所做的工作非常多(layout、display、prepare、commit)。实际上是基于减轻CPU工作的时长、包括压力，来达到优化的效果。</p>
<ul>
<li><p>针对CPU的优化方案</p>
<ul>
<li>对象创建、调整、销毁，可以放到子线程，以节省CPU的部分时间</li>
<li>预排版(布局计算、文本计算)，可以放到子线程处理，这样主线程就有更多的时间能较快响应用户的交互</li>
<li>预渲染(文本等异步绘制、图片编解码等)</li>
</ul>
</li>
<li><p>针对GPU等优化方案</p>
<ul>
<li>基于纹理渲染，尽量避免离屏渲染。产生离屏渲染后，GPU的工作量会变大</li>
<li>可以依托CPU的异步绘制机制，来减轻GPU的压力</li>
<li>基于视图混合，减轻视图层级的复杂性</li>
</ul>
</li>
</ul>
<h3 id="绘制原理-amp-异步绘制"><a href="#绘制原理-amp-异步绘制" class="headerlink" title="绘制原理&amp;异步绘制"></a>绘制原理&amp;异步绘制</h3><p>异步绘制是用来解决UI视图滑动性能方面的技术解决方案</p>
<ul>
<li><p>UIView视图绘制原理步骤</p>
<ul>
<li>UIView绘制原理的流程图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/UIView绘制原理的过程.png" alt="UIView绘制原理的过程"></p>
</li>
</ul>
<p>调用setNeedsDisplay不会立即进入到绘制流程，只有在当前RunLoop将要结束的时候，才会进入到当前视图的绘制流程</p>
<ul>
<li>系统的绘制流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/系统的绘制流程.png" alt="系统的绘制流程"></p>
<ul>
<li><p>UI异步绘制的过程</p>
<ul>
<li>实现系统提供的接口displayLayer:</li>
<li>代理负责生成对应的bitmap</li>
<li>设置该bitmap作为layer.contents属性的值</li>
</ul>
</li>
<li><p>异步绘制时序流程图</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/异步绘制时序流程图.png" alt="异步绘制时序流程图"></p>
<h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p>什么是离屏渲染、对离屏渲染的理解</p>
<p>离屏渲染的概念起源于GPU层面</p>
<p>相对离屏渲染而言的是在屏渲染(即当前屏幕渲染)</p>
<p>在屏渲染指的是GPU层面的一个概念</p>
<ul>
<li><p>何时触发离屏渲染</p>
<ul>
<li>圆角(同时要和maskToBounds一起使用时)，两个条件都满足时才能触发离屏渲染</li>
<li>图层蒙版</li>
<li>阴影</li>
<li>光栅化</li>
</ul>
</li>
<li><p>为何要避免离屏渲染</p>
<ul>
<li>因，离屏渲染发生在GPU层面，触发离屏渲染会增加GPU的工作量</li>
<li>创建新的渲染缓冲区</li>
<li>上下文切换</li>
</ul>
</li>
</ul>
<hr>
<h2 id="OC语言特性"><a href="#OC语言特性" class="headerlink" title="OC语言特性"></a>OC语言特性</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>分类的使用</p>
<ul>
<li>声明私有方法</li>
<li>分解体积庞大的类文件</li>
<li>把Framework的私有方法公开化</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>在运行时进行决议，只有在运行时，才将在分类中的方法添加到宿主类中(编译时/运行时)</li>
<li>可以为系统类添加分类</li>
</ul>
</li>
<li><p>分类中可添加的内容</p>
<ul>
<li>实例方法</li>
<li>类方法</li>
<li>协议</li>
<li>属性(实际上只声明了对应的set/get方法，不能直接添加实例变量/成员变量)</li>
</ul>
</li>
</ul>
<p>多个分类中的同名方法哪个会生效，最后编译的分类中的同名方法会生效</p>
<p><strong>分类方法会“覆盖”宿主类的方法</strong>，因在分类的源代码实现过程中，分类中的方法在方法列表中的位置处于原宿主方法的前面，当分类中的方法与宿主中的方法同名时，所要执行的方法命中方法列表中分类的方法(优先实现)，就不会再执行宿主中的同名方法，体现效果为分类中的方法“覆盖”了宿主中的同名方法</p>
<ul>
<li>分类的总结<ul>
<li>分类添加的方法可以“覆盖”原类方法</li>
<li>同名分类方法谁能生效取决于编译顺序(最后被编译的分类，会被优先生效)</li>
<li>名字相同的分类会引起编译报错</li>
</ul>
</li>
</ul>
<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><ul>
<li><p>关联对象的本质</p>
<ul>
<li>关联对象由AssociationsManager管理并在AssociationsHashMap存储</li>
<li>所有对象的关联内容都在同一个全局容器中</li>
<li>具体过程，可见下图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/关联对象的本质.png" alt="关联对象的本质"></p>
</li>
</ul>
<p>通过关联对象，可以给分类添加“成员变量”。添加的“成员变量”，没有添加到宿主类上，添加到一个全局容器中。可见下图</p>
<p><img src="/2020/04/21/iOS知识点/分类成员变量的本质.png" alt="分类成员变量的本质"></p>
<ul>
<li>使用的关键方法<ul>
<li>objc_getAssociatedObject</li>
<li>objc_setAssociatedObject</li>
<li>objc_removeAssociatedObjects</li>
</ul>
</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><p>用扩展来做</p>
<ul>
<li>声明私有属性</li>
<li>声明私有方法</li>
<li>声明私有成员变量</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>编译时决议</li>
<li>只以声明的形式存在，多数情况下寄生于宿主类的.m中(分类有声明.h和实现.m)</li>
<li>不能为系统类添加扩展(可以为系统类添加分类)</li>
</ul>
</li>
</ul>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><ul>
<li>准确的说是一种软件设计模式(代理模式)</li>
<li>iOS当中以@protocol形式体现</li>
<li>传递方式是一对一</li>
<li>涉及协议(方法、属性)、委托方、代理方</li>
</ul>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><ul>
<li><p>特点</p>
<ul>
<li>是使用<strong>观察者模式</strong>(特点)来实现的用于<strong>跨层传递消息</strong>(作用)的机制</li>
<li>传递方式为一对多</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/通知一对多的流程.png" alt="通知一对多的流程"></p>
</li>
<li><p>如何实现通知的机制</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/实现通知的机制.png" alt="实现通知的机制"></p>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><ul>
<li><p>什么是KVO</p>
<ul>
<li>KVO是Key-value observing的缩写</li>
<li>KVO是OC对<strong>观察者设计模式</strong>的又一实现</li>
<li>Apple使用了isa混写(<strong>isa-swizzling</strong>)来实现KVO(如何实现混写，涉及KVO的实现机制)</li>
</ul>
</li>
<li><p>KVO的实现机制</p>
</li>
</ul>
<p>isa混写技术的实现(系统在运行时动态创建了一个子类，改写了isa的指向，同时重写了setter方法，来实现kvo的机制的)(调用addObserverForKeyPath之后系统底层的实现)</p>
<p><img src="/2020/04/21/iOS知识点/KVO的实现机制.png" alt="KVO的实现机制"></p>
<p>重写setter方法的过程中，调用了如下两个方法</p>
<ul>
<li>willChangeValueForKey:</li>
<li><p>didChangeValueForKey:</p>
</li>
<li><p>面试点</p>
<ul>
<li>通过kvc设置value能使kvo生效，因为通过kvc设置value的过程中，触发了目标对象对应的setter方法</li>
<li>通过成员变量的直接赋值，是不会触发系统的kvo</li>
<li>手动kvo方式，即对相应属性手动重写willChangeValueForKey和didChangeValueForKey(will、did成对出现)</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>使用setter方法改变值kvo才会生效</li>
<li>使用setValue:forKey:改变值kvo才会生效</li>
<li>成员变量直接修改需<strong>手动添加</strong>kvo才会生效</li>
</ul>
</li>
</ul>
<h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><ul>
<li><p>键值编码技术，与键值编码技术相关的两个方法</p>
<ul>
<li>-valueForKey:</li>
<li>-setValue:forKey:</li>
</ul>
<p>KVC这种键值编码技术，是会破坏面向对象编程思想</p>
<ul>
<li>valueForKey的调用流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/valueForKey调用流程.png" alt="valueForKey调用流程"></p>
<p>关键点是访问器、实例变量</p>
<ul>
<li>访问器的说明</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/访问器.png" alt="访问器"></p>
<ul>
<li>实例变量的说明</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/实例变量.png" alt="实例变量"></p>
<ul>
<li>setValue:forKey:的调用流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/setValueForKey的调用流程.png" alt="setValueForKey的调用流程"></p>
</li>
</ul>
<h3 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h3><ul>
<li><p>属性关键字的类型</p>
<ul>
<li>读写权限<ul>
<li>readonly</li>
<li>readwrite(默认)</li>
</ul>
</li>
<li>原子性<ul>
<li>atomic(默认)，指明赋值或获取是线程安全的</li>
<li>nonatomic(常声明的类型)</li>
</ul>
</li>
<li>引用计数<ul>
<li>retain(MRC)/strong(ARC)</li>
<li>assign(修饰基本数据类型、对象类型)/unsafe_unretained(MRC)</li>
<li>weak</li>
<li>copy</li>
</ul>
</li>
</ul>
</li>
<li><p>assign/weak</p>
<ul>
<li>assign<ul>
<li>修饰基本数据类型，如int、BOOL等</li>
<li>修饰对象类型时，不改变其引用计数</li>
<li>会产生悬垂指针</li>
</ul>
</li>
<li><p>weak</p>
<ul>
<li>不改变被修饰对象的引用计数</li>
<li>所指对象在被释放之后会自动置为nil</li>
</ul>
</li>
<li><p>copy关键字</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/copy关键字.png" alt="copy关键字"></p>
</li>
</ul>
<hr>
<h2 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h2><h3 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h3><ul>
<li>编译时语言与动态运行时语言的区别</li>
<li>消息传递与函数调用的区别</li>
<li>消息传递</li>
<li>消息转发</li>
<li>Method-Swizzling(方法混淆)(运行时替换方法的实现)</li>
<li>不能向编译后的类中增加实例变量，因此时已经完成了实例变量的内存布局，所以编译后是无法修改的</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>objc_object</p>
<ul>
<li>OC中常用的id类型，对应到Runtime中就是objc_object这个结构体</li>
<li><p>objc_object结构体中的主要成员如下图</p>
<p><img src="/2020/04/21/iOS知识点/objc_object主要成员.png" alt="objc_object主要成员"></p>
</li>
</ul>
<ul>
<li><p>objc_class</p>
<ul>
<li>OC中使用的Class类型，对应到Runtime中就是objc_class这个结构体</li>
<li><p>objc_class结构体的构成如下图</p>
<p><img src="/2020/04/21/iOS知识点/objc_class结构体构成.png" alt="objc_class结构体构成"></p>
</li>
</ul>
</li>
<li><p>isa指针</p>
<ul>
<li>是共用体isa_t类型</li>
<li><p>以64位架构为例，isa指针类型如下图</p>
<p><img src="/2020/04/21/iOS知识点/isa指针类型.png" alt="isa指针类型"></p>
</li>
<li><p>isa指向</p>
<p><img src="/2020/04/21/iOS知识点/isa指向.png" alt="isa指向"></p>
</li>
</ul>
</li>
<li><p>cache_t</p>
<ul>
<li>用于快速查找方法执行函数</li>
<li>是可增量扩展的哈希表结构</li>
<li>是<strong>局部性原理</strong>的最佳应用(常被调用的方法，放到方法缓冲区中，提高调用方法时被调用方法的命中率)</li>
<li><p>cache_t结构说明如下图</p>
<p><img src="/2020/04/21/iOS知识点/cache_t的结构.png" alt="cache_t的结构"></p>
<p>key是方法选择器名称</p>
</li>
</ul>
</li>
<li><p>class_data_bits_t</p>
<ul>
<li>class_data_bits_t主要是对class_rw_t的封装</li>
<li>class_rw_t代表了类相关的读写信息、对class_ro_t的封装</li>
<li>class_ro_t代表了类相关的只读信息</li>
<li><p>class_rw_t结构如下</p>
<p><img src="/2020/04/21/iOS知识点/class_rw_t结构.png" alt="class_rw_t结构"></p>
</li>
<li><p>class_ro_t结构如下</p>
<p><img src="/2020/04/21/iOS知识点/class_ro_t结构.png" alt="class_ro_t结构"></p>
</li>
<li><p>method_t</p>
<ul>
<li>method_t是对函数四要素的封装和抽象</li>
<li><p>method_t结构如下</p>
<p><img src="/2020/04/21/iOS知识点/method_t结构.png" alt="method_t结构"></p>
</li>
<li><p>method_t中的types结构，使用了Type Encodings技术</p>
</li>
<li><p>types结构如下</p>
<p><img src="/2020/04/21/iOS知识点/types结构.png" alt="types结构"></p>
<p>图中的v@:就是method_t中types所存储的内容。图中体现了调用函数时，函数中所隐藏的固有参数self(消息接收者)，即函数的调用者，对应到types中的@来体现</p>
<p>调用方法(消息传递)，到达Runtime层面都会转换成objc_msgSend()这样的函数调用，objc_msgSend()的第一个参数和第二个参数都是固定不变的，第一个参数需是id类型(是消息的接收者)，第二个参数是SEL(选择器)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Runtime整体数据结构</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/runtime基础数据结构.png" alt="runtime基础数据结构"></p>
<p>基于上图可作为回答<strong>消息传递机制</strong>、<strong>转发流程</strong>、<strong>编译时语言和动态运行时语言的区别</strong>的依据</p>
</li>
</ul>
<h3 id="类对象、元类对象-amp-消息传递"><a href="#类对象、元类对象-amp-消息传递" class="headerlink" title="类对象、元类对象&amp;消息传递"></a>类对象、元类对象&amp;消息传递</h3><ul>
<li><p>什么是类对象、元类对象</p>
<ul>
<li>类对象</li>
<li>元类对象</li>
</ul>
</li>
<li><p>实例对象可以通过isa指针找到对应的类对象</p>
</li>
<li><strong>类对象</strong>存储<strong>实例方法</strong>列表等信息</li>
<li><strong>元类对象</strong>存储<strong>类方法</strong>列表等信息</li>
<li>调用的类方法，是从元类的类方法列表中查找获取的</li>
<li>类对象和元类对象关系图如下</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/类对象和元类对象关系.png" alt="类对象和元类对象关系"></p>
<p>从给定的实例对象，依据上图进行分析、论述类对象与元类对象间的关系</p>
<p><strong>重听5-3</strong></p>
<ul>
<li>id类型对应是objc_object数据结构类型，objc_object中有isa成员变量</li>
<li><strong>isa是指针指向</strong></li>
<li><p>类对象和元类对象都是objc_class数据结构的，objc_class继承于objc_object，所以类对象和元类对象都有isa指针</p>
</li>
<li><p>消息传递转化成了函数调用，是发生在<strong>编译器</strong>层面的</p>
</li>
<li><p>消息传递</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/消息传递.png" alt="消息传递"></p>
<ul>
<li><p>消息传递流程中的关键环节</p>
<ul>
<li><p>缓存查找</p>
<ul>
<li><p>缓存查找，实际上就是根据给定的方法选择器(SEL)，来查找方法的对应实现(IMP)</p>
<p><img src="/2020/04/21/iOS知识点/缓存查找.png" alt="缓存查找"></p>
</li>
<li><p>hash查找</p>
</li>
</ul>
</li>
<li><p>当前类中查找</p>
<ul>
<li>对于已排好序的方法列表，采用二分查找</li>
<li>对于未排序的方法列表，采用一般遍历查找</li>
</ul>
</li>
<li><p>父类逐级查找</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/父类逐级查找.png" alt="父类逐级查找"></p>
</li>
</ul>
<h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><ul>
<li>实例方法的消息转发流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/实例方法的消息转发.png" alt="实例方法的消息转发"></p>
<ul>
<li>方法签名<ul>
<li>根据method_t中的types来理解，方法签名的格式如‘v@:’</li>
</ul>
</li>
</ul>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method-Swizzling"></a>Method-Swizzling</h3><ul>
<li>用于页面统计等场景</li>
</ul>
<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><ul>
<li>为类动态添加方法<ul>
<li>使用接口class_addMethod()</li>
</ul>
</li>
</ul>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><ul>
<li><p>dynamic</p>
<ul>
<li>指明属性的setter和getter方法是在运行时添加，不是在编译时实现</li>
</ul>
</li>
<li><p>用dynamic做引子，作如下回答</p>
<ul>
<li>动态运行时语言将函数决议推迟到运行时</li>
<li>编译时语言在编译期进行函数决议</li>
</ul>
</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><ul>
<li>内存布局</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/内存布局.png" alt="内存布局"></p>
<ul>
<li>stack，栈区，方法调用，在该内存区进行展开</li>
<li>heap，堆区，通过alloc等分配的对象</li>
<li>bss，未初始化的全局变量等</li>
<li>data，已初始化的全局变量等</li>
<li>text，程序的代码段，加载到内存中，就存放在该区域中</li>
</ul>
<h3 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h3><ul>
<li>iOS系统针对不同的场景，会有不同的内存管理方案<ul>
<li>针对小对象，如NSNumber这样的，采用的是TaggedPointer内存管理方案</li>
<li>对于64位架构下的应用程序，采用的是NONPOINTER_ISA方案<ul>
<li>非指针型的isa，bit位除存储实际的isa指针信息外，剩余未使用的bit位用于存放内存管理相关的信息</li>
</ul>
</li>
<li>散列表，复杂的数据结构，包括<ul>
<li>引用计数表</li>
<li>弱引用表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER_ISA"></a>NONPOINTER_ISA</h4><ul>
<li><p>非指针型的isa</p>
</li>
<li><p>在arm64架构下，对NONPOINTER_ISA进行分析</p>
<ul>
<li>这种情况下isa的指针是64个bit位</li>
<li>bit结构如下</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/non_isa_bit_01.png" alt="non_isa_bit_01"></p>
<p><img src="/2020/04/21/iOS知识点/non_isa_bit_02.png" alt="non_isa_bit_02"></p>
<ul>
<li>第一位indexed，如为0的情况下，表示指针型的isa，即整体的bit数值表示的是实际的地址指针信息；如为1的情况下，表示非指针型的isa，即bit位除存储实际的isa指针信息外，剩余未使用的bit位用于存放内存管理相关的信息</li>
<li>shiftcls，是用于存储类地址值信息的</li>
</ul>
</li>
</ul>
<h4 id="散列表方式"><a href="#散列表方式" class="headerlink" title="散列表方式"></a>散列表方式</h4><ul>
<li>通过SideTables()这样的结构来实现<ul>
<li>SideTables()实际上是一个hash表</li>
</ul>
</li>
<li>SideTables()的结构如下</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/SideTables结构.png" alt="SideTables结构"></p>
<p><img src="/2020/04/21/iOS知识点/SideTable结构.png" alt="SideTable结构"></p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>内存管理方案<strong>散列表</strong>涉及的数据结构</p>
<ul>
<li><p>散列表的成员结构</p>
<ul>
<li>Spinlock_t(自旋锁)<ul>
<li>是“忙等”的锁</li>
<li>适用于轻量访问，如SideTable中对某个对象进行引用计数加一减一的操作(该操作非常快)</li>
</ul>
</li>
<li><p>RefcountMap(引用计数表)</p>
<ul>
<li>实际上是一个hash表</li>
<li>通过指针找到对应对象的引用计数</li>
<li>size_t(表示对应对象的引用计数值)(考虑引用计数存储是用64位的bit来表示的环境下的情况)</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RefcountMap.png" alt="RefcountMap"></p>
<p><img src="/2020/04/21/iOS知识点/RefcountMap_Size_t.png" alt="RefcountMap_Size_t"></p>
</li>
<li><p>weak_table_t(弱引用表)</p>
<ul>
<li>实际上是一张hash表</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/弱引用表.png" alt="弱引用表"></p>
</li>
</ul>
</li>
</ul>
<p>Tips:</p>
<p>hash查找可以提高效率的原因，因插入和获取都是通过同一个hash函数进行的，所以在根据给定值去hash列表中查找某个值时，会避免一般查找时所采取的循环遍历，进而提高了查找效率</p>
<h3 id="MRC-amp-ARC"><a href="#MRC-amp-ARC" class="headerlink" title="MRC&amp;ARC"></a>MRC&amp;ARC</h3><h4 id="MRC环境下"><a href="#MRC环境下" class="headerlink" title="MRC环境下"></a>MRC环境下</h4><ul>
<li>关于引用计数，涉及如下方法<ul>
<li>alloc、retain、release、retainCount、autorelease、dealloc</li>
</ul>
</li>
</ul>
<h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><ul>
<li>ARC是LLVM和Runtime协作的结果</li>
<li>ARC中禁止手动调用retain/release/retainCount/dealloc</li>
<li>ARC中新增weak、strong属性关键字</li>
</ul>
<h3 id="引用计数管理"><a href="#引用计数管理" class="headerlink" title="引用计数管理"></a>引用计数管理</h3><ul>
<li><p>通过分析alloc、retain、release、retainCount、dealloc等系统方法的内部实现来理解引用计数管理的实现流程</p>
</li>
<li><p>alloc的实现</p>
<ul>
<li>经过一系列调用，最终调用了C函数calloc</li>
<li>此时并没有设置引用计数为1。但调用retainCount查看引用计数值时，引用计数值为1，具体原因看retainCount的实现</li>
</ul>
</li>
<li><p>retain实现</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/retain实现.png" alt="retain实现"></p>
<p>加一操作不是真实的加上数字1，而是加上了一个偏移量，这个偏移量是4，反映出来的结果就是加一操作</p>
<ul>
<li>release实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/release实现.png" alt="release实现"></p>
<ul>
<li>retainCount实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/retainCount实现.png" alt="retainCount实现"></p>
<p>刚新alloc出来的一个对象，在引用计数表中，实际上是没有这个对象相关联的一个key-value的一个映射的，因此此时table.refcnts.find(this)-&gt;second读出来的值是0</p>
<ul>
<li>dealloc实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/dealloc实现的流程图.png" alt="dealloc实现的流程图"></p>
<p><strong>是否可以释放</strong>的判断环节，依据右边的五个标准进行判断，当五个标准都不满足时走YES流程。五个标准中的has_cxx_dtor会判断是否进行了c++操作、是否有ARC操作</p>
<ul>
<li>object_dispose()实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/object_dispose(" alt="object_dispose()实现">实现.png)</p>
<ul>
<li>objc_destructInstance()实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/objc_destructInstance(" alt="objc_destructInstance()实现">实现.png)</p>
<ul>
<li>clearDeallocating()实现</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/clearDeallocating(" alt="clearDeallocating()实现">实现.png)</p>
<p>weak修饰的属性在所指向的对象被释放后，相应属性被置为nil的原因，因系统底层在执行dealloc的时候，若对象有被weak修饰的属性所指向时，会执行weak_clear_no_lock()操作</p>
<h3 id="弱引用管理"><a href="#弱引用管理" class="headerlink" title="弱引用管理"></a>弱引用管理</h3><p><strong>重听6-6、6-7、6-8</strong></p>
<ul>
<li><p>weak变量，是怎样添加到弱引用表当中的，通过weak_register_no_lock()实现的</p>
</li>
<li><p>添加weak变量，发生的函数调用栈如下图</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/添加weak变量.png" alt="添加weak变量"></p>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><ul>
<li><p>自动释放池的实现原理</p>
<ul>
<li>是以栈为结点通过双向链表的形式组合而成</li>
<li>是和线程一一对应的</li>
</ul>
</li>
<li><p>autorelease流程</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/autorelease流程.png" alt="autorelease流程"></p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><ul>
<li><p>类型</p>
<ul>
<li>自循环引用</li>
<li>相互循环引用</li>
<li>多循环引用</li>
</ul>
</li>
<li><p>产生循环引用的情况</p>
<ul>
<li>代理（相互循环引用）</li>
<li>Block</li>
<li>NSTimer</li>
<li>大环引用</li>
</ul>
</li>
<li><p>如何破除循环引用</p>
<ul>
<li>避免产生循环引用</li>
<li>在合适的时机手动断环</li>
</ul>
</li>
<li><p>破除循环引用的解决方案</p>
<ul>
<li>__weak</li>
<li>__block<ul>
<li>MRC下，__block修饰对象不会增加其引用计数，避免了循环引用</li>
<li>ARC下，__block修饰对象会被强引用，无法避免循环引用，需要手动解环</li>
</ul>
</li>
<li>__unsafe_unretained，所修饰的对象，引用计数器不改变，等效于__weak<ul>
<li>修饰对象不会增加其引用计数，避免了循环引用</li>
<li>如果被修饰对象在某一时机被释放，会产生<strong>悬垂指针</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><h3 id="本质-什么是block"><a href="#本质-什么是block" class="headerlink" title="本质(什么是block)"></a>本质(什么是block)</h3><ul>
<li>Block是将<strong>函数</strong>及其<strong>执行上下文</strong>封装起来的<strong>对象</strong></li>
<li>理解Block是一个对象，是因其成员结构中有isa指针(Block是对象的标志)</li>
<li>Block的调用<ul>
<li>Block调用即是函数的调用</li>
</ul>
</li>
</ul>
<h3 id="截获变量"><a href="#截获变量" class="headerlink" title="截获变量"></a>截获变量</h3><p><strong>重点看</strong></p>
<p>针对不同类型的变量，block对变量的截获特点是不同的</p>
<ul>
<li><p>被截获变量的类型</p>
<ul>
<li>局部变量<ul>
<li>基本数据类型<ul>
<li>对于基本数据类型的局部变量截获其值</li>
</ul>
</li>
<li>对象类型<ul>
<li>对于对象类型的局部变量<strong>连同所有权修饰符</strong>一起截获</li>
</ul>
</li>
</ul>
</li>
<li><p>静态局部变量</p>
<ul>
<li>以指针形式截获局部静态变量</li>
</ul>
</li>
<li><p>全局变量</p>
</li>
<li>静态全局变量<ul>
<li>不截获全局变量、静态全局变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h3><ul>
<li>MRC下，__block修饰对象不会增加其引用计数，避免了循环引用</li>
<li><p>ARC下，__block修饰对象会被强引用，无法避免循环引用，需要手动解环</p>
</li>
<li><p>使用场景</p>
<ul>
<li>一般情况下，对被截获变量进行<strong>赋值</strong>操作需添加__block修饰符</li>
<li>使用 != 赋值，如对可变数组的使用</li>
</ul>
</li>
<li><p>对变量进行赋值时</p>
<ul>
<li>需要__block修饰符<ul>
<li>局部变量<ul>
<li>基本数据类型</li>
<li>对象类型</li>
</ul>
</li>
</ul>
</li>
<li>不需要__block修饰符<ul>
<li>静态局部变量</li>
<li>全局变量</li>
<li>静态全局变量</li>
</ul>
</li>
</ul>
</li>
<li><p>__block修饰的变量变成了对象</p>
</li>
<li><p><strong>栈上的__block</strong>的<strong>forwarding指针是指向</strong>block自身的</p>
</li>
<li><p>__forwarding指针与Block的内存管理有关</p>
</li>
</ul>
<h3 id="Block的内存管理"><a href="#Block的内存管理" class="headerlink" title="Block的内存管理"></a>Block的内存管理</h3><ul>
<li><p>block的类型，三种</p>
<ul>
<li>_NSConcreteGlobalBlock(全局)</li>
<li>_NSConcreteStackBlock(栈)</li>
<li>_NSConcreteMallocBlock(堆)</li>
</ul>
</li>
<li><p>不同类型的block在内存中的布局，如下图</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/不同block的内存分布.png" alt="不同block的内存分布"></p>
<ul>
<li>对block进行copy的效果</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/block_copy的效果.png" alt="block_copy的效果"></p>
<ul>
<li>栈上block的销毁</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/栈上block的销毁.png" alt="栈上block的销毁"></p>
<ul>
<li>栈上block的copy</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/栈上block的copy.png" alt="栈上block的copy"></p>
<ul>
<li>栈上__block的copy操作</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/栈上__block的copy操作.png" alt="栈上__block的copy操作"></p>
<p>注：前提是经过了copy操作</p>
<ul>
<li>__forwarding存在的意义<ul>
<li>不论在任何内存位置，都可以顺利访问同一个__block变量</li>
</ul>
</li>
</ul>
<h3 id="循环引用-1"><a href="#循环引用-1" class="headerlink" title="循环引用"></a>循环引用</h3><p><strong>重看7-5</strong> </p>
<hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>iOS系统中提供的多线程技术方案<ul>
<li>GCD</li>
<li>NSOperation(AFN)</li>
<li>NSThread(常驻线程)</li>
</ul>
</li>
</ul>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><ul>
<li>主队列当中所提交的任务，不论通过同步方式，还是异步方式，最终都要在主线程中进行处理和执行</li>
<li>通过同步方式提交任务，不论是提交到并行队列，还是串行队列，最终都是在当前线程上进行执行</li>
<li>GCD底层所分派的线程，默认情况下，是没有开启对应的RunLoop的，此时在线程中想要执行的方法，需要提交到线程对应的RunLoop中，并且RunLoop启动了，这时想要执行的方法才会执行生效(涉及线程和RunLoop的关系)</li>
</ul>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async()"></a>dispatch_barrier_async()</h3><ul>
<li>利用GCD实现多读单写</li>
</ul>
<h3 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async()"></a>dispatch_group_async()</h3><p><strong>重听8-3</strong></p>
<ul>
<li>使用GCD实现：A、B、C三个任务并发，完成后执行任务D</li>
</ul>
<h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><ul>
<li><p>使用NSOperation实现多线程编程，需要和NSOperationQueue配合使用来实现多线程方案</p>
</li>
<li><p>实现多线程方案的优势和特点</p>
<ul>
<li>可以添加任务依赖，通过addDependency以及removeDependency方法为任务添加依赖或移除依赖，这种特点是GCD和NSThead所不具备的</li>
<li>任务执行状态的控制<ul>
<li>isReady</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isCancelled</li>
<li>状态控制<ul>
<li>如果只重写main方法，底层控制变更任务执行完成状态，以及任务退出</li>
<li>如果重写了start方法，自行控制任务状态</li>
</ul>
</li>
</ul>
</li>
<li>可以控制最大并发量，通过设置max这个属性来控制最大并发量</li>
</ul>
</li>
<li><p>系统<strong>通过KVO</strong>移除一个isFinished=YES的NSOperation的</p>
</li>
</ul>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><ul>
<li><p>面试中关于NSThread的面试问题，通常是结合RunLoop来考察的</p>
</li>
<li><p>启动流程</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/NSThread启动流程.png" alt="NSThread启动流程"></p>
<p><img src="/2020/04/21/iOS知识点/实现常驻线程功能的实现.png" alt="实现常驻线程功能的实现"></p>
<ul>
<li>NSThead的执行原理<ul>
<li>内部创建了一个pthread线程，当main函数或指定的target的selector方法执行结束之后，系统会进行线程的退出管理操作，如要维护一个常驻线程，需要在NSThead所对应的selector方法中去维护一个RunLoop事件循环</li>
</ul>
</li>
</ul>
<h3 id="多线程与锁"><a href="#多线程与锁" class="headerlink" title="多线程与锁"></a>多线程与锁</h3><ul>
<li>iOS当中都有哪些锁<ul>
<li>@synchronized<ul>
<li>一般在创建单例对象的时候使用</li>
</ul>
</li>
<li>atomic<ul>
<li>修饰属性的关键字</li>
<li>对被修饰对象进行原子操作(不负责使用，即赋值时保证线程安全，使用时不保证线程安全，如，可变数组的使用)</li>
</ul>
</li>
<li>OSSpinLock<ul>
<li>自旋锁</li>
<li><strong>循环等待询问</strong>，不释放当前资源</li>
<li>用于轻量级数据访问，简单的int值 +1/-1 操作</li>
</ul>
</li>
<li>NSRecursiveLock<ul>
<li>递归锁</li>
<li>可以重入(递归锁的特点)</li>
</ul>
</li>
<li>NSLock<ul>
<li>开发中常使用的锁</li>
<li>保证线程互斥进入临界区</li>
</ul>
</li>
<li>dispatch_semaphore_t<ul>
<li>信号量</li>
<li>相关操作方法<ul>
<li>dispatch_semaphore_create()</li>
<li>dispatch_semaphore_wait()(阻塞行为是主动行为)</li>
<li>dispatch_semaphore_signal()(唤醒是被动行为)</li>
</ul>
</li>
</ul>
</li>
<li>不同锁对应不同的使用场景</li>
</ul>
</li>
</ul>
<hr>
<h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>RunLoop是通过内部维护的<strong>事件循环</strong>来对<strong>事件/消息进行管理</strong>的一个对象</p>
<ul>
<li>状态的切换(用户态<-->内核态)是解释什么是RunLoop的关键点</--></li>
</ul>
</li>
<li><p>事件循环</p>
<ul>
<li>没有消息需要处理时，休眠以避免资源占用<ul>
<li>线程的状态切换：当没有消息要处理时，线程由<strong>用户态</strong>通过系统调用进入<strong>内核态</strong></li>
</ul>
</li>
<li><p>有消息需要处理时，立刻被唤醒</p>
<ul>
<li>线程的状态切换：由<strong>内核态</strong>转变为<strong>用户态</strong></li>
</ul>
</li>
<li><p>用户态、内核态</p>
<ul>
<li>应用程序通常运行在用户态，用户态面向用户的操作交互；相对于用户态而言是内核态，内核态是针对系统级别的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>main函数为什么一直保持运行的状态而不会终止退出</p>
<ul>
<li>因为在main函数体内会调用UIApplicationMain()这个函数，在这个函数内部会启动一个主线程的运行循环(RunLoop)</li>
<li>RunLoop是对事件循环的一种维护机制</li>
<li>RunLoop的特点<ul>
<li>接收消息</li>
<li>处理</li>
<li>等待(不等于死循环)(线程休眠)</li>
<li>期间会发生用户态到内核态的相互切换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>NSRunLoop是CFRunLoop的封装，提供了面向对象的API</p>
<ul>
<li><p>RunLoop涉及的三个主要数据结构</p>
<ul>
<li>CFRunLoop<ul>
<li>pthread(可知，线程与RunLoop是一一对应的关系)</li>
<li>currentMode</li>
<li>modes</li>
<li>commonModes</li>
<li>commonModeItems</li>
</ul>
</li>
<li>CFRunLoopMode<ul>
<li>name</li>
<li>sources0</li>
<li>sources1</li>
<li>observers</li>
<li>timers</li>
</ul>
</li>
<li>Source/Timer/Observer<ul>
<li>CFRunLoopSource<ul>
<li>source0<ul>
<li>需要手动唤醒线程</li>
</ul>
</li>
<li>source1<ul>
<li>具备唤醒线程的能力</li>
</ul>
</li>
</ul>
</li>
<li>CFRunLoopTimer<ul>
<li>基于事件的定时器，和NSTimer是toll-free bridged(免费桥转换)的</li>
</ul>
</li>
<li>CFRunLoopObserver<ul>
<li>观测时间点<ul>
<li>kCFRunLoopEntry</li>
<li>kCFRunLoopBeforeTimers</li>
<li>kCFRunLoopBeforeSources</li>
<li>kCFRunLoopBeforeWaiting(RunLoop将从用户态切到内核态)</li>
<li>kCFRunLoopAfterWaiting</li>
<li>kCFRunLoopExit</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>各数据结构之间的关系</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RunLoop各数据结构之间的关系.png" alt="RunLoop各数据结构之间的关系"></p>
</li>
<li><p>RunLoop的Mode</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RunLoop的Mode.png" alt="RunLoop的Mode"></p>
<ul>
<li>CommonMode的特殊性<ul>
<li>NS中对应的是NSRunLoopCommonModes</li>
<li>CommonMode不是实际存在的一种Mode</li>
<li>是同步Source/Timer/Observer到多个Mode中的一种技术方案</li>
</ul>
</li>
</ul>
<h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p><strong>重听9-3</strong></p>
<ul>
<li>RunLoop事件循环机制流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RunLoop事件循环机制流程.png" alt="RunLoop事件循环机制流程"></p>
<ul>
<li>RunLoop的核心</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RunLoop的核心.png" alt="RunLoop的核心"></p>
<h3 id="RunLoop与NSTimer"><a href="#RunLoop与NSTimer" class="headerlink" title="RunLoop与NSTimer"></a>RunLoop与NSTimer</h3><ul>
<li>如何把一个timer同步到多个mode上面<ul>
<li>通过CFRunLoopAddTimer函数，给timer打上commonMode标签，将Timer添加到多个mode中</li>
</ul>
</li>
</ul>
<h3 id="RunLoop与多线程"><a href="#RunLoop与多线程" class="headerlink" title="RunLoop与多线程"></a>RunLoop与多线程</h3><ul>
<li>线程是和RunLoop一一对应的</li>
<li>自己创建的线程默认是没有RunLoop的，需要自己手动创建RunLoop<ul>
<li>使用场景(怎样实现一个常驻线程)，过程如下<ul>
<li>为当前线程开启一个RunLoop(调用currentRunLoop，该函数会去当前线程查找RunLoop，如果没有RunLoop，会为当前线程创建一个RunLoop)</li>
<li>向该RunLoop中添加一个Port/Source等维持RunLoop的事件循环</li>
<li>启动该RunLoop(调用run方法)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li><p>超文本传输协议</p>
</li>
<li><p>从以下方面理解HTTP</p>
<ul>
<li><p>请求/响应报文</p>
<ul>
<li>请求报文</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/请求报文.png" alt="请求报文"></p>
<ul>
<li>响应报文</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/响应报文.png" alt="响应报文"></p>
<ul>
<li><p>请求方式</p>
<ul>
<li>get、post、head、put、delete、options</li>
</ul>
</li>
<li><p>get和post的区别</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/get_post的区别.png" alt="get_post的区别"></p>
<ul>
<li>安全性：不应该引起Server端的任何状态变化(get/head/options)</li>
<li>幂等性：同一个请求方法执行多次和执行一次的效果完全相同(get/put/delete)</li>
<li>可缓存性：请求是否可以被缓存(get/head)</li>
</ul>
<ul>
<li>状态码<ul>
<li>1xx、2xx、3xx、4xx、5xx</li>
</ul>
</li>
</ul>
</li>
<li><p>连接建立流程</p>
<ul>
<li>HTTP的连接建立，涉及TCP的三次握手(三次握手中，通过第三次的ACK报文来确立是否建立连接，用于回答为何不采用两次握手)，四次挥手</li>
</ul>
</li>
<li>HTTP的特点<ul>
<li>无连接<ul>
<li>可以通过HTTP的<strong>持久连接</strong>方案来补偿无连接的问题</li>
</ul>
</li>
<li>无状态<ul>
<li>可以通过<strong>Cookie/Session</strong>来补偿无状态的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>持久连接</p>
<ul>
<li>涉及的头部字段<ul>
<li>Connection: keep-alive(指明是否持久连接)</li>
<li>time: 20(指定持续有效的时间段)</li>
<li>max: 10(指定可发送HTTP请求和响应的最大量)</li>
</ul>
</li>
<li>如何判断一个请求是否结束的方案<ul>
<li>Content-length: 1024(依据服务端返回的该字段值，对客户端所接收的数据进行判断，如客户端所接收的数据大小等于服务端返回的该字段值的大小，则本次请求结束)</li>
<li>chunked，最后会有一个空的chunked(post请求情况下，当服务端返回的报文中，chunked为空，则本次请求结束)</li>
</ul>
</li>
</ul>
</li>
<li><p>Charles抓包原理：中间人攻击</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/中间人攻击.png" alt="中间人攻击"></p>
<h3 id="HTTPS协议与网络安全"><a href="#HTTPS协议与网络安全" class="headerlink" title="HTTPS协议与网络安全"></a>HTTPS协议与网络安全</h3><ul>
<li><p>HTTP与HTTPS的区别</p>
<ul>
<li>HTTPS = HTTP + SSL/TLS</li>
<li>协议栈</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/HTTPS协议栈.png" alt="HTTPS协议栈"></p>
</li>
<li><p>HTTPS建立连接流程</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/HTTPS建立连接流程.png" alt="HTTPS建立连接流程"></p>
<ul>
<li><p>HTTPS采用的加密手段</p>
<ul>
<li>连接建立过程使用非对称加密，非对称加密很耗时</li>
<li>后续通信过程使用对称加密</li>
<li>非对称加密(安全性高)</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/非对称加密.png" alt="非对称加密"></p>
<ul>
<li>对称加密</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/对称加密.png" alt="对称加密"></p>
</li>
</ul>
<h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h3><p><strong>重听10-4、10-5</strong></p>
<ul>
<li>UDP特点<ul>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>面向报文<ul>
<li>既不合并，也不拆分</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP功能</p>
<ul>
<li>复用</li>
<li>分用</li>
<li>差错检测</li>
</ul>
</li>
<li><p>TCP特点</p>
<ul>
<li>面向连接<ul>
<li>三次握手</li>
<li>四次挥手</li>
</ul>
</li>
<li>可靠传输<ul>
<li>无差错</li>
<li>不丢失</li>
<li>不重复</li>
<li>按序到达</li>
<li>使用停止等待协议：无差错情况、超时重传、确认丢失、确认迟到</li>
</ul>
</li>
<li>面向字节流<ul>
<li>TCP连接是一个逻辑通道</li>
</ul>
</li>
<li><p>流量控制</p>
<ul>
<li><p>基于滑动窗口协议来实现的(按序到达)</p>
<p><img src="/2020/04/21/iOS知识点/滑动窗口协议过程.png" alt="滑动窗口协议过程"></p>
</li>
</ul>
</li>
<li><p>拥塞控制</p>
<ul>
<li>慢开始、拥塞避免</li>
<li>快恢复、快重传</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul>
<li><p>对DNS的了解</p>
<ul>
<li>域名到IP地址的映射，DNS解析请求采用UDP数据报，且明文</li>
</ul>
</li>
<li><p>DNS查询方式</p>
<ul>
<li>递归查询</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/DNS递归查询.png" alt="DNS递归查询"></p>
<ul>
<li>迭代查询</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/DNS迭代查询.png" alt="DNS迭代查询"></p>
</li>
<li><p>DNS解析存在的问题</p>
<ul>
<li>DNS劫持问题</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/DNS劫持.png" alt="DNS劫持"></p>
<ul>
<li>DNS解析转发问题</li>
</ul>
</li>
<li><p>DNS劫持与HTTP的关系是怎样的</p>
<ul>
<li>DNS劫持与HTTP没有关系，因DNS解析发生在HTTP建立连接之前</li>
<li>DNS解析请求使用UDP数据报，端口号53</li>
</ul>
</li>
<li><p>怎样解决DNS劫持</p>
<ul>
<li>httpDNS方案</li>
</ul>
<p><img src="iOS知识点/httpDNS实现理论.png" alt="httpDNS实现理论"></p>
<ul>
<li>长连接方案</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/DNS长连接方案.png" alt="DNS长连接方案"></p>
</li>
</ul>
<h3 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h3><ul>
<li><p>是对HTTP协议无状态特点的补偿</p>
</li>
<li><p>Cookie主要用来记录用户状态，区分用户；状态保存在客户端</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/Cookie流程.png" alt="Cookie流程"></p>
<p>客户端发送的cookie在http请求报文的Cookie首部字段中</p>
<p>服务器端设置http响应报文的Set-Cookie首部字段</p>
<ul>
<li><p>怎样修改Cookie</p>
<ul>
<li>新cookie覆盖旧cookie</li>
<li>覆盖规则：name、path、domain等需要与原cookie一致</li>
</ul>
</li>
<li><p>怎样删除Cookie</p>
<ul>
<li>新cookie覆盖旧cookie</li>
<li>覆盖规则：name、path、domain等需要与原cookie一致</li>
<li>设置cookie的expires=过去的一个时间点，或者maxAge=0(设置cookie失效)</li>
</ul>
</li>
<li><p>Session也是用来记录用户状态，区分用户；状态存放在服务器端</p>
</li>
<li><p>Session和Cookie的关系是怎样的</p>
<ul>
<li>Session需要依赖于Cookie机制</li>
<li>Session工作流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/Session工作流程.png" alt="Session工作流程"></p>
</li>
</ul>
<hr>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h3><p><img src="/2020/04/21/iOS知识点/六大设计原则.png" alt="六大设计原则"></p>
<ul>
<li>单一职责原则<ul>
<li>一个类只负责一件事，如CALayer和UIView</li>
</ul>
</li>
<li>开闭原则<ul>
<li>对修改关闭，对扩展开放</li>
</ul>
</li>
<li>接口隔离原则<ul>
<li>使用多个专门的协议，而不是一个庞大臃肿的协议，如UITableView</li>
<li>协议中的方法也尽量少</li>
</ul>
</li>
<li>依赖倒置原则<ul>
<li>抽象不应该依赖于具体实现，具体实现可以依赖于抽象</li>
</ul>
</li>
<li>里氏替换原则<ul>
<li>父类可以被子类无缝替换，且原有功能不受任何影响，如KVO</li>
</ul>
</li>
<li>迪米特法则<ul>
<li>一个对象应当对其他对象有尽可能少的了解</li>
<li>高内聚、低耦合</li>
</ul>
</li>
</ul>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><ul>
<li>类构成</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/责任链类构成.png" alt="责任链类构成"></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><ul>
<li>类构成</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/桥接类构成.png" alt="桥接类构成"></p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul>
<li><p>对象适配器</p>
<ul>
<li>类构成</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/对象适配器类构成.png" alt="对象适配器类构成"></p>
<p><img src="/2020/04/21/iOS知识点/对象适配器的逻辑实现.png" alt="对象适配器的逻辑实现"></p>
</li>
<li><p>类适配器</p>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例实现代码</p>
<p><img src="/2020/04/21/iOS知识点/单例实现代码.png" alt="单例实现代码"></p>
<ul>
<li>注意super的调用</li>
<li>要重写allocWithZone:和copyWithZone:</li>
</ul>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul>
<li>对行为进行参数化的设计模式，如微博。以降低代码重合度</li>
</ul>
<h2 id="重听11-6"><a href="#重听11-6" class="headerlink" title="重听11-6"></a><strong>重听11-6</strong></h2><h2 id="架构-框架"><a href="#架构-框架" class="headerlink" title="架构/框架"></a>架构/框架</h2><ul>
<li>引入架构&amp;框架，主要实现模块化，将各个功能按模块划分，作一个相应的分层，目的是为了解耦，最终实现降低代码重合度的效果</li>
</ul>
<h3 id="图片缓存框架"><a href="#图片缓存框架" class="headerlink" title="图片缓存框架"></a>图片缓存框架</h3><ul>
<li>怎样设计一个图片缓存框架</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/图片缓存框架.png" alt="图片缓存框架"></p>
<ul>
<li><p>图片通过什么方式进行读写</p>
<ul>
<li>以图片URL的单向Hash值作为Key</li>
<li>读取的过程如下</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/框架中图片的读取过程.png" alt="框架中图片的读取过程"></p>
<p>引入内存模块，是从多级缓存角度考虑的</p>
</li>
<li><p>内存的设计上需要考虑的问题</p>
<ul>
<li><p>存储的Size(从内存资源稀缺性的角度出发)</p>
<ul>
<li><p>存储的数据结构(从大小、使用频度上考虑)，队列方式存储(FIFO)</p>
<p><img src="/2020/04/21/iOS知识点/存储的Size.png" alt="存储的Size"></p>
</li>
</ul>
</li>
<li><p>淘汰的策略</p>
<ul>
<li>淘汰，因为内存Size大小有限</li>
<li>淘汰的策略依托于存储Size的设计方案的</li>
<li>方案<ul>
<li>以队列先进先出的方式淘汰</li>
<li>LRU算法(最近最久未使用算法)(如30分钟之内是否使用过)。可以通过<strong>定时检查(损耗性能)</strong>方式(思路，落地性不强)，也可通过<strong>提高检查触发频率(即每次触发时，对所有图片的未使用时长进行检查)(触发方式：每次进行读写时、前后台切换时)</strong>的方式。使用LRU算法时，注意开销问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘设计需要考虑的问题</p>
<ul>
<li>需要考虑磁盘空间大，但读取效率低的特点</li>
<li>存储方式的选择</li>
<li>大小限制(如100MB)</li>
<li>淘汰策略(如某一图片存储时间距今已超过7天)</li>
</ul>
</li>
<li><p>网络部分的设计需要考虑的问题</p>
<ul>
<li>图片请求的最大并发量</li>
<li>请求的超时策略(重试，如最多重试两次)</li>
<li>请求优先级</li>
</ul>
</li>
<li><p>图片解码</p>
<ul>
<li>对不同格式的图片，解码采用的方式<ul>
<li>应用策略模式对不同图片格式进行解码</li>
</ul>
</li>
<li>在哪个阶段做图片解码处理<ul>
<li>磁盘读取之后(从磁盘读取未解码，解码后再放入内存，以此减轻视图渲染时因图片解码所带来的压力)</li>
<li>网络请求返回后</li>
</ul>
</li>
</ul>
</li>
<li><p>线程处理</p>
<ul>
<li>图片缓存框架整体流程中，线程的处理过程如下时序图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/图片框架中线程处理时序流程图.png" alt="图片框架中线程处理时序流程图"></p>
</li>
</ul>
<h3 id="阅读时长统计"><a href="#阅读时长统计" class="headerlink" title="阅读时长统计"></a>阅读时长统计</h3><ul>
<li>时长统计的框架</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/时长统计的框架.png" alt="时长统计的框架"></p>
<p>页面式：push开始、pop结束<br>自定义式：体现在设计框架时，对扩展性的考虑<br>磁盘存储：防止异常情况下(程序杀死、设备断电)记录数据的丢失</p>
<ul>
<li><p>记录器</p>
<ul>
<li>为何有不同的记录器<ul>
<li>基于不同分类场景提供的关于记录的封装、适配</li>
</ul>
</li>
</ul>
</li>
<li><p>如何降低记录数据的丢失率</p>
<ul>
<li>定时写磁盘(如每隔一段时间就做磁盘的写入)</li>
<li>限定内存缓存的条数(如10条)，超过该条数，即写磁盘</li>
</ul>
</li>
<li><p>延时上传的场景</p>
<ul>
<li>从节约客户端流量和提高性能的角度考虑，不是每产生一条记录就上传</li>
<li>采用延时上传的策略来进行批量上传(如，产生一定量(每50条)或过一定时间(每隔10分钟)进行上传)</li>
<li>触发延时上传的场景<ul>
<li>前后台切换</li>
<li>从无网到有网的变化</li>
<li>通用轻量接口捎带</li>
</ul>
</li>
</ul>
</li>
<li><p>上传时机的把控</p>
<ul>
<li>立刻上传</li>
<li>延时上传</li>
<li>定时上传</li>
</ul>
</li>
</ul>
<h3 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h3><p>以微博APP正文页为例</p>
<ul>
<li>整体架构</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/微博整体架构.png" alt="微博整体架构"></p>
<p><img src="/2020/04/21/iOS知识点/微博整体架构视图层.png" alt="微博整体架构视图层"></p>
<p><img src="/2020/04/21/iOS知识点/微博整体架构业务逻辑层.png" alt="微博整体架构业务逻辑层"></p>
<p><img src="/2020/04/21/iOS知识点/微博整体架构数据层.png" alt="微博整体架构数据层"></p>
<ul>
<li>数据流</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/微博整体架构数据流.png" alt="微博整体架构数据流"></p>
<p><img src="/2020/04/21/iOS知识点/微博整体架构数据间关系.png" alt="微博整体架构数据间关系"></p>
<ul>
<li>反向更新</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/微博整体架构反向更新.png" alt="微博整体架构反向更新"></p>
<ul>
<li><p>总结</p>
<ul>
<li>涉及的思想</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/微博整体架构涉及的思想.png" alt="微博整体架构涉及的思想"></p>
<ul>
<li>MVVM结构图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/MVVM结构图.png" alt="MVVM结构图"></p>
<ul>
<li>RN数据流思想</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RN数据流思想.png" alt="RN数据流思想"></p>
<p>任何一个子节点，是没有权利做自己的变化更新的，它必须要把这种变化更新的消息传递给根节点，然后由根节点自顶向下的方式去询问需要更新的节点(从一个主动行为变成一个被动行为)</p>
</li>
</ul>
<h3 id="客户端整体架构"><a href="#客户端整体架构" class="headerlink" title="客户端整体架构"></a>客户端整体架构</h3><ul>
<li>客户端整体架构结构图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/客户端整体架构.png" alt="客户端整体架构"></p>
<p>独立的通用层构成有：时长统计框架、崩溃统计框架、网络第三方框架<br>通用业务层：如控件的封装<br>中间层：用于协调各业务的交互，及处理各业务的解耦</p>
<ul>
<li><p>业务之间的解耦通信方式</p>
<ul>
<li>OpenURL(Router方式)</li>
<li>依赖注入(TOONRouter???)</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/依赖注入.png" alt="依赖注入"></p>
</li>
</ul>
<p>整体架构设计的原则：上层可以依赖下层，下层不可以依赖上层</p>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="字符串反转算法"><a href="#字符串反转算法" class="headerlink" title="字符串反转算法"></a>字符串反转算法</h3><ul>
<li>字符串反转</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/字符串反转.png" alt="字符串反转"></p>
<h3 id="链表反转算法"><a href="#链表反转算法" class="headerlink" title="链表反转算法"></a>链表反转算法</h3><ul>
<li><p>链表反转</p>
<ul>
<li>头插法，关键点是哨兵指针先移动，再执行节点的赋值移除操作</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/链表反转.png" alt="链表反转"></p>
</li>
</ul>
<h3 id="有序数组合并算法"><a href="#有序数组合并算法" class="headerlink" title="有序数组合并算法"></a>有序数组合并算法</h3><p><img src="/2020/04/21/iOS知识点/有序数组合并.png" alt="有序数组合并"></p>
<p><img src="/2020/04/21/iOS知识点/有序数组合并有剩余数组.png" alt="有序数组合并有剩余数组"></p>
<h3 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h3><p>13-4</p>
<ul>
<li>示例：用hash算法实现，找出给定字符串中第一个只出现一次的字符</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/hash算法.png" alt="hash算法"></p>
<h3 id="查找两个子视图的共同父视图算法"><a href="#查找两个子视图的共同父视图算法" class="headerlink" title="查找两个子视图的共同父视图算法"></a>查找两个子视图的共同父视图算法</h3><p>13-5</p>
<h3 id="求无序数组当中的中位数的算法"><a href="#求无序数组当中的中位数的算法" class="headerlink" title="求无序数组当中的中位数的算法"></a>求无序数组当中的中位数的算法</h3><hr>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="AFN"><a href="#AFN" class="headerlink" title="AFN"></a>AFN</h3><p>14-1</p>
<ul>
<li>框架图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/AFN框架图.png" alt="AFN框架图"></p>
<ul>
<li>主要类关系图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/主要类关系图.png" alt="主要类关系图"></p>
<ul>
<li>AFURLSessionManager主要功能<ul>
<li>创建和管理NSURLSession、NSURLSessionTask</li>
<li>实现NSURLSessionDelegate等协议的代理方法</li>
<li>引入AFSecurityPolicy保证请求安全</li>
<li>引入AFNetworkReachabilityManager监控网络状态</li>
</ul>
</li>
</ul>
<h3 id="SDWeb"><a href="#SDWeb" class="headerlink" title="SDWeb"></a>SDWeb</h3><ul>
<li>框架图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/SDWeb架构简图.png" alt="SDWeb架构简图"></p>
<ul>
<li>加载图片的流程</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/SDWeb加载图片流程.png" alt="SDWeb加载图片流程"></p>
<h3 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h3><ul>
<li><p>是函数响应式的编程框架</p>
</li>
<li><p>重要概念</p>
<ul>
<li>信号</li>
<li>订阅(订阅一个信号)</li>
</ul>
</li>
<li><p>信号</p>
<ul>
<li>ReactiveCocoa中的核心类RACSignal</li>
<li>RACSignal结构图</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/RACSignal结构图.png" alt="RACSignal结构图"></p>
<ul>
<li>信号是代表一连串的状态。在状态改变时，对应的订阅者RACSubscriber就会收到通知执行相应的指令</li>
</ul>
</li>
<li><p>订阅</p>
<ul>
<li>订阅信号的工作逻辑</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/订阅信号的工作逻辑.png" alt="订阅信号的工作逻辑"></p>
<ul>
<li>订阅内部原理</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/订阅内部原理.png" alt="订阅内部原理"></p>
</li>
</ul>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><ul>
<li>是一个提升iOS界面渲染性能的一个框架</li>
<li><p>主要用来减轻主线程的压力，能在子线程执行的操作就在子线程中执行</p>
</li>
<li><p>主要处理的问题</p>
</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/ASDK主要处理的问题.png" alt="ASDK主要处理的问题"></p>
<ul>
<li>基本原理</li>
</ul>
<p><img src="/2020/04/21/iOS知识点/ASDK基本原理.png" alt="ASDK基本原理"></p>
<ul>
<li>封装了一个ASNode</li>
<li>针对ASNode的修改和提交，会对其进行封装并提交到一个全局容器当中</li>
<li>ASDK也在RunLoop中注册了一个Observer</li>
<li>当RunLoop进入休眠前，ASDK执行该loop内提交的所有任务</li>
</ul>
<hr>
<h3 id="iOS中使用的多线程"><a href="#iOS中使用的多线程" class="headerlink" title="iOS中使用的多线程"></a>iOS中使用的多线程</h3><h5 id="GCD-1"><a href="#GCD-1" class="headerlink" title="GCD"></a>GCD</h5><ul>
<li>同步/异步、串行/并发<ul>
<li>死锁原因：队列引起的循环等待。例子：viewDidLoad和Block。在主队列(串行队列)中分派viewDidLoad到主线程去执行，viewDidLoad在执行的过程中会调用Block去执行任务，viewDidLoad继续执行的前提条件是Block执行完毕后继续执行viewDidLoad，Block上的任务要想执行，依赖主队列(串行队列)的性质(先进先出FIFO)，此时Block想要执行，依赖viewDidLoad的完成，这种情况下就产生了viewDidLoad和Block的相互等待，造成了队列的循环等待，产生死锁。</li>
<li>主队列当中提交的任务(无论是同步或是异步)，最终都要在主线程中进行处理和执行</li>
<li>同步提交意味着在当前线程执行</li>
<li>任务添加到队列中，分析任务的执行顺序时，要考虑队列的性质，如FIFO</li>
<li>只要是以同步方式去提交任务，无论是提交到并发队列还是串行队列，最终都是在当前线程去执行</li>
<li>全局队列(global_queue)，是并发队列</li>
</ul>
</li>
<li>dispatch_barrier_async，用于解决多读单写，系统层方面的一个解决方案</li>
<li>dispatch_group，</li>
</ul>
<h5 id="NSOperation-1"><a href="#NSOperation-1" class="headerlink" title="NSOperation"></a>NSOperation</h5><p>NSOperation常用于第三方库的对线程编程，如AFNetwork</p>
<h5 id="NSThread-1"><a href="#NSThread-1" class="headerlink" title="NSThread"></a>NSThread</h5><p>实现常驻线程的时候，会用到NSThread</p>
<hr>
<p>线程同步，资源共享，会涉及到多线程与锁</p>
<h5 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h5><p>KVO：isa 混写技术的实现<br>MVVM + RAC<br>RN</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/组件化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/14/组件化/" class="post-title-link" itemprop="url">组件化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-14 10:43:49" itemprop="dateCreated datePublished" datetime="2020-04-14T10:43:49+08:00">2020-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="组件化使用的背景"><a href="#组件化使用的背景" class="headerlink" title="组件化使用的背景"></a>组件化使用的背景</h3><p>组件化方案的出现，是为解决项目随着业务的不断发展，模块间的代码耦合越来越多，代码量急剧增加带来项目不易维护的问题。组件化方案，有利于项目工程的管理，解决了不同业务模块间的代码耦合。项目经过组件化的拆分，不仅可以解决代码耦合的问题，还可以增强代码的复用。</p>
<p>组件化的基础原型：路由(<code>Router</code>)就像是个调度中心，各个模块通过路由调度其他模块，模块之间不需要相互引用，调度方式更加统一、自由，能够实现解耦的作用。</p>
<h3 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h3><ul>
<li>从颗粒度大小角度来看(颗粒度从小到大)<ol>
<li>一个符合单一职责原则的类是一个组件(单一职责原则，即不同的类具备不同的职责，各司其职)</li>
<li>为了完成某个独立功能的几个类可称为一个组件。如<code>NSArray</code>类簇</li>
<li>一个框架亦可称为一个组件。如<code>Foundation</code>等，通常意义上称为<code>framework</code>或<code>library</code></li>
<li>一个完整独立的<code>App</code>亦可称之为一个组件</li>
</ol>
</li>
</ul>
<p>组件化的讨论分为功能组件、业务组件。组件化的核心是组件间的通信，即组件化讨论要考虑到组件间的通信。</p>
<p>上述<code>1</code>、<code>2</code>、<code>3</code>种颗粒度大小的组件间的通信，有通过构造传值、属性传值、<code>Block</code>闭包传值、协议回调传值以及单例传值。第<code>4</code>种颗粒度大小的组件间的通信，通过统一资源定位符，即<code>URL</code>路由来实现。每种颗粒度大小的组件最终都可以抽象为第一种颗粒度级别的情况，因为再多的类都得保证最后使用的时候要尽可能简单，即符合<strong>迪米特法则</strong>。迪米特法则特点是，低耦合、高内聚。</p>
<h3 id="什么是耦合性"><a href="#什么是耦合性" class="headerlink" title="什么是耦合性"></a>什么是耦合性</h3><p>耦合性，有紧耦合性、松耦合性和无耦合性之分。紧耦合性，是在一个类里面实例化了另外一个实例；松耦合性，践行开闭原则和里氏替换原则，通过构造器或者属性传值解耦；无耦合性，通过协议来实现，通过协议来实现解耦的方式是大部分语言都有的功能。</p>
<p>开闭原则：类、模块、函数可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。即对软件实体的改动，最好用扩展而非修改的方式。</p>
<p>里氏替换原则：一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。即子类可以扩展父类的方法，但不应该复写父类的方法。</p>
<p><strong>解决组件间通信的问题，就是解决传值和耦合的问题</strong></p>
<h3 id="组件化实现过程的讨论"><a href="#组件化实现过程的讨论" class="headerlink" title="组件化实现过程的讨论"></a>组件化实现过程的讨论</h3><ul>
<li><p><code>App</code>之间的通信是怎么做的</p>
<ul>
<li><code>App</code>之间的通信是通过<code>openURL</code>的方式，<code>url</code>其实就相当于一个协议，当一个应用指定了<code>URL Schemes</code>，系统就会实现这个<code>url</code>和这个<code>App</code>之间的绑定。当<code>openURL</code>的时候，系统就会调用这个<code>url</code>的实现，找到对应的<code>App</code>打开，并调用这个<code>App</code>的<code>delegate</code>方法。</li>
<li>同理，在我们的<code>App</code>中，可以把业务组件等价于<code>App</code>，那么组件间的通信一样可以等价于<code>URL</code>路由方式，这种方式现在有所对应的实践，如<code>URLNavigator</code>、蘑菇街路由等。<code>URL</code>思路在同一个<code>App</code>中实现时，在代码层面上是不够直接的，性能上也不够好（因要进行额外解析或者内存常驻），此时就得通过设计模式来解决这个问题。</li>
</ul>
</li>
<li><p><code>A</code>、<code>B</code>组件间跳转传值</p>
<ul>
<li>如在<code>A</code>组件的某个页面上点击一个按钮要进入到<code>B</code>组件的某个页面。从组件间需解耦的理论来看，当点击按钮后<code>A</code>组件不应该知道下一个组件是哪一个及怎样跳转到下一个组件。</li>
<li>针对上面的场景，<code>CTMediator</code>的做法是通过<code>category</code>来实现，代码如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  // A组件中</span><br><span class="line">#pragma mark - event response</span><br><span class="line">- (void)didTappedPushBViewControllerButton:(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line">    UIViewController *viewController = [[CTMediator sharedInstance] B_viewControllerWithContentText:@&quot;hello, world!&quot;];</span><br><span class="line">    [self.navigationController pushViewController:viewController animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <code>CTMediator</code>的这种实现方式，也造成了其作者所说的<strong>命名域问题</strong>，同时<code>category</code>这个<code>repo</code>是由<code>B</code>组件维护的，那很显然<code>A</code>组件侧要完成这个功能必须等待<code>B</code>组件侧完成，一个开发阶段的人员不应该互相等待，<code>A</code>组件侧只需要负责给中介者发个消息就行了，其他的不需要管。为了解耦与同步工作，<code>A</code>组件侧应该依赖于自己的抽象，即定义一个协议，代码如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  @protocol AViewControllerMediating </span><br><span class="line">-(void)avc:(UIViewController *)vc didTappedPushBVCButtonWithContentText:(NSString *)text;</span><br><span class="line">@end</span><br><span class="line">#pragma mark - event response</span><br><span class="line">- (void)didTappedPushBViewControllerButton:(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line">    [self.mediator avc:self didTappedPushBVCButtonWithContentText:@&quot;hello, world!&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样<code>A</code>组件侧这边根本不需要等待<code>B</code>组件侧开发完成，自己完全可以写个单元测试的<code>mock</code>类来测试自己有没有正确的发送消息，<code>A</code>组件侧做到这一步就可以了。当<code>B</code>组件侧开发完后，只需要把跳转的逻辑实现搬到<strong>中介者</strong>的<code>AViewControllerMediating</code>协议实现处即可。</p>
<p>  上述通过<code>AViewControllerMediating</code>协议处理的流程，好处就是，当不再需要跳转到<code>B</code>组件或<code>B</code>组件被砍掉时，如跳到<code>C</code>组件，只需要<code>C</code>组件侧重写实现跳转逻辑即可，即只需要修改一处地方即可，不会影响到<code>A</code>组件侧的修改。相比于上述添加协议的处理方式，<code>CTMediator</code>的做法很显然要涉及到相关两个组件的改动。<strong>改动的地方越少，维护性越高。</strong>这才是真正的解耦做法，而不是把可编译的类名变成字符串，进行所谓的运行时解耦。</p>
<p><code>push</code>、<code>present</code>、<code>dismiss</code>、<code>pop</code>这些其实才是真正的路由逻辑，这些代码应该出现在一个地方即<strong>中介者</strong>。一旦跳转逻辑需要改动或修改<code>bug</code>，只需要去中介者里面找就行。涉及到组件化的项目视图控制器肯定不少，而中介者一般不会有很多。</p>
<ul>
<li>组件化中主工程的理解</li>
</ul>
<p>抽象层面上可以把主工程看成是<code>MVC</code>中的<code>Controller</code>，基于<code>MVC</code>再怎么拆成<code>MVVM</code>或<code>VIPER</code>，<code>Controller</code>中协调<code>Model</code>和<code>View</code>的工作还在，<code>M</code>和<code>V</code>不就是组件的最细颗粒度级别(上述组件描述<code>1</code>的情况)吗？那么主工程就是一个天然调度各个组件的地方，调度不同业务组件的代码就应该放到主工程。</p>
<p>主工程是一个集成各个组件的地方，而中介者是调度各个组件的，中介者放到主工程里面一点问题都没有。同时注意，显式依赖显然比隐式依赖要更健壮。</p>
<p>小结：在<code>iOS</code>领域里，一定是组件化的中间件为<code>openURL</code>提供服务，而不是<code>openURL</code>方式为组件化提供服务。如果在给<code>App</code>实施组件化方案的过程中是基于<code>openURL</code>方案的话，有一个致命的缺陷，非常规对象(不能被字符串化到<code>URL</code>中的对象，如<code>UIImage</code>)无法参与本地组件间的调度。</p>
<h3 id="现有组件化的实现方案"><a href="#现有组件化的实现方案" class="headerlink" title="现有组件化的实现方案"></a>现有组件化的实现方案</h3><h4 id="蘑菇街"><a href="#蘑菇街" class="headerlink" title="蘑菇街"></a>蘑菇街</h4><h5 id="url-block方案"><a href="#url-block方案" class="headerlink" title="url-block方案"></a><code>url-block</code>方案</h5><p>通过在启动时注册组件提供的服务，把调用组件使用的<code>url</code>和组件提供的服务<code>block</code>对应起来，保存到内存中。在使用组件的服务时，通过<code>url</code>找到对应的<code>block</code>，然后获取服务。</p>
<p><code>url-block</code>方案的架构图</p>
<p><img src="/2020/04/14/组件化/url_block方案的架构图.png" alt="url_block方案的架构图"></p>
<p><code>MGJRouter</code>就是一个单例类，使用前需要通过注册组件，调用方通过<code>URL</code>调用服务方页面，通过路由表的映射关系进行关联，调用方可以传入复杂的参数、对象等。<code>MGJRouter</code>中使用<code>block</code>实现正反向传值。</p>
<p>基本跳转的步骤：先注册组件，然后调用<code>openURL</code>方法，传入参数即可。</p>
<p>实际使用中，使用一个类来统一管理注册方法，在<code>load</code>方法中进行注册，这样就不会到处看到注册的代码，方便管理。</p>
<p><a href="https://github.com/meili/MGJRouter" target="_blank" rel="noopener"><code>url-block</code>的示例代码</a></p>
<ul>
<li><code>url-block</code>方案的优缺点<ul>
<li>优点<ul>
<li>可以使用定义好的路由实现页面间的跳转</li>
</ul>
</li>
<li>缺点<ul>
<li>需要在内存中维护<code>url-block</code>的表，组件多了可能会有内存问题</li>
<li><code>url</code>注册对于实施组件化没必要，查找<code>url</code>的实现不够高效</li>
<li>路由写错后编译没问题，而运行实现就出问题了，以后维护也不方便</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="protocol-class"><a href="#protocol-class" class="headerlink" title="protocol-class"></a><code>protocol-class</code></h5><p>这种方案，是通过<code>protocol</code>定义服务接口，组件通过实现该接口来提供接口定义的服务。具体实现就是把<code>protocol</code>和<code>class</code>做一个映射，同时在内存中保存一张映射表，使用的时候通过<code>protocol</code>找到对应的<code>class</code>来获取需要的服务。</p>
<p><code>protocol-class</code>方案注册：在模块的协议实现类中的<code>load</code>方法里进行注册。</p>
<p><code>protocol-class</code>方案的架构图</p>
<p><img src="/2020/04/14/组件化/protocol_class方案的架构图.png" alt="protocol_class方案的架构图"></p>
<p>协议和类的一一对应关系中，类是实现了对应的协议的，所以通过协议获取到的类是可以按照<code>protocol</code>中声明的方法自由使用的。</p>
<p><a href="https://github.com/zhfei/Engineer" target="_blank" rel="noopener"><code>protocol-class</code>的实例代码</a></p>
<p>蘑菇街的<code>url-block</code>和<code>protocol-class</code>方案，都是通过单例模式对组件进行管理的。</p>
<h4 id="有赞"><a href="#有赞" class="headerlink" title="有赞"></a>有赞</h4><h4 id="CTMediator"><a href="#CTMediator" class="headerlink" title="CTMediator"></a><code>CTMediator</code></h4><ul>
<li>设计模式：中介(<code>Mediator</code>)模式 + <code>Target-Action</code>模式</li>
<li>流程简述：<code>[CTMediator shareInstance]</code> &gt; <code>openUrl</code> &gt; <code>parseUrl</code> &gt; <code>performTarget:action:params</code> &gt; <code>RunTime</code> &gt; 分配到各个业务(<code>target</code>)下的各个业务逻辑(<code>action</code>)</li>
<li>调用：分为远程调用和本地调用，通过本地调用来支持远程调用</li>
<li>参数：对于非常规参数，如<code>UIImage/UIView</code>等，<code>openUrl</code>方式是没办法直接传递的，调用本地的<code>performTarget</code>方法，可直接通过<code>params</code>传递非常规参数</li>
<li>与其他组件化方案的区别：蘑菇街所有的组件化调用是建立在<code>URL</code>上的，这是<code>CTMediator</code>与蘑菇街最大的不同</li>
<li><code>CTMediator</code>组件化方案架构图</li>
</ul>
<p><img src="/2020/04/14/组件化/CTMediator组件化方案架构图.png" alt="CTMediator组件化方案架构图"></p>
<p><code>CTMediator</code>主要用到的是<code>RunTime</code>中的让对象发送消息。<code>performSelector</code>本质上就是会转化成<code>objc_msgSend</code>来进行实现。</p>
<p><code>CTMediator</code>中最关键的方法<code>- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</code>。其内部实现使用了运行时相关的<code>NSSelectorFromString</code>、<code>NSClassFromString</code>、<code>SEL</code>等方法。</p>
<p><code>CTMediator</code>中主要代码的理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[target performSelector:action withObject:params];</span><br><span class="line"></span><br><span class="line">action(SEL)通过NSSelectorFromString获取了，target通过NSClassFromString获取，接下来只需要通过performSelector方法执行target(Class)中的action即可。</span><br></pre></td></tr></table></figure>
<p>Tips：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RunTime的使用场景：让一个对象发送消息(即是执行方法)、交换方法(Method Swizzling)、动态添加方法、给分类增加属性、字典转模型等。</span><br></pre></td></tr></table></figure>
<ul>
<li>总结<ul>
<li><code>CTMediator</code>的实现得益于<code>RunTime</code>的存在，正因为如此我们可以解耦各个模块，实现<code>App</code>之间的模块化。</li>
</ul>
</li>
</ul>
<h3 id="现有组件化方案的缺陷"><a href="#现有组件化方案的缺陷" class="headerlink" title="现有组件化方案的缺陷"></a>现有组件化方案的缺陷</h3><ul>
<li><code>CTMediator</code></li>
</ul>
<p>不要滥用单例，因为除了单例共享状态之外，还容易造成紧耦合性，就算要用也要通过依赖注入(即通过传入的参数进行初始化)的方式，这样也能增加可测试性。而<code>CTMediator</code>的使用很显然造成了单例的紧耦合。</p>
<p><code>CTMediator</code>采用硬编码的方式，依赖于<code>OC</code>运行时，通用型也不高。按照作者的说法，<code>category</code>这个<code>repo</code>是服务方维护的，然后调用方要依赖于这个<code>category</code>，这同样是依赖于服务方，只不过原来可能要直接依赖<code>B</code>组件，现在分一个<code>B_category</code>组件然后依赖它，作者所谓的命名域一样渗透，依赖列表里同样出现了服务方的名字。</p>
<ul>
<li><code>protocol-class</code>注册</li>
</ul>
<p>蘑菇街和<code>Beehive</code>用到了这种方式。这个方式虽然用到了协议，但跟上面使用的<code>AViewControllerMediating</code>协议完全是两个意思。<code>protocol-class</code>注册中协议的这个意思，<code>A</code>组件调用<code>B</code>组件，然后<code>B</code>组件提供一个协议出来自己再实现，这个协议放<code>B</code>组件里又怕依赖侵入，然后就放到<code>PublicProtocolDomain.h</code>里面并下沉，再在<code>A</code>组件里通过<code>ModuleManager</code>取出来。这就是觉得这个方案很绕的原因。</p>
<p><code>B</code>组件要对外提供服务，提供一个外观类就够了。协议是由<code>A</code>组件定义的，然后由中介者去实现，因为中介者本身就是要依赖各个组件的，自然而然的就能实现<code>A</code>组件中的协议调用<code>B</code>组件中的方法了。</p>
<h3 id="组件化的Coordinator方案"><a href="#组件化的Coordinator方案" class="headerlink" title="组件化的Coordinator方案"></a>组件化的<code>Coordinator</code>方案</h3><p>根据上述的讨论理解，实现解耦，不需要再搞一个<code>category repo</code>，而所谓的<code>Target</code>其实相当于一个组件模块的外观类，提供一组较易用的方法，可称为<code>Service</code>或<code>Coordinator</code>。这个方案运用了真正的<code>POP</code>(面向过程编程，注重细节、功能)思想，把它用在组件化里完全合适，并且无需所谓的注册、无需运行时，内存占用少、运行速度快，有编译期检查，可<code>Mock</code>测试，无单例，和<code>URL</code>路由也能配合。</p>
<p><code>Coordinator</code>方案的模型图如下</p>
<p><img src="/2020/04/14/组件化/Coordinator方案的App宏观层面.jpg" alt="Coordinator方案的App宏观层面"></p>
<p><img src="/2020/04/14/组件化/Coordinator方案的模块微观层面.jpg" alt="Coordinator方案的模块微观层面"></p>
<p><a href="https://github.com/Bruce-pac/MainProject-MultiPod" target="_blank" rel="noopener"><code>Coordinator</code>方案的代码</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>组件化的目的是为了让代码复用性更强，并不是要把主工程架空，只要你遵守<code>SOLID</code>原则灵活运用设计模式，并且分好文件夹，就算你在一个工程中一样可以称之为组件化，做成<code>Pod</code>或者<code>Package</code>是画龙点睛的做法，拆分过头甚至适得其反。如果团队人不多，业务模块不多，完全没必要把业务进行<code>Pod</code>级别的隔离，做到基础组件的隔离就够了。</p>
<h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><p><a href="https://juejin.im/post/5e8d8ec5e51d4546dd2155c6#heading-4" target="_blank" rel="noopener">组件化的一个新想法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/02/iOS多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/02/iOS多线程/" class="post-title-link" itemprop="url">iOS多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-02 10:41:41" itemprop="dateCreated datePublished" datetime="2020-04-02T10:41:41+08:00">2020-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><h4 id="多线程是什么"><a href="#多线程是什么" class="headerlink" title="多线程是什么"></a>多线程是什么</h4><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h4><p><strong>线程</strong>和<strong>进程</strong>的区别主要在于它们是不同的<strong>操作系统资源管理方式</strong>。</p>
<p>进程有独立的地址空间，一个进程崩溃后，在保护模式的控制下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等同于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费的资源较大，效率要差一些。</p>
<p>对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>线程是<code>CPU</code>独立运行和独立调度的基本单位（一个进程中执行的代码片段）。<br>进程是资源分配的基本单位（进程是一块包含了某些资源的内存区域）。</p>
<p>进程和线程都是由操作系统所<strong>感知</strong>的程序运行的基本单元，系统利用该基本单元实现<strong>系统</strong>对<strong>应用</strong>的并发性。进程是线程的容器，真正完成代码执行的是线程，而进程则作为线程的执行环境。一个程序(应用)至少包含一个进程，一个进程至少包含一个线程，一个进程中的所有线程共享当前进程所拥有的资源。</p>
<h4 id="多线程有什么用"><a href="#多线程有什么用" class="headerlink" title="多线程有什么用"></a>多线程有什么用</h4><h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><p>异步和同步是相对的，<strong>同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行</strong>。<strong>异步就是彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作</strong>。</p>
<p>线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。</p>
<p>异步和多线程并不是一个等同的关系，异步是最终的目的，多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者，而调用者不用等待其结果的返回而可以做其它的事情。</p>
<p>实现<strong>异步</strong>可以<strong>采用多线程技术</strong>或<strong>交给另外的进程来处理</strong>。</p>
<h4 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发/并行"></a>并发/并行</h4><p>并发性和并行性的区别，用馒头做比喻，前者相当于一个人同时吃三个馒头，后者相当于三个人同时吃一个馒头。</p>
<p>并发性(<code>Concurrence</code>)：指两个或两个以上事件或活动在<strong>同一时间间隔</strong>内发生。并发的实质是一个物理<code>CPU</code>在若干道程序之间多路复用，并发性是对有限的物理资源强制行使多用户共享以提高效率。</p>
<p>并行性(<code>Parallelism</code>)：指两个或两个以上事件或活动在<strong>同一时刻</strong>发生。在多道程序环境下，并行性使多个程序同一时刻可在不同<code>CPU</code>上同时执行，在多核<code>CPU</code>的环境下，可提高<code>CPU</code>的利用率。</p>
<p>一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。前者是逻辑上的同时发生，后者是物理上的同时发生。</p>
<p>并行和并发的联系：并行的事件或活动一定是并发的，但反之并发的事件或活动未必是并行的。并行性是并发性的特例，而并发性是并行性的扩展。</p>
<h4 id="串行-并行"><a href="#串行-并行" class="headerlink" title="串行/并行"></a>串行/并行</h4><h3 id="iOS开发中几种多线程方案"><a href="#iOS开发中几种多线程方案" class="headerlink" title="iOS开发中几种多线程方案"></a><code>iOS</code>开发中几种多线程方案</h3><p>在<code>iOS</code>中目前有<code>4</code>套多线程方案，分别是<code>Pthreads</code>、<code>NSThread</code>、<code>GCD</code>、<code>NSOperation &amp; NSOperationQueue</code>。</p>
<p>多线程周边产品，如线程同步、延时执行、单例模式</p>
<h4 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a><code>Pthreads</code></h4><ul>
<li><p>概念</p>
<ul>
<li><code>POSIX</code>线程(<code>POSIX threads</code>)，简称<code>Pthreads</code>，是线程的<code>POSIX</code>标准。该标准定义了创建和操作线程的一整套<code>API</code>。在类<code>Unix</code>操作系统(<code>Unix</code>、<code>Linux</code>、<code>Mac OS X</code>等)中，都使用<code>Pthreads</code>作为操作系统的线程。</li>
<li>即这是一套在很多操作系统上都通用的多线程<code>API</code>，有较强的移植性，因此在<code>iOS</code>中也是可以的。</li>
<li>这是基于<code>C</code>语言的框架</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>使用过程中需要<code>C</code>语言函数，需要程序员手动管理线程的生命周期(即处理线程的各个状态的转换)</li>
<li><code>iOS</code>开发中几乎不可能用到</li>
</ul>
</li>
</ul>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a><code>NSThread</code></h4><p>这套方案是经过苹果封装后的，并且完全面向对象的。所以可以直接操控线程对象，非常直观和方便。但是，它的生命周期需要程序员手动管理，因此这套方案也是偶尔用，如<code>[NSThread currentThread]</code>获取当前线程类，以知道当前线程的各种属性，用于调试十分方便。</p>
<ul>
<li><p>使用</p>
<ul>
<li>创建并启动<ol>
<li>先创建线程类，再启动<ul>
<li><code>OC方法</code> - <code>//创建 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil]; //启动 [thread start];</code></li>
<li><code>Swift方法</code> - <code>//创建 let thread = NSThread(target: self, selector: &quot;run:&quot;, object: nil) //启动 thread.start()</code></li>
</ul>
</li>
<li>创建并自动启动<ul>
<li><code>OC方法</code> - <code>[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];</code></li>
<li><code>Swift方法</code> - <code>NSThread.detachNewThreadSelector(&quot;run:&quot;, toTarget: self, withObject: nil)</code></li>
</ul>
</li>
<li>使用<code>NSObject</code>的方法创建并自动启动<ul>
<li><code>OC方法</code> - <code>[self performSelectorInBackground:@selector(run:) withObject:nil];</code></li>
<li><code>Swift方法</code> - 因苹果认为<code>performSelector:</code>不安全，所以在<code>Swift</code>去掉了这个方法</li>
</ul>
</li>
</ol>
</li>
<li>其他方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//取消线程</span><br><span class="line">- (void)cancel;</span><br><span class="line">//启动线程</span><br><span class="line">- (void)start;</span><br><span class="line">//判断某个线程的状态的属性</span><br><span class="line">@property (readonly, getter=isExecuting) BOOL executing;</span><br><span class="line">@property (readonly, getter=isFinished) BOOL finished;</span><br><span class="line">@property (readonly, getter=isCancelled) BOOL cancelled;</span><br><span class="line">//设置和获取线程名字</span><br><span class="line">-(void)setName:(NSString *)n;</span><br><span class="line">-(NSString *)name;</span><br><span class="line">//获取当前线程信息</span><br><span class="line">+ (NSThread *)currentThread;</span><br><span class="line">//获取主线程信息</span><br><span class="line">+ (NSThread *)mainThread;</span><br><span class="line">//使当前线程暂停一段时间，或者暂停到某个时刻</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)time;</span><br><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <code>NSThread</code>只有在一些非常简单的场景才会使用，因它还不够智能，如不能自动管理线程的生命周期；不能简便地处理多线程中的其他高级概念，如线程组、栅栏。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a><code>GCD</code></h4><p><code>GCD</code>全称是<code>Grand Central Dispatch</code>，它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的<code>CPU</code>内核(比如双核、四核)，最重要的是它会自动管理线程的生命周期(创建线程、调度线程、销毁线程)，完全不需要程序员手动管理，只需要告诉它干什么就行。它使用的也是<code>C</code>语言，由于使用了<code>Block</code>，使得使用起来更加方便、灵活。</p>
<h5 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h5><p>在<code>GCD</code>中，加入了两个重要的概念，<strong>任务</strong>和<strong>队列</strong>。</p>
<ul>
<li><p>任务，即操作，想要干什么，是一段处理代码，在<code>GCD</code>中就是一个<code>Block</code>，所以添加任务十分方便</p>
<ul>
<li>任务有两种执行方式，<strong>同步执行(<code>sync</code>)</strong>和<strong>异步执行(<code>async</code>)</strong>，他们之间的区别可以从<strong>是否会有线程阻塞</strong>和<strong>是否会新开线程</strong>来理解<ul>
<li><strong>会不会阻塞当前线程，直到<code>Block</code>中的任务执行完毕</strong><ul>
<li>同步执行，它会阻塞当前线程并等待<code>Block</code>中的任务执行完毕，然后当前线程才会继续往下执行</li>
<li>异步执行，当前线程会直接往下执行，它不会阻塞当前线程</li>
</ul>
</li>
<li><strong>是否会创建新的线程</strong><ul>
<li>同步执行，只要是同步执行的任务，都会在当前线程执行，不会另开线程</li>
<li>异步执行，只要是异步执行的任务，都会另开线程，在别的线程执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>队列，用于存放任务。有两种队列，<strong>串行队列</strong>和<strong>并行队列</strong></p>
<ul>
<li>串行队列，放到串行队列的任务，<code>GCD</code>会<code>FIFO</code>(先进先出)地取出一个，执行一个，然后取下一个，这样一个一个的执行</li>
<li>并行队列，放到并行队列中的任务，<code>GCD</code>也会<code>FIFO</code>的取出来，不同的是，它取出来一个任务就会放到别的线程，然后再取出一个任务又放到另一个线程。这样由于取的动作很快，看起来，所有的任务都是一起执行的。需要注意，<code>GCD</code>会根据系统资源控制并行的数量，所以如果任务很多，<code>GCD</code>并不会让所有任务同时执行。</li>
</ul>
</li>
</ul>
<p>任务在同步和异步，及在串行和并行队列的环境下的执行情况如下表</p>
<table>
<thead>
<tr>
<th></th>
<th>同步执行</th>
<th>异步执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>串行队列</td>
<td>在当前线程，任务一个一个执行</td>
<td>在其他线程，任务一个一个执行</td>
</tr>
<tr>
<td>并行队列</td>
<td>在当前线程，任务一个一个执行</td>
<td><code>GCD</code>会开很多线程，任务会被分配到已创建的线程中，一起执行</td>
</tr>
</tbody>
</table>
<h5 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h5><ul>
<li>主队列：这是一个特殊的串行队列。主队列用于刷新<code>UI</code>，任何需要刷新<code>UI</code>的工作都要在主队列(对应主线程)中执行，所以一般耗时的任务都要放到别的线程执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">获取主队列的代码：</span><br><span class="line"></span><br><span class="line">//OBJECTIVE-C</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"> </span><br><span class="line">//SWIFT</span><br><span class="line">let queue = dispatch_get_main_queue()</span><br></pre></td></tr></table></figure>
<ul>
<li>自己创建的队列：可以创建串行队列，也可以创建并行队列。创建队列的函数，第一个参数，用于<code>DEBUG</code>标识，可以为空；第二个参数用来表示创建的队列是串行的还是并行的，传入<code>DISPATCH_QUEUE_SERIAL</code>或<code>NULL</code>表示创建的是串行队列，传入<code>DISPATCH_QUEUE_CONCURRENT</code>表示创建的是并行队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自己创建队列的代码：(创建串行队列为例)</span><br><span class="line"></span><br><span class="line">//OBJECTIVE-C</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">//SWIFT</span><br><span class="line">let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, nil)</span><br></pre></td></tr></table></figure>
<ul>
<li>全局并行队列：<code>GCD</code>维护的唯一一个并行队列，只要是并行任务一般都加入到这个队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">获取全局并行队列的代码：</span><br><span class="line"></span><br><span class="line">//OBJECTIVE-C</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">//SWIFT</span><br><span class="line">let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br></pre></td></tr></table></figure>
<h5 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h5><ul>
<li>同步任务(<code>SYNC</code>)：不会另开线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建代码：</span><br><span class="line"></span><br><span class="line">//OC</span><br><span class="line">dispatch_sync(, ^&#123;</span><br><span class="line">  //code here</span><br><span class="line">  NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line">dispatch_sync(, &#123; () -&gt; Void in</span><br><span class="line">  //code here</span><br><span class="line">  println(NSThread.currentThread())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>异步任务(<code>ASYNC</code>)：会另开线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建代码：</span><br><span class="line"></span><br><span class="line">//OC</span><br><span class="line">dispatch_async(, ^&#123;</span><br><span class="line">  //code here</span><br><span class="line">  NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line">dispatch_async(, &#123; () -&gt; Void in</span><br><span class="line">  //code here</span><br><span class="line">  println(NSThread.currentThread())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>示例解析</p>
<ul>
<li>示例一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  以下代码在主线程调用，结果是什么？</span><br><span class="line">  </span><br><span class="line">  NSLog(&quot;AAA - %@&quot;, NSThread.currentThread())</span><br><span class="line">dispatch_sync(dispatch_get_main_queue(), &#123; () -&gt; Void in </span><br><span class="line">        NSLog(&quot;sync - %@&quot;, NSThread.currentThread())</span><br><span class="line">&#125;)</span><br><span class="line">NSLog(&quot;BBB - %@&quot;, NSThread.currentThread())</span><br><span class="line">答案：只会打印第一句：AAA，然后主线程就卡住了，此时如果界面上有按钮，会发现按钮点击不了</span><br><span class="line">解析：同步任务会阻塞当前线程，然后把Block中的任务放到指定的队列中执行，只有等到Block中的任务完</span><br><span class="line">成后才会让当前线程继续往下执行。上面代码的执行步骤是：打印完第一句后，`dispatch_sync`立即阻塞</span><br><span class="line">当前的主线程，然后把Block中的任务放到`main_queue`中。`main_queue`中的任务会被取出来放到主</span><br><span class="line">线程中执行。但主线程这时已经被阻塞了，所以Block中的任务就不能完成，Block中的任务不完成，</span><br><span class="line">`dispatch_sync`就会一直阻塞主线程，产生了死锁现象，最终导致主线程一直卡死。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>示例二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">以下代码会产生什么结果？</span><br><span class="line"></span><br><span class="line">let queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL)</span><br><span class="line"> NSLog(&quot;AAA - %@&quot;, NSThread.currentThread())</span><br><span class="line">  dispatch_async(queue, &#123; () -&gt; Void in</span><br><span class="line">      NSLog(&quot;syncBBB - %@&quot;, NSThread.currentThread())</span><br><span class="line">      dispatch_sync(queue, &#123; () -&gt; Void in</span><br><span class="line">           NSLog(&quot;sync - %@&quot;, NSThread.currentThread())</span><br><span class="line">      &#125;)</span><br><span class="line">      NSLog(&quot;syncCCC - %@&quot;, NSThread.currentThread())</span><br><span class="line"> &#125;)</span><br><span class="line">NSLog(&quot;DDD - %@&quot;, NSThread.currentThread())</span><br><span class="line">答案：AAA - 、syncBBB -、DDD -打印出来了，sync -、syncCCC -没有打印出来</span><br><span class="line">解析：</span><br><span class="line">1、使用DISPATCH_QUEUE_SERIAL这个参数，创建了一个串行队列</span><br><span class="line">2、打印AAA -这句</span><br><span class="line">3、dispatch_async异步执行，所以当前线程不会被阻塞，这种情况下有了两条线程，一条当前线程继续</span><br><span class="line">往下执行，打印出DDD -这句，另一条线程执行Block中的内容，打印syncBBB -这句。因为这两条线程</span><br><span class="line">是并行的，所以打印的先后顺序无所谓。</span><br><span class="line">4、重点！dispatch_sync同步执行，于是它所在的线程会被阻塞，一直等到sync里的任务执行完才会继</span><br><span class="line">续往下执行。sync把自己Block中的任务放到queue中，queue是一个串行队列，一次执行一个任务，所</span><br><span class="line">以sync的Block必须等到前一个任务执行完毕，但此时queue正在执行的任务就是被sync阻塞了的那个，</span><br><span class="line">于是发生了死锁，所以sync所在的线程被卡死了，因此剩下的两句log不会被执行自然就不会被打印了。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h5><p>队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，队列组会通过一个方法通知我们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">队列组使用的代码：</span><br><span class="line"></span><br><span class="line">//OC</span><br><span class="line">//1.创建队列组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">//2.创建队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">//3.多次使用队列组的方法执行任务, 只有异步方法</span><br><span class="line">//3.1.执行3次循环</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    for (NSInteger i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        NSLog(@&quot;group-01 - %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//3.2.主队列执行8次循环</span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    for (NSInteger i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        NSLog(@&quot;group-02 - %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//3.3.执行5次循环</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    for (NSInteger i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;group-03 - %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//4.都完成后会自动通知</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;完成 - %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-barrier-的使用"><a href="#dispatch-barrier-的使用" class="headerlink" title="dispatch_barrier_的使用"></a><code>dispatch_barrier_</code>的使用</h5><ul>
<li><p><code>func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t);</code></p>
<ul>
<li>这个方法重点是传入的<code>queue</code>，当传入的<code>queue</code>是通过<code>DISPATCH_QUEUE_CONCURRENT</code>参数自己创建的<code>queue</code>时，<code>dispatch_barrier_async</code>这个方法会阻塞这个<code>queue</code>(是阻塞传入的自定义创建的<code>queue</code>，而不是阻塞当前线程)，一直等到这个<code>queue</code>中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，才会取消阻塞，使这个<code>queue</code>中排在它后面的任务继续执行</li>
<li>如果传入的不是自定义创建的<code>queue</code>，那么它就和<code>dispatch_async</code>的功能一样了</li>
</ul>
</li>
<li><p><code>func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t);</code></p>
<ul>
<li>这个方法重点也是传入的<code>queue</code>,当传入的<code>queue</code>是通过<code>DISPATCH_QUEUE_CONCURRENT</code>参数自己创建的<code>queue</code>时，<code>dispatch_barrier_sync</code>这个方法会阻塞这个<code>queue</code>，同时还会阻塞当前线程，一直等到这个<code>queue</code>中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，才会取消阻塞，使这个<code>queue</code>中排在它后面的任务继续执行</li>
<li>如果传入的不是自定义创建的<code>queue</code>，那么它就和<code>dispatch_sync</code>的功能一样了</li>
</ul>
</li>
</ul>
<h5 id="DispatchSemaphone信号量"><a href="#DispatchSemaphone信号量" class="headerlink" title="DispatchSemaphone信号量"></a><code>DispatchSemaphone</code>信号量</h5><p>使用信号量可以很好的实现多线程同步的问题。</p>
<h4 id="NSOperation和NSOperationQueue"><a href="#NSOperation和NSOperationQueue" class="headerlink" title="NSOperation和NSOperationQueue"></a><code>NSOperation</code>和<code>NSOperationQueue</code></h4><p><code>NSOperation</code>是苹果公司对<code>GCD</code>的封装，完全面向对象。<code>NSOperation</code>和<code>NSOperationQueue</code>分别对应<code>GCD</code>中的<strong>任务</strong>和<strong>队列</strong>。</p>
<ol>
<li>将要执行的任务封装到一个<code>NSOperation</code>对象中</li>
<li>将此任务添加到一个<code>NSOperationQueue</code>对象中</li>
</ol>
<p>执行完上述操作后，系统会自动执行任务。具体执行过程，见下面内容：</p>
<h5 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h5><p><code>NSOperation</code>只是一个抽象类，所以不能封装任务，它有2个子类用于封装任务，分别是<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>。创建一个<code>Operation</code>后，需要调用<code>start</code>方法来启动任务，它会默认在<strong>当前队列同步</strong>执行；也可以在中途取消一个任务，只需要调用其<code>cancel</code>方法即可。</p>
<ul>
<li><p><code>NSInvocationOperation</code></p>
<ul>
<li>需要传入一个方法名</li>
<li>创建代码如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//OC</span><br><span class="line"> //1.创建NSInvocationOperation对象</span><br><span class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line"></span><br><span class="line">//2.开始执行</span><br><span class="line">[operation start];</span><br><span class="line"></span><br><span class="line">因NSInvocationOperation不是类型安全的，所以Swift中没有对应的创建方法</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>NSBlockOperation</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//OC</span><br><span class="line">//1.创建NSBlockOperation对象</span><br><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">   NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">//2.开始任务</span><br><span class="line">[operation start];</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line">//1.创建NSBlockOperation对象</span><br><span class="line">let operation = NSBlockOperation &#123; () -&gt; Void in</span><br><span class="line">    println(NSThread.currentThread())</span><br><span class="line">&#125;</span><br><span class="line">//2.开始任务</span><br><span class="line">operation.start()</span><br></pre></td></tr></table></figure>
<p>创建的<code>Operation</code>任务，默认会在当前线程执行。但<code>NSBlockOperation</code>有一个方法<code>addExecutionBlock</code>，通过这个方法可以给<code>Operation</code>添加多个执行<code>Block</code>，这样<code>Operation</code>中的任务会并发执行，<code>Operation</code>会在<strong>主线程</strong>和<strong>其他的多个线程</strong>执行这些任务。</p>
<p><code>addExecutionBlock</code>的使用示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//OC</span><br><span class="line">//1.创建NSBlockOperation对象</span><br><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">   NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">//添加多个Block</span><br><span class="line">for (NSInteger i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;第%ld次：%@&quot;, i, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">//2.开始任务</span><br><span class="line">[operation start];</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line">//1.创建NSBlockOperation对象</span><br><span class="line">let operation = NSBlockOperation &#123; () -&gt; Void in</span><br><span class="line">    NSLog(&quot;%@&quot;, NSThread.currentThread())</span><br><span class="line">&#125;</span><br><span class="line">//2.添加多个Block</span><br><span class="line">for i in 0.. Void in</span><br><span class="line">    NSLog(&quot;第%ld次 - %@&quot;, i, NSThread.currentThread())</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.开始任务</span><br><span class="line">operation.start()</span><br></pre></td></tr></table></figure>
<p>注：<code>addExecutionBlock</code>方法必须在<code>start()</code>方法之前执行，否则会报错。</p>
<ul>
<li>自定义<code>Operation</code></li>
</ul>
<p>除了<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>两种<code>Operation</code>外，还可以自定义<code>Operation</code>。自定义<code>Operation</code>需要继承<code>NSOperation</code>类，并实现其<code>main()</code>方法，因为在调用<code>start()</code>方法的时候，内部会调用<code>main()</code>方法完成相关逻辑。同时还需要实现<code>cancel()</code>在内的各种方法。</p>
<h5 id="创建队列-1"><a href="#创建队列-1" class="headerlink" title="创建队列"></a>创建队列</h5><p>可以调用一个<code>NSOperation</code>对象的<code>start()</code>方法来启动这个任务，但是这样做任务默认是同步执行的，就算使用<code>addExecutionBlock</code>方法，也会在<strong>当前线程</strong>和<strong>其他线程</strong>中执行，即还是会占用当前线程。这时就要用到队列<code>NSOperationQueue</code>了，按类型来说一共有两种类型，分为<strong>主队列</strong>和<strong>其他队列</strong>。只要任务添加到队列，会自动调用任务的<code>start()</code>方法。</p>
<ul>
<li><p>主队列</p>
<ul>
<li>在<code>iOS</code>中，每套多线程方案都会有一个主线程，这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程中处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  获取主队列的代码：</span><br><span class="line">  </span><br><span class="line">  //OBJECTIVE-C</span><br><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br><span class="line">//SWIFT</span><br><span class="line">let queue = NSOperationQueue.mainQueue()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>其他队列</p>
<ul>
<li>因为主队列比较特殊，会单独有一个类方法来获得主队列。那通过初始化产生的队列就是<strong>其他队列</strong>。因为只有两种队列，除了主队列，其他队列就不需要名字了</li>
<li>其他队列的任务会在其他线程并行执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  创建其他队列的代码：</span><br><span class="line">  </span><br><span class="line">  //OC</span><br><span class="line">  //1.创建一个其他队列    </span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">//2.创建NSBlockOperation对象</span><br><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">//3.添加多个Block</span><br><span class="line">for (NSInteger i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;第%ld次：%@&quot;, i, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">//4.队列添加任务</span><br><span class="line">[queue addOperation:operation];</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">//Swift</span><br><span class="line">//1.创建其他队列</span><br><span class="line">let queue = NSOperationQueue()</span><br><span class="line">//2.创建NSBlockOperation对象</span><br><span class="line">let operation = NSBlockOperation &#123; () -&gt; Void in</span><br><span class="line">    NSLog(&quot;%@&quot;, NSThread.currentThread())</span><br><span class="line">&#125;</span><br><span class="line">//3.添加多个Block</span><br><span class="line">for i in 0.. Void in</span><br><span class="line">        NSLog(&quot;第%ld次 - %@&quot;, i, NSThread.currentThread())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//4.队列添加任务</span><br><span class="line">queue.addOperation(operation)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>NSOperationQueue</code>与<code>GCD</code>的比较<ul>
<li>队列的比较<ul>
<li><code>NSOperationQueue</code>中没有串行队列，但<code>NSOperationQueue</code>中有一个参数<code>maxConcurrentOperationCount</code>最大并发数，用来设置最多可以让多少个任务同时执行。当把该参数设置为<code>1</code>时，任务就是串行执行了</li>
</ul>
</li>
<li>添加任务的比较<ul>
<li><code>NSOperationQueue</code>有一个添加任务的方法<code>- (void)addOperationWithBlock:(void (^)(void))block;</code>，和<code>GCD</code>类似，通过该方法就可以添加一个任务到队列中了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="NSOperation的使用"><a href="#NSOperation的使用" class="headerlink" title="NSOperation的使用"></a><code>NSOperation</code>的使用</h5><ul>
<li><p>添加依赖</p>
<ul>
<li>这是<code>NSOperation</code>实用的功能之一。使用场景如，有<code>3</code>个任务，<code>A</code>-从服务器上下载一张图片；<code>B</code>-给这张图片加个水印；<code>C</code>-把加水印的图片返回给服务器，这种场景下使用依赖进行处理</li>
<li>实现代码如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  //OC</span><br><span class="line">  //1.任务一：下载图片</span><br><span class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;下载图片 - %@&quot;, [NSThread currentThread]);</span><br><span class="line">    [NSThread sleepForTimeInterval:1.0];</span><br><span class="line">&#125;];</span><br><span class="line">//2.任务二：打水印</span><br><span class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;打水印   - %@&quot;, [NSThread currentThread]);</span><br><span class="line">    [NSThread sleepForTimeInterval:1.0];</span><br><span class="line">&#125;];</span><br><span class="line">//3.任务三：上传图片</span><br><span class="line">NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;上传图片 - %@&quot;, [NSThread currentThread]);</span><br><span class="line">    [NSThread sleepForTimeInterval:1.0];</span><br><span class="line">&#125;];</span><br><span class="line">//4.设置依赖</span><br><span class="line">[operation2 addDependency:operation1];      //任务二依赖任务一</span><br><span class="line">[operation3 addDependency:operation2];      //任务三依赖任务二</span><br><span class="line">//5.创建队列并加入任务</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  //Swift</span><br><span class="line">  //1.任务一：下载图片</span><br><span class="line">let operation1 = NSBlockOperation &#123; () -&gt; Void in</span><br><span class="line">    NSLog(&quot;下载图片 - %@&quot;, NSThread.currentThread())</span><br><span class="line">    NSThread.sleepForTimeInterval(1.0)</span><br><span class="line">&#125;</span><br><span class="line">//2.任务二：打水印</span><br><span class="line">let operation2 = NSBlockOperation &#123; () -&gt; Void in</span><br><span class="line">    NSLog(&quot;打水印   - %@&quot;, NSThread.currentThread())</span><br><span class="line">    NSThread.sleepForTimeInterval(1.0)</span><br><span class="line">&#125;</span><br><span class="line">//3.任务三：上传图片</span><br><span class="line">let operation3 = NSBlockOperation &#123; () -&gt; Void in</span><br><span class="line">    NSLog(&quot;上传图片 - %@&quot;, NSThread.currentThread())</span><br><span class="line">    NSThread.sleepForTimeInterval(1.0)</span><br><span class="line">&#125;</span><br><span class="line">//4.设置依赖</span><br><span class="line">operation2.addDependency(operation1)    //任务二依赖任务一</span><br><span class="line">operation3.addDependency(operation2)    //任务三依赖任务二</span><br><span class="line">//5.创建队列并加入任务</span><br><span class="line">let queue = NSOperationQueue()</span><br><span class="line">queue.addOperations([operation3, operation2, operation1], waitUntilFinished: false)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用依赖功能时应注意<ul>
<li>不能添加相互依赖，不然会产生死锁。如<code>A</code>依赖<code>B</code>，<code>B</code>依赖<code>A</code></li>
<li>可以使用<code>removeDependency</code>来解除依赖关系</li>
<li>可以在不同的队列之间依赖，因这个依赖是添加到任务身上的，和队列没关系</li>
</ul>
</li>
</ul>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><ul>
<li><code>NSOperation</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL executing; //判断任务是否正在执行</span><br><span class="line">BOOL finished; //判断任务是否完成</span><br><span class="line">void (^completionBlock)(void); //用来设置完成后需要执行的操作</span><br><span class="line">- (void)cancel; //取消任务</span><br><span class="line">- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NSOperationQueue</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger operationCount; //获取队列的任务数</span><br><span class="line">- (void)cancelAllOperations; //取消队列中所有的任务</span><br><span class="line">- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕</span><br><span class="line">[queue setSuspended:YES]; // 暂停queue</span><br><span class="line">[queue setSuspended:NO]; // 继续queue</span><br></pre></td></tr></table></figure>
<h3 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h3><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步，是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。有以下实现线程同步的方法</p>
<ul>
<li><p>互斥锁</p>
<ul>
<li>原理-给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块</li>
<li>实现代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//OC</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">  //需要执行的代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line">objc_sync_enter(self)</span><br><span class="line">//需要执行的代码块</span><br><span class="line">objc_sync_exit(self)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>同步执行</p>
<ul>
<li>原理-使用多线程的知识，把多个线程都要执行的代码块添加到同一个串行队列，通过这种方式实现线程同步的概念</li>
<li>实现代码(使用<code>GCD</code>和<code>NSOperation</code>的两种方案)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//OC</span><br><span class="line">//GCD</span><br><span class="line">//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSInteger ticket = lastTicket;</span><br><span class="line">    [NSThread sleepForTimeInterval:0.1];</span><br><span class="line">    NSLog(@&quot;%ld - %@&quot;,ticket, [NSThread currentThread]);</span><br><span class="line">    ticket -= 1;</span><br><span class="line">    lastTicket = ticket;</span><br><span class="line">&#125;);</span><br><span class="line">//NSOperation &amp; NSOperationQueue</span><br><span class="line">//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中</span><br><span class="line">//       2. 设置 queue 的 maxConcurrentOperationCount 为 1</span><br><span class="line">//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！</span><br><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSInteger ticket = lastTicket;</span><br><span class="line">    [NSThread sleepForTimeInterval:1];</span><br><span class="line">    NSLog(@&quot;%ld - %@&quot;,ticket, [NSThread currentThread]);</span><br><span class="line">    ticket -= 1;</span><br><span class="line">    lastTicket = ticket;</span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperation:operation];</span><br><span class="line">[operation waitUntilFinished];</span><br><span class="line">//后续要做的事</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><p>延迟执行，就是延时一段时间再执行某段代码。有以下实现延迟执行的常用方法</p>
<ul>
<li><p><code>perform</code></p>
<ul>
<li>实现代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//OC</span><br><span class="line">// 3秒后自动调用self的run:方法，并且传递参数：@&quot;abc&quot;</span><br><span class="line">[self performSelector:@selector(run:) withObject:@&quot;abc&quot; afterDelay:3];</span><br><span class="line"></span><br><span class="line">//Swift中无对应方法</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>GCD</code></p>
<ul>
<li>可以使用<code>GCD</code>中的<code>dispatch_after</code>方法，<code>OC</code>和<code>Swift</code>中都可以使用</li>
<li>实现代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  //OC</span><br><span class="line">  // 创建队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">// 设置延时，单位秒</span><br><span class="line">double delay = 3; </span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^&#123;</span><br><span class="line">    // 3秒后需要执行的任务</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>NSTimer</code></p>
<ul>
<li>计时器实现延迟执行</li>
<li>实现代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//OC</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@&quot;abc&quot; repeats:NO];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>这里使用<code>GCD</code>的<code>dispatch_once</code>方法来实现</p>
<p>实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//OC</span><br><span class="line">@interface Tool : NSObject</span><br><span class="line">+ (instancetype)sharedTool;</span><br><span class="line">@end</span><br><span class="line">@implementation Tool</span><br><span class="line">static id _instance;</span><br><span class="line">+ (instancetype)sharedTool &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[Tool alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="从其他线程回到主线程的方法"><a href="#从其他线程回到主线程的方法" class="headerlink" title="从其他线程回到主线程的方法"></a>从其他线程回到主线程的方法</h4><p>在其他线程操作完成后需要回到主线程更新<code>UI</code>。有以下实现回到主线程的方法</p>
<ul>
<li><code>NSThread</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Objective-C</span><br><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];</span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line">//swift 取消了 performSelector 方法。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>GCD</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Objective-C</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">&#125;);</span><br><span class="line">//Swift</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NSOperationQueue</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Objective-C</span><br><span class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">&#125;];</span><br><span class="line">//Swift</span><br><span class="line">NSOperationQueue.mainQueue().addOperationWithBlock &#123; () -&gt; Void in</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同多线程方案的使用方法和注意事项"><a href="#不同多线程方案的使用方法和注意事项" class="headerlink" title="不同多线程方案的使用方法和注意事项"></a>不同多线程方案的使用方法和注意事项</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/微信小程序开发笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/微信小程序开发笔记/" class="post-title-link" itemprop="url">微信小程序开发笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 15:25:29" itemprop="dateCreated datePublished" datetime="2020-01-10T15:25:29+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>模块的使用</p>
<ul>
<li><code>WXML</code>中的模块，使用<code>&lt;import src=&quot;模块所在路径&quot;/&gt;</code>导入</li>
<li><code>JS</code>中的模块，使用<code>require(&#39;模块所在路径&#39;)</code>导入<ul>
<li>注：<code>JS</code>模块中，要通过<code>module.exports = {外部使用的方法名:JS模块内部实现的方法名};</code>对所要使用的方法进行注册</li>
</ul>
</li>
</ul>
</li>
<li><p><code>px</code>与<code>rpx</code>间的相互转换</p>
<ul>
<li><code>rpx</code>转<code>px</code>：<code>px = rpx / 750 * wx.getSystemInfoSync().screenWidth;</code></li>
<li><code>px</code>转<code>rpx</code>：<code>rpx = px * 750 / wx.getSystemInfoSync().screenWidth;</code></li>
</ul>
</li>
<li><p><code>position</code></p>
<ul>
<li><code>relative</code>(相对) - 这个属性是在保留自己原来的位置不变的情况下，在原来的位置中进行偏移</li>
<li><code>absolute</code>(绝对) - 这个属性并没有保留原来的位置，并且坐标偏移是以最近的父视图为准进行偏移</li>
<li><code>fixed</code>(确定) - 这个属性元素框的表现类似于将<code>position</code>设置为<code>absolute</code>，不过其包含块是视窗本身</li>
</ul>
</li>
<li><p>布局技巧</p>
<ul>
<li>左右两侧可以各自滑动，互不影响 - 使用<code>absolute</code>布局</li>
</ul>
</li>
<li><p>取值</p>
<ul>
<li>通过<code>dataset.key</code>取值时，<code>key</code>全为小写字母</li>
</ul>
</li>
<li><p>使用<code>scroll-view</code>实现锚点跳转</p>
<ul>
<li>使用<code>scroll-view</code>实现长页面的标记跳转，锚点标记主要是使用<code>scroll-view</code>的<code>scroll-into-view</code>属性</li>
<li>实现步骤如下<ul>
<li>最外层容器使用<code>scroll-view</code></li>
<li>设置<code>scroll-view</code>的滚动方向<code>scroll-y=&quot;true&quot;</code></li>
<li>赋值<code>scroll-into-view</code></li>
<li>跳转到的位置使用<code>id</code>定位。注id的值要使用字母、数字、下划线开头，且定位的<code>id</code>格式值和<code>scroll-into-view</code>的属性值的格式要一致</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/18/轮子(代码)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/18/轮子(代码)/" class="post-title-link" itemprop="url">轮子(代码)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-18 14:13:17" itemprop="dateCreated datePublished" datetime="2019-10-18T14:13:17+08:00">2019-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>圆形图像-无边框</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)getEllipseImageWithImage:(UIImage *)originImage &#123;</span><br><span class="line">    CGFloat padding = 40;</span><br><span class="line">    UIColor *bgColor = UIColor.orangeColor;</span><br><span class="line">    CGSize originSize = originImage.size;</span><br><span class="line">    CGRect originRect = CGRectMake(0, 0, originSize.width, originSize.height);</span><br><span class="line">    </span><br><span class="line">    UIGraphicsBeginImageContext(originSize);</span><br><span class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGRect desRect = CGRectMake(padding, padding, originSize.width - padding * 2, originSize.height - padding * 2);</span><br><span class="line">    CGContextSetFillColorWithColor(ctx, bgColor.CGColor);</span><br><span class="line">    </span><br><span class="line">    UIRectFill(originRect);</span><br><span class="line">    </span><br><span class="line">    CGContextAddEllipseInRect(ctx, desRect);</span><br><span class="line">    CGContextClip(ctx);</span><br><span class="line">    </span><br><span class="line">    [originImage drawInRect:originRect];</span><br><span class="line">    </span><br><span class="line">    UIImage *desImg = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    </span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    </span><br><span class="line">    return desImg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>圆形图像-有边框</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)getEllipseImageByFrameWithImage:(UIImage *)originImage &#123;</span><br><span class="line">    CGFloat padding = 5;</span><br><span class="line">    UIColor *bgColor = UIColor.purpleColor;</span><br><span class="line">    </span><br><span class="line">    CGSize originSize = originImage.size;</span><br><span class="line">    CGRect originRect = CGRectMake(0, 0, originSize.width, originSize.height);</span><br><span class="line">    </span><br><span class="line">    UIGraphicsBeginImageContext(originSize);</span><br><span class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGRect desRect = CGRectMake(padding, padding, originSize.width - padding * 2, originSize.height - padding * 2);</span><br><span class="line">    CGContextSetFillColorWithColor(ctx, bgColor.CGColor);</span><br><span class="line">    UIRectFill(originRect);</span><br><span class="line">    CGContextAddEllipseInRect(ctx, desRect);</span><br><span class="line">    CGContextClip(ctx);</span><br><span class="line">    [originImage drawInRect:originRect];</span><br><span class="line">    </span><br><span class="line">    //frame</span><br><span class="line">    CGFloat borderW = 10;</span><br><span class="line">    CGContextSetStrokeColorWithColor(ctx, [UIColor blueColor].CGColor);</span><br><span class="line">    CGContextSetLineCap(ctx, kCGLineCapButt);</span><br><span class="line">    CGContextSetLineWidth(ctx, borderW);</span><br><span class="line">    CGContextAddEllipseInRect(ctx, desRect);</span><br><span class="line">    CGContextStrokePath(ctx);</span><br><span class="line">    </span><br><span class="line">    UIImage *desImg = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    </span><br><span class="line">    return desImg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/Runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/16/Runtime/" class="post-title-link" itemprop="url">Runtime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-16 14:38:13" itemprop="dateCreated datePublished" datetime="2019-10-16T14:38:13+08:00">2019-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>OC</code>是一门基于<code>C</code>语言加入了<strong>面向对象特性</strong>和<strong>消息转发机制</strong>的动态语言，因此<code>OC</code>总是想办法把一些决定工作从<strong>编译连接</strong>推迟到<strong>运行时</strong>，这意味着只有编译器是不够的，还需要一个运行时系统(<code>runtime system</code>)来执行编译后的代码，动态创建类和对象，进行消息发送和转发，这就是<code>Objective-C Runtime</code>系统存在的意义，它是整个<code>OC</code>运行框架的一块基石。<code>Runtime</code>简称运行时。<strong><code>OC</code>就是运行时机制，其中最主要的是消息机制。</strong>对于<code>C</code>语言，函数的调用在编译的时候会决定调用哪个函数；对于<code>OC</code>的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。<code>Runtime</code>基本是用<code>C</code>和汇编写的，可见苹果为了动态系统的高效而作出的努力。</p>
<p>高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是<code>OC</code>并不能直接编译为汇编语言，而是要先转写为纯<code>C</code>语言再进行编译和汇编的操作，从<code>OC</code>到<code>C</code>语言的过渡就是由<code>Runtime</code>来实现的。然而我们使用<code>OC</code>进行面向对象开发，而<code>C</code>语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。</p>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><code>Runtime</code>的核心是消息传递(<code>Messaging</code>)</p>
<p>在<code>OC</code>中，使用<code>[receiver message]</code>语法并不会马上执行<code>receiver</code>对象的<code>message</code>方法的代码，而是向<code>receiver</code>发送一条<code>message</code>消息，这条消息可能由<code>receiver</code>来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。其实<code>[receiver message]</code>被编译器转化为：<code>id objc_msgSend(id self, SEL op, ...);</code></p>
<p>以上述例子，从<code>id</code>和<code>SEL</code>两个数据结构来理解<code>Runtime</code>所包含的重要数据结构</p>
<h5 id="Runtime数据结构"><a href="#Runtime数据结构" class="headerlink" title="Runtime数据结构"></a><code>Runtime</code>数据结构</h5><ul>
<li><p><code>SEL</code></p>
<ul>
<li><code>SEL</code>是函数<code>objc_msgSend</code>第二个参数的数据类型，表示<strong>方法选择器</strong></li>
<li><code>SEL</code>的数据结构是：<code>typedef struct objc_selector *SEL;</code><ul>
<li><code>SEL</code>是映射到方法的<code>C</code>字符串</li>
<li>可以通过<code>OC</code>编译器命令<code>@selector()</code>或者<code>Runtime</code>系统的<code>sel_registerName</code>函数来获取一个<code>SEL</code>类型的方法选择器</li>
<li>如果知道<code>selector</code>对应的方法名是什么，可以通过<code>NSString* NSStringFromSelector(SEL aSelector)</code>方法将<code>SEL</code>转化为字符串</li>
</ul>
</li>
</ul>
</li>
<li><p><code>id</code></p>
<ul>
<li><code>id</code>是通用类型指针，能够表示任何对象</li>
<li><p><code>id</code>的数据结构如下</p>
<p> <img src="/2019/10/16/Runtime/id数据结构.png" alt="id数据结构"></p>
</li>
<li><p><code>id</code>其实就是一个指向<code>objc_object</code>结构体指针，它包含一个<code>Class isa</code>成员，根据<code>isa</code>指针就可以顺藤摸瓜找到<strong>对象所属的类</strong></p>
</li>
<li>注：根据<code>Apple</code>的官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="noopener">Key-Value Observing Implementation Details</a>提及，<code>key-value observing</code>是使用<code>isa-swizzling</code>的技术实现的，<code>isa</code>指针在运行时被修改，指向一个中间类而不是真正的类。所以，你不应该使用<code>isa</code>指针来确定类的关系，而是使用<code>class</code>方法来确定实例对象的类</li>
</ul>
</li>
<li><p><code>Class</code></p>
<ul>
<li><code>isa</code>指针的数据类型是<code>Class</code>，<code>Class</code>表示对象所属的类</li>
<li><p><code>Class</code>的数据结构如下</p>
<p><img src="/2019/10/16/Runtime/Class的数据结构.png" alt="Class的数据结构"></p>
</li>
<li><p><code>Class</code>是一个<code>objc_class</code>结构体指针</p>
</li>
<li><p><code>objc_class</code>结构体定义如下</p>
<p><img src="/2019/10/16/Runtime/objc_class结构体定义.png" alt="objc_class结构体定义"></p>
</li>
<li><p>注：<code>OBJC2_UNAVAILABLE</code>是一个<code>Apple</code>对<code>Objc</code>系统运行版本进行约束的宏定义，主要为了兼容非<code>Objective-C 2.0</code>的遗留版本</p>
</li>
<li><p>重要成员变量的分析</p>
<ul>
<li><p><code>isa</code>表示一个<code>Class</code>对象的<code>Class</code>，也就是<code>Meta Class</code>。在面向对象设计中，一切都是对象，<code>Class</code>在设计中本身也是一个对象。<code>objc_class</code>定义如下：</p>
<p><img src="/2019/10/16/Runtime/objc_class定义.png" alt="objc_class定义"></p>
</li>
<li><p>由上图可见，结构体<code>objc_class</code>也是继承<code>objc_object</code>，说明<code>Class</code>在设计中本身也是一个对象</p>
</li>
<li><p><code>Meta Class</code>也是一个<code>Class</code>，它也跟其他<code>Class</code>一样有自己的<code>isa</code>和<code>super_class</code>指针。关系图如下：</p>
<p><img src="/2019/10/16/Runtime/Class中isa和super_class间的关系图.png" alt="Class中isa和super_class间的关系图"></p>
</li>
<li><p>上图中实线是<code>super_class</code>指针，虚线是<code>isa</code>指针，其中</p>
<ul>
<li><code>Root class</code>(<code>class</code>)其实就是<code>NSObject</code>，<code>NSObject</code>是没有超类的，所以<code>Root class</code>(<code>class</code>)的<code>superclass</code>指向<code>nil</code></li>
<li>每个<code>Class</code>都有一个<code>isa</code>指针指向唯一的<code>Meta class</code>(<code>isa</code>是对象指向自己所属类型的指针)</li>
<li><code>Root class</code>(<code>meta</code>)的<code>superclass</code>指向<code>Root class</code>(<code>class</code>)，也就是<code>NSObject</code>，形成一个回路</li>
<li>每个<code>Meta class</code>的<code>isa</code>指针都指向<code>Root class</code>(<code>meta</code>)</li>
</ul>
</li>
<li><p><code>ivars</code>表示多个成员变量，它指向<code>objc_ivar_list</code>结构体，结构体的定义如下</p>
<p><img src="/2019/10/16/Runtime/objc_ivar_list结构体定义.png" alt="objc_ivar_list结构体定义"></p>
<ul>
<li><code>objc_ivar_list</code>是一个链表，存储多个<code>objc_ivar</code>，而<code>objc_ivar</code>结构体存储类的单个成员变量信息</li>
</ul>
</li>
<li><p><code>methodLists</code>表示方法列表，它指向<code>objc_method_list</code>结构体的二级指针，可以动态修改<code>*methodLists</code>的值来添加成员方法，也是<code>Category</code>实现原理，同样也解释<code>Category</code>不能添加实例变量的原因。<code>objc_method_list</code>结构体的定义如下</p>
<p><img src="/2019/10/16/Runtime/objc_method_list结构体的定义.png" alt="objc_method_list结构体的定义"></p>
<ul>
<li><code>objc_method_list</code>也是一个链表，存储多个<code>objc_method</code>，而<code>objc_method</code>结构体存储类的某个方法的信息</li>
</ul>
</li>
<li><code>cache</code>用来缓存经常访问的方法，它指向<code>objc_cache</code>结构体</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Method</code></p>
<ul>
<li><p><code>Method</code>表示类中的某个方法，其定义如下</p>
<p><img src="/2019/10/16/Runtime/method定义.png" alt="method定义"></p>
<ul>
<li><code>Method</code>是一个指向<code>objc_method</code>结构体的指针，<code>objc_method</code>结构体存储了方法名(<code>method_name</code>)、方法类型(<code>method_types</code>)和方法实现(<code>method_imp</code>)等信息，<code>method_imp</code>的数据类型是<code>IMP</code>，它是一个函数指针</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Ivar</code></p>
<ul>
<li><code>Ivar</code>表示类中的实例变量</li>
<li><p><code>Ivar</code>的结构定义如下</p>
<p><img src="/2019/10/16/Runtime/Ivar结构定义.png" alt="Ivar结构定义"></p>
<ul>
<li><code>Ivar</code>是一个指向<code>objc_ivar</code>结构体指针，它包含了变量名(<code>ivar_name</code>)、变量类型(<code>ivar_type</code>)等信息</li>
</ul>
</li>
</ul>
</li>
<li><p><code>IMP</code></p>
<ul>
<li><code>IMP</code>本质上是一个函数指针，指向方法的实现</li>
<li><p><code>IMP</code>的定义如下</p>
<p><img src="/2019/10/16/Runtime/IMP的定义.png" alt="IMP的定义"></p>
<ul>
<li>当向某个对象发送一条信息，可以由这个函数指针(<code>IMP</code>)来指定方法的实现，它最终就会执行那段代码，这样可以绕开<strong>消息传递</strong>阶段而去执行另一个方法实现</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Cache</code></p>
<ul>
<li><code>Cache</code>用来缓存</li>
<li><p><code>Cache</code>的定义如下</p>
<p><img src="/2019/10/16/Runtime/Cache的定义.png" alt="Cache的定义"></p>
<ul>
<li><code>Cache</code>其实就是一个存储<code>Method</code>的链表，主要是为了优化方法调用的性能</li>
<li>不通过<code>Cache</code>进行方法调用的流程为，当对象<code>receiver</code>调用方法<code>message</code>时，首先根据对象<code>receiver</code>的<code>isa</code>指针查找到它对应的类，然后在类的<code>methodLists</code>中搜索方法，如果没有找到，就使用<code>super_class</code>指针到父类中的<code>methodLists</code>查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有<code>20%</code>的方法经常被调用，占总调用次数的<code>80%</code>。所以使用<code>Cache</code>来缓存经常调用的方法，当调用方法时，优先在<code>Cache</code>查找，如果没有找到，再到<code>methodLists</code>查找，这样就可以大大提高函数查询的效率。这也就是<code>objc_class</code>中重要成员<code>objc_cache</code>做的事情，在找到<code>message</code>之后，把<code>message</code>的<code>method_name</code>作为<code>key</code>，<code>method_imp</code>作为<code>value</code>给存起来。当再次收到<code>message</code>消息的时候，可以直接在<code>cache</code>里找到，避免去遍历<code>objc_method_list</code>。<code>objc_cache</code>是存在<code>objc_class</code>结构体中的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><h5 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a><code>objc_msgSend</code>函数</h5><p>当某个对象使用语法<code>[receiver message]</code>来调用某个方法时，其实<code>[receiver message]</code>被编译器转化为:<code>id objc_msgSend(id self, SEL op, ...);</code></p>
<ul>
<li><p><code>objc_msgSend</code>具体发送消息的流程如下</p>
<ol>
<li>首先根据<code>receiver</code>对象的isa指针获取它对应的<code>class</code>(找到对象对应的类)</li>
<li>优先在<code>class</code>的<code>cache</code>查找<code>message</code>方法，如果找不到，再到<code>methodLists</code>查找</li>
<li>如果没有在<code>class</code>找到，再到<code>super_class</code>查找</li>
<li>一旦找到<code>message</code>这个方法，就执行它实现的<code>IMP</code></li>
<li><p>消息发送流程图如下</p>
<p><img src="/2019/10/16/Runtime/消息发送流程图.png" alt="消息发送流程图"></p>
</li>
</ol>
</li>
</ul>
<h5 id="方法解析与消息转发"><a href="#方法解析与消息转发" class="headerlink" title="方法解析与消息转发"></a>方法解析与消息转发</h5><h3 id="OC中基于Runtime特性的运用"><a href="#OC中基于Runtime特性的运用" class="headerlink" title="OC中基于Runtime特性的运用"></a><code>OC</code>中基于<code>Runtime</code>特性的运用</h3><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>分类中不能重写系统方法，因为会把系统的方法给覆盖掉，分类中不能调用<code>super</code></p>
<p>运用<code>Runtime</code>在分类中添加自定义方法，涉及的点：<code>+load VS +initialize</code>、<code>method_exchangeImplementations(originalMethod, swizzledMethod);</code></p>
<p>分类中添加自定义方法时在<code>load</code>中操作的原因：<code>+load</code>方法能够确保在类的初始化时候调用，这能够保证改变应用行为的一致性。(由于<code>load</code>类方法是程序运行时这个类被加载到内存中就调用的一个方法，执行比较早，并且不需要我们手动调用。而且这个方法具有唯一性，也就是只会被调用一次，不用担心资源抢夺的问题)</p>
<p><code>class_addMethod</code>：当被添加的方法已经存在时，会返回<code>NO</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/09/iOS中的框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/09/iOS中的框架/" class="post-title-link" itemprop="url">iOS中的框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-09 10:08:06" itemprop="dateCreated datePublished" datetime="2019-10-09T10:08:06+08:00">2019-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Cocoa"><a href="#Cocoa" class="headerlink" title="Cocoa"></a><code>Cocoa</code></h3><p><strong><code>Cocoa</code></strong>不是一种编程语言，也不是一个开发工具，它是创建<code>Mac OS X</code>和<code>iOS</code>程序的原生面向对象<code>API</code>，为这两者应用提供了<strong>编程环境</strong>。</p>
<p><code>Cocoa</code>本身是一个<strong>框架的集合</strong>，它包含了众多子框架，其中最重要的要数<code>Foundation</code>和<code>UIKit</code>。<code>Foundation</code>是框架的基础，和界面无关，其中包含了大量常用的<code>API</code>；<code>UIKit</code>是基础的<code>UI</code>类库，在进行<code>iOS</code>应用程序开发的过程中会经常用到。</p>
<p><code>Foundation</code>和<code>UIKit</code>这两个框架在系统中的位置如下图：</p>
<p><img src="/2019/10/09/iOS中的框架/Foundation和UIKit的位置.jpg" alt="Foundation和UIKit的位置"></p>
<ul>
<li><p>所有的<code>Mac OS X</code>和<code>iOS</code>程序都是由大量的对象构成，而这些对象的根对象都是<code>NSObject</code>，<code>NSObject</code>就处在<code>Foundation</code>框架之中，具体的类结构如下：</p>
<p><img src="/2019/10/09/iOS中的框架/NSObject类结构01.jpg" alt="NSObject类结构01"></p>
<p><img src="/2019/10/09/iOS中的框架/NSObject类结构02.jpg" alt="NSObject类结构02"></p>
<p><img src="/2019/10/09/iOS中的框架/NSObject类结构03.jpg" alt="NSObject类结构03"></p>
<ul>
<li>通常会将它们分为以下几类<ul>
<li>操作系统服务：文件系统、<code>URL</code>、进程通讯</li>
<li>归档和序列化</li>
<li>表达式和条件判断</li>
<li><code>Objective-C</code>语言服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="UIKit框架"><a href="#UIKit框架" class="headerlink" title="UIKit框架"></a><code>UIKit</code>框架</h3><p><code>UIKit</code>主要用于界面构架</p>
<ul>
<li><code>UIKit</code>框架中类的结构如下</li>
</ul>
<p><img src="/2019/10/09/iOS中的框架/UIKit框架中的类继承图.jpg" alt="UIKit框架中的类继承图"></p>
<h3 id="iOS文件系统框架"><a href="#iOS文件系统框架" class="headerlink" title="iOS文件系统框架"></a><code>iOS</code>文件系统框架</h3><ul>
<li><code>iOS</code>文件系统框架图如下</li>
</ul>
<p><img src="/2019/10/09/iOS中的框架/iOS文件系统框架图.jpg" alt="iOS文件系统框架图"></p>
<h3 id="常用知识点"><a href="#常用知识点" class="headerlink" title="常用知识点"></a>常用知识点</h3><h5 id="常用结构体"><a href="#常用结构体" class="headerlink" title="常用结构体"></a>常用结构体</h5><p>在<code>Foundation</code>中定义了很多常用结构体类型来简化我们的日常开发，这些结构体完全采用<code>Objective-C</code>定义，和我们自己定义的结构体没有任何区别，之所以由框架为我们提供，完全是为了简化我们的开发。常用的结构体有<code>NSRange</code>、<code>NSPoint</code>、<code>NSSize</code>、<code>NSRect</code>等。</p>
<ul>
<li><p>在<code>OC</code>中多数时间单位都是秒。</p>
</li>
<li><p>系统静态方法一般都是自动释放。</p>
</li>
</ul>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p>在<code>OC</code>中路径、文件读写等操作是利用字符串来完成的。</p>
<p>读取文件内容还可以利用<code>URL</code>，它除了可以读取本地文件还可以读取网络文件。</p>
<p>是否是绝对路径，如是以<code>/</code>开头的则是绝对路径，反之不是。</p>
<p><code>OC</code>中，获取扩展名不包括<code>.</code>；删除扩展名，包含<code>.</code>。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p><strong>对数组进行操作时，应关注所进行的操作，是否会对原数组有所修改。</strong></p>
<p>数组最后以<code>nil</code>结尾。</p>
<p>数组不能存放<code>C</code>语言的基础类型。</p>
<ul>
<li>可变数组<ul>
<li>当把对象添加到数组中的时候，对象的计数器会<code>+1</code>，当把对象从数组中移除的时候，对象的计数器会<code>-1</code></li>
<li>当可变数组对象<code>release</code>的时候，会依次调用数组里面每个对象的<code>release</code></li>
<li>在不可变数组中无论对数组怎么排序，原来的数组顺序都不会改变，但是在可变数组中如果使用<code>sortUsingSelector:</code>排序原来的数组顺序就发生了变化</li>
</ul>
</li>
</ul>
<h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><ul>
<li>同数组一样，不管是可变字典还是不可变字典初始化元素后面必须加上<code>nil</code>以表示结束</li>
<li>对于字典遍历，<code>for</code>遍历循环的是<code>key</code></li>
<li>一个字典的<code>key</code>或<code>value</code>添加到字典中时计数器<code>+1</code>；字典释放时调用<code>key</code>或<code>value</code>的<code>release</code>一次，计数器<code>-1</code></li>
</ul>
<h5 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h5><ul>
<li>装箱<ul>
<li>是为了将基本类型和结构体，封装成对象类型，以便于存放到数组和字典中</li>
<li><code>OC</code>中装箱的过程必须手动实现，<code>OC</code>不支持自动装箱</li>
<li>在<code>OC</code>中一般将基本数据类型装箱成<code>NSNumber</code>类型，<code>NSNumber</code>不能对结构体装箱</li>
<li>对结构体的装箱和拆箱，需要使用<code>NSValue</code>类型<ul>
<li><code>NSNumber</code>是<code>NSValue</code>的子类</li>
<li><code>NSValue</code>包装了一些基本数据类型的常用装箱、拆箱方法</li>
<li><code>NSValue</code>可以对任何数据类型进行装箱、拆箱操作</li>
<li>对于系统自带的结构体类型，系统提供了对应的装箱、拆箱方法</li>
<li>对于自定义的结构体类型，需要使用NSValue中的如下方法进行处理<ul>
<li>使用<code>+(NSValue *)valueWithBytes:(const void *)value objCType:(const char *)type;</code>进行装箱</li>
<li>使用<code>-(void)getValue:(void *)value;</code>进行拆箱</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p><code>C</code>语言中定义字符串结尾必须加一个<code>\0</code>，表示字符串结束。</p>
<p>在数组和字典里使用<code>nil</code>，来表示数组或字典已经结束。如果想在数组或字典中存储空值，则需要使用<code>NSNull</code>。<code>NSNull</code>这个类是一个单例，只有一个<code>null</code>方法。</p>
<ul>
<li><p><code>@</code>符号</p>
<ul>
<li>可表示关键字，如<code>@protocol</code></li>
<li>可表示字符串，如<code>@&quot;xxx&quot;</code></li>
<li>可表示输出一个对象，如<code>%@</code></li>
<li>可表示装箱，如<code>@3</code></li>
</ul>
</li>
<li><p><code>isKindOfClass</code>判断一个对象是否为某种类型；<code>isMemberOfClass</code>判断一个对象是否是某个类的实例化对象</p>
</li>
<li><p><code>OC</code>反射功能的实现，得益于<code>OC</code>动态运行时的支持</p>
<ul>
<li>反射，即是对正常操作的逆向实现。一般正常操作是根据类型生成实例对象，反射是先根据字符串，通过系统的<code>API</code>(如，<code>NSClassFromString</code>、<code>NSStringFromClass</code>、<code>NSSelectorFromString</code>、<code>NSStringFromSelector</code>等)得到对应的类，在得到类的基础上走正常操作流程</li>
</ul>
</li>
<li><p><code>retain</code>、<code>copy</code>、<code>mutablecopy</code>的理解</p>
<ul>
<li><code>retain</code>：始终采取浅复制，引用计数器会加<code>1</code>，返回的对象和被复制对象是同一个对象<code>1</code>(也就是说这个对象的引用多了一个，或者说是指向这个对象的指针多了一个)</li>
<li><code>copy</code>：对于不可变对象<code>copy</code>采用的是浅复制，引用计数器加<code>1</code>(其实这是编译器进行了优化，既然原来的对象不可变，复制之后的对象也不可变那么就没有必要再重新创建一个对象了)；对于可变对象<code>copy</code>采用的是深复制，引用计数器不变(原来的对象是可变，现在要产生一个不可变的当然得重新产生一个对象)</li>
<li><code>mutablecopy</code>：无论是可变对象还是不可变对象采取的都是深复制，引用计数器不变(如果从一个不可变对象产生一个可变对象自然不用说两个对象绝对不一样肯定是深复制；如果从一个可变对象产生出另一个可变对象，那么当其中一个对象改变自然不希望另一个对象改变，当然也是深复制)</li>
</ul>
</li>
<li><p>要想支持<code>copy</code>或者<code>mutablecopy</code>操作那么对象必须实现<code>NSCoping</code>协议并实现<code>-(id)copyWithZone:(NSZone*)zone</code>方法。在<code>Foundation</code>中常用的可复制对象有：<code>NSNumber</code>、<code>NSString</code>、<code>NSMutableString</code>、<code>NSArray</code>、<code>NSMutableArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code></p>
<ul>
<li><code>zone</code>是系统已经分配好的用于存储当前对象的内存</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li>字符串常量，存储在常量区，系统不会对它进行引用计数</li>
<li>通过<code>stringWithxxx</code>创建的字符串对象同一般对象类似，存储在堆中，系统会对其进行引用计数</li>
<li>通过<code>stringWithString</code>生成的字符串，其引用计数的值，由后面参数对象的类型确定</li>
</ul>
</li>
<li><p>文件操作</p>
<ul>
<li>细粒度的操作文件，需要通过文件操作柄(<code>NSFileHandle</code>)进行操作</li>
<li>注，使用文件柄操作文件时，对于打开的文件要记得关闭</li>
<li>文件的操作，可通过<code>NSURL</code>、<code>NSBundle</code>(程序包)<ul>
<li><code>NSBundle</code>，程序包，一般用于获取<code>Resource</code>中的资源。在<code>iOS</code>中经常用于读取应用程序中的资源文件，如图片、声音、视频等</li>
<li><code>[NSBundle mainBundle];</code>//主要操作<strong>程序包所在目录</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>归档/解档</p>
<ul>
<li>归档，在其他语言中又叫“序列化”，就是将对象保存到硬盘；解档，在其他语言又叫“反序列化”就是将硬盘文件还原成对象。其实归档就是数据存储的过程，在<code>iOS</code>中数据的存储有五种方式：<ol>
<li><code>xml</code>属性列表(<code>plist</code>归档)</li>
<li><code>NSUserDefaults</code>(偏好设置)</li>
<li><code>NSKeyedArchiver</code>归档(加密形式)</li>
<li><code>SQLite3</code>(嵌入式数据库)</li>
<li><code>Core Data</code>(面向对象方式的嵌入式数据库)</li>
</ol>
</li>
<li><code>xml</code>属性列表<ul>
<li>缺点：<ul>
<li>这种方式是明文保存的</li>
<li>这种方式操作的对象有限，只有<code>NSArray</code>、<code>NSMutableArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code>支持</li>
</ul>
</li>
<li>归档时只要调用对应的<code>writeToFile</code>方法即可，解档调用<code>arrayWithContentsOfFile</code>或<code>dictionaryWithContentsOfFile</code>，注意像<code>NSString</code>、<code>NSNumber</code>、<code>NSData</code>即使有这个方法它存储的也不是<code>xml</code>格式</li>
</ul>
</li>
<li><code>NSKeyedArchiver</code>归档<ul>
<li>如果要针对更多对象归档或者需要归档时能够加密的话就需要使用<code>NSKeyedArchiver</code>进行归档和解档，使用这种方式归档的范围更广而且归档内容是密文存储</li>
<li>从归档范围来讲<code>NSKeyedArchiver</code>适合所有<code>OC</code>对象，但是对于自定义对象我们需要实现<code>NSCoding</code>协议</li>
<li>从归档方式来讲<code>NSKeyedArchiver</code>分为简单归档和复杂对象归档，简单归档就是针对单个对象可以直接将对象作为根对象(不用设置<code>key</code>)，复杂对象就是针对多个对象，存储时不同对象需要设置不同的<code>Key</code></li>
<li>自定义对象的归档<ul>
<li>对自定义对象进行归档那么这个对象必须实现<code>NSCoding</code>协议，在这个协议中有两个方法都必须实现：<ol>
<li><code>-(void)encodeWithCoder:(NSCoder *)aCoder;</code>通过给定的<code>Archiver</code>对消息接收者进行编码 - 归档时调用</li>
<li><code>-(id)initWithCoder:(NSCoder *)aDecoder;</code>从一个给定的<code>Unarchiver</code>的数据返回一个初始化对象 - 解档时调用</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
