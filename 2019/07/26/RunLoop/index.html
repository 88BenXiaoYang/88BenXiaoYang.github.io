<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="RunLoop的概念 背景：一般情况下，一个线程一次只能执行一个任务，执行完任务后线程就会退出。 目的：需要一个机制，让线程能随时处理事件但并不退出。  为了实现上述目的，引入Event Loop模型(事件循环模型)。Event Loop在OSX/iOS里的实现是RunLoop。实现Event Loop模型的关键点是：如何管理事件/消息，如何让线程在没有消息处理时休眠以避免资源占用，在有消息到来时">
<meta property="og:type" content="article">
<meta property="og:title" content="RunLoop">
<meta property="og:url" content="http://yoursite.com/2019/07/26/RunLoop/index.html">
<meta property="og:site_name" content="Ben&#39;Blog">
<meta property="og:description" content="RunLoop的概念 背景：一般情况下，一个线程一次只能执行一个任务，执行完任务后线程就会退出。 目的：需要一个机制，让线程能随时处理事件但并不退出。  为了实现上述目的，引入Event Loop模型(事件循环模型)。Event Loop在OSX/iOS里的实现是RunLoop。实现Event Loop模型的关键点是：如何管理事件/消息，如何让线程在没有消息处理时休眠以避免资源占用，在有消息到来时">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/07/26/RunLoop/与RunLoop相关的类关系.png">
<meta property="og:image" content="http://yoursite.com/2019/07/26/RunLoop/RunLoop内部逻辑.png">
<meta property="og:image" content="http://yoursite.com/2019/07/26/RunLoop/OSX_iOS系统架构.png">
<meta property="og:image" content="http://yoursite.com/2019/07/26/RunLoop/Darwin核心架构.png">
<meta property="og:image" content="http://yoursite.com/2019/07/26/RunLoop/状态切换流程.png">
<meta property="og:image" content="http://yoursite.com/2019/07/26/RunLoop/NSURLConnection工作流程图.png">
<meta property="og:updated_time" content="2020-11-23T03:54:31.126Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RunLoop">
<meta name="twitter:description" content="RunLoop的概念 背景：一般情况下，一个线程一次只能执行一个任务，执行完任务后线程就会退出。 目的：需要一个机制，让线程能随时处理事件但并不退出。  为了实现上述目的，引入Event Loop模型(事件循环模型)。Event Loop在OSX/iOS里的实现是RunLoop。实现Event Loop模型的关键点是：如何管理事件/消息，如何让线程在没有消息处理时休眠以避免资源占用，在有消息到来时">
<meta name="twitter:image" content="http://yoursite.com/2019/07/26/RunLoop/与RunLoop相关的类关系.png">

<link rel="canonical" href="http://yoursite.com/2019/07/26/RunLoop/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>RunLoop | Ben'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ben'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工欲善其事，必先利其器</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RunLoop
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-26 12:59:14" itemprop="dateCreated datePublished" datetime="2019-07-26T12:59:14+08:00">2019-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 11:54:31" itemprop="dateModified" datetime="2020-11-23T11:54:31+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="RunLoop的概念"><a href="#RunLoop的概念" class="headerlink" title="RunLoop的概念"></a><code>RunLoop</code>的概念</h3><ul>
<li>背景：一般情况下，<strong>一个线程一次只能执行一个任务</strong>，执行完任务后线程就会退出。</li>
<li>目的：需要一个机制，让线程能随时处理事件但并不退出。</li>
</ul>
<p>为了实现上述目的，引入<code>Event Loop</code>模型(事件循环模型)。<code>Event Loop</code>在<code>OSX/iOS</code>里的实现是<code>RunLoop</code>。实现<strong><code>Event Loop</code>模型的关键点是：</strong>如何管理<strong>事件/消息</strong>，如何让<strong>线程</strong>在没有消息处理时休眠以避免资源占用，在有消息到来时立刻被唤醒(<code>Event Loop</code>的核心思想)。</p>
<p><code>Event Loop</code>模型的代码逻辑，通常是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模型思想的具体实现通过对象来体现。所以，<code>RunLoop</code>实际上就是一个对象，<code>RunLoop</code>对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行<strong><code>Event Loop</code>模型关键点</strong>的逻辑。线程执行了这个入口函数后，就会一直处于这个<strong>函数内部“接受消息 -&gt; 等待 -&gt; 处理”的循环</strong>中，直到这个循环结束(如传入<code>quit</code>消息)，函数返回，此时执行这个函数的线程就会退出。</p>
<p><code>OSX/iOS</code>系统中，提供了<code>NSRunLoop</code>和<code>CFRunLoopRef</code>两个实现了<code>Event Loop</code>模型思想的对象。</p>
<ul>
<li><code>CFRunLoopRef</code>是在<code>CoreFoundation</code>框架内的，它提供了纯<code>C</code>函数的<code>API</code>，所有这些<code>API</code>都是<strong>线程安全</strong>的。</li>
<li><code>NSRunLoop</code>是基于<code>CFRunLoopRef</code>的封装，提供了<strong>面向对象</strong>的<code>API</code>，但是这些<code>API</code>不是线程安全的。</li>
</ul>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a><code>RunLoop</code>与线程的关系</h3><p><code>iOS</code>开发中会遇到的两个线程对象：<code>pthread_t</code>和<code>NSThread</code>。<code>pthread_t</code>和<code>NSThread</code>是一一对应的，即<code>pthread_t</code>中有的方法，在<code>NSThread</code>中会有与之功能相同的对应方法。</p>
<p><code>CFRunLoop</code>是基于<code>pthread</code>来管理的。</p>
<p>苹果不允许直接创建<code>RunLoop</code>，只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code>和<code>CFRunLoopGetCurrent()</code>。两个函数内部的逻辑代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">/// 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">/// 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        /// 取不到时，创建一个</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析代码可知，线程和<code>RunLoop</code>之间是一一对应的，其关系是保存在一个全局的<code>Dictionary</code>里。线程刚创建时并没有<code>RunLoop</code>，如果不主动获取，那<code>RunLoop</code>一直都不会有。<code>RunLoop</code>的创建是发生在第一次获取时，<code>RunLoop</code>的销毁是发生在线程结束时。只能在一个线程的内部获取其<code>RunLoop</code>(主线程除外？)。</p>
<h3 id="RunLoop对外的接口"><a href="#RunLoop对外的接口" class="headerlink" title="RunLoop对外的接口"></a><code>RunLoop</code>对外的接口</h3><p>在<code>CoreFoundation</code>里面关于<code>RunLoop</code>有<code>5</code>个类：</p>
<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
<p>其中<code>CFRunLoopModeRef</code>类并没有对外暴露，只是通过<code>CFRunLoopRef</code>的接口进行了封装。</p>
<p>与<code>RunLoop</code>有关的<code>5</code>个类的关系如下：</p>
<p><img src="/2019/07/26/RunLoop/与RunLoop相关的类关系.png" alt="与RunLoop相关的类关系"></p>
<p>一个<code>RunLoop</code>包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source/Timer/Observer</code>。每次调用<code>RunLoop</code>的主函数时，只能指定其中一个<code>Mode</code>，这个<code>Mode</code>被称作<code>CurrentMode</code>。<strong>如果需要切换<code>Mode</code>，只能退出<code>Loop</code>，再重新指定一个<code>Mode</code>进入。</strong>这样做主要是为了分隔开不同组的<code>Source/Timer/Observer</code>，让不同组的<code>Source/Timer/Observer</code>互不影响。</p>
<ul>
<li><p><code>CFRunLoopSourceRef</code>是事件产生的地方。<code>Source</code>有两个版本：<code>Source0</code>和<code>Source1</code></p>
<ul>
<li><code>Source0</code>只包含了一个回调(函数指针)，它并不能主动触发事件</li>
<li><code>Source1</code>包含了一个<code>mach_port</code>和一个回调(函数指针)，被用于<strong>通过内核</strong>和其他线程相互发送消息</li>
</ul>
</li>
<li><p><code>CFRunLoopTimerRef</code>是基于时间的触发器，它和<code>NSTimer</code>是<code>toll-free bridge</code>的，可以混用。<code>CFRunLoopTimerRef</code>包含一个时间长度和一个回调(函数指针)。当其加入到<code>RunLoop</code>时，<code>RunLoop</code>会注册对应的时间点，当时间点到时，<code>RunLoop</code>会被唤醒以执行那个回调</p>
</li>
<li><p><code>CFRunLoopObserverRef</code>是观察者，每个<code>Observer</code>都包含了一个回调(函数指针)，当<code>RunLoop</code>的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有以下几个：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠(RunLoop将从用户态切到内核态)</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Source/Timer/Observer</code>被统称为<code>mode item</code>，一个<code>item</code>可以被同时加入多个<code>mode</code>。但一个<code>item</code>被重复加入同一个<code>mode</code>时是不会有效果的。如果一个<code>mode</code>中一个<code>item</code>都没有，则<code>RunLoop</code>(里面的主函数)会直接退出，不进入循环</p>
<h3 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a><code>RunLoop</code>的<code>Mode</code></h3><p>从<code>CFRunLoopMode</code>和<code>CFRunLoop</code>的结构去分析理解</p>
<p><code>CFRunLoopMode</code>和<code>CFRunLoop</code>的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个<code>Mode</code>可以将自己标记为<code>Common</code>属性(通过将其<code>ModeName</code>添加到<code>RunLoop</code>的<code>commonModes</code>中）。每当<code>RunLoop</code>的内容发生变化时(即<code>RunLoop</code>的成员变量发生了变化)，<code>RunLoop</code>都会自动将<code>_commonModeItems</code>里的<code>Source/Observer/Timer</code>同步到具有<code>Common</code>标记的所有<code>Mode</code>里。<code>commonModes</code>的特殊性，是同步<code>Source/Timer/Observer</code>到多个<code>Mode</code>中的一种技术方案。</p>
<p>有时需要一个<code>Timer</code>，在两个<code>Mode</code>中都能得到回调，解决方法有两种：</p>
<ul>
<li>一种办法就是将这个<code>Timer</code>分别加入这两个<code>Mode</code></li>
<li>还有一种方式，就是将<code>Timer</code>加入到顶层的<code>RunLoop</code>的<code>commonModeItems</code>中，<code>commonModeItems</code>被<code>RunLoop</code>自动更新到所有具有<code>Common</code>属性的<code>Mode</code>里去</li>
</ul>
<h5 id="操作相关的API"><a href="#操作相关的API" class="headerlink" title="操作相关的API"></a>操作相关的<code>API</code></h5><ul>
<li><code>CFRunLoop</code>对外暴露的管理<code>Mode</code>的接口只有<code>2</code>个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Mode</code>暴露的管理<code>mode item</code>的接口有下面几个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>
<p>只能通过<code>mode name</code>来操作内部的<code>mode</code>，当你传入一个新的<code>mode name</code>但<code>RunLoop</code>内部没有对应<code>mode</code>时，<code>RunLoop</code>会自动帮你创建对应的<code>CFRunLoopModeRef</code>。对于一个<code>RunLoop</code>来说，其内部的<code>mode</code>只能增加不能删除</p>
<h3 id="RunLoop的内部逻辑"><a href="#RunLoop的内部逻辑" class="headerlink" title="RunLoop的内部逻辑"></a><code>RunLoop</code>的内部逻辑</h3><p><code>RunLoop</code>内部的逻辑大致如下</p>
<p><img src="/2019/07/26/RunLoop/RunLoop内部逻辑.png" alt="RunLoop内部逻辑"></p>
<p><code>RunLoop</code>内部主要函数(<code>CFRunLoopRunSpecific</code>)的内部是一个<code>do-while</code>循环。当调用<code>CFRunLoopRun()</code>时，线程就会一直停留在这个循环里，直到超时或被手动停止，该函数才会返回。</p>
<h3 id="RunLoop的底层实现"><a href="#RunLoop的底层实现" class="headerlink" title="RunLoop的底层实现"></a><code>RunLoop</code>的底层实现</h3><p><code>RunLoop</code>的核心是基于<code>mach port</code>的，其进入休眠时调用的函数是<code>mach_msg()</code>。要理解<code>RunLoop</code>底层实现的逻辑，从<code>OSX/iOS</code>系统架构和<code>Darwin</code>核心架构进行分析。</p>
<h6 id="OSX-iOS系统架构"><a href="#OSX-iOS系统架构" class="headerlink" title="OSX/iOS系统架构"></a><code>OSX/iOS</code>系统架构</h6><p><img src="/2019/07/26/RunLoop/OSX_iOS系统架构.png" alt="OSX_iOS系统架构"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">苹果官方将整个系统大致划分为上述4个层次：</span><br><span class="line">应用层包括用户能接触到的图形应用；</span><br><span class="line">应用框架层即开发人员接触到的Cocoa等框架；</span><br><span class="line">核心框架层包括各种核心框架、OpenGL等内容；</span><br><span class="line">Darwin即操作系统的核心，包括系统内核、驱动、Shell等内容。</span><br></pre></td></tr></table></figure>
<h6 id="Darwin核心架构"><a href="#Darwin核心架构" class="headerlink" title="Darwin核心架构"></a><code>Darwin</code>核心架构</h6><p><img src="/2019/07/26/RunLoop/Darwin核心架构.png" alt="Darwin核心架构"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在硬件层上面的三个组成部分：Mach、BSD、IOKit，共同组成了XNU内核</span><br><span class="line"></span><br><span class="line">XNU内核的内环被称作Mach，其作为一个微内核，仅提供了诸如处理器调</span><br><span class="line">度、IPC(进程间通信)等非常少量的基础服务</span><br><span class="line"></span><br><span class="line">BSD层可以看作围绕Mach层的一个外环，其提供了诸如进程管理、文件系统</span><br><span class="line">和网络等功能</span><br><span class="line"></span><br><span class="line">IOKit层是为设备驱动提供了一个面向对象(C++)的一个框架</span><br></pre></td></tr></table></figure>
<p>在<code>Mach</code>中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为“对象”。和其他架构不同，<code>Mach</code>的对象间不能直接调用，只能通过<strong>消息传递</strong>的方式实现<strong>对象间的通信</strong>。“消息”是<code>Mach</code>中最基础的概念，<strong>消息在两个端口(<code>port</code>)之间传递</strong>，这就是<code>Mach</code>的<code>IPC</code>(进程间通信)的核心。</p>
<p>一条<code>Mach</code>消息实际上就是一个二进制数据包(<code>BLOB</code>)，其头部定义了当前端口<code>local_port</code>和目标端口<code>remote_port</code>，发送和接受消息是通过同一个<code>API</code>进行的，其<code>option</code>标记了消息传递的方向。</p>
<p>为了实现消息的发送和接收，<code>mach_msg()</code>函数实际上是调用了一个<code>Mach</code>陷阱(<code>trap</code>)，即函数<code>mach_msg_trap()</code>，陷阱这个概念在<code>Mach</code>中等同于系统调用。当在用户态调用<code>mach_msg_trap()</code>时会触发陷阱机制，切换到内核态。内核态中内核实现的<code>mach_msg()</code>函数会完成实际的工作。状态切换流程图如下：</p>
<p><img src="/2019/07/26/RunLoop/状态切换流程.png" alt="状态切换流程"></p>
<p><code>RunLoop</code>的核心就是一个<code>mach_msg()</code>，<code>RunLoop</code>调用这个函数去接收消息，如果没有发送<code>port</code>消息过来，内核会将线程置于等待状态。</p>
<h3 id="RunLoop的应用"><a href="#RunLoop的应用" class="headerlink" title="RunLoop的应用"></a><code>RunLoop</code>的应用</h3><p>对监听者(<code>observers</code>)而言，线程即将进入<code>RunLoop</code>，此处有<code>Observer</code>会创建<code>AutoreleasePool:_objc_autoreleasePoolPush();</code>，线程即将休眠，会通知<code>Observers</code>，即将进入休眠，此处有<code>Observer</code>释放并新建<code>AutoreleasePool: _objc_autoreleasePoolPop();`</code>_objc_autoreleasePoolPush();<code>，线程即将退出</code>RunLoop<code>，通知</code>Observers<code>，即将退出</code>RunLoop<code>，此处有</code>Observer<code>释放</code>AutoreleasePool: _objc_autoreleasePoolPop();`</p>
<h5 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a><code>AutoreleasePool</code></h5><p>主线程中的自动释放池，首次创建时，优先级最高，保证创建释放池发生在其他所有回调之前；最后释放时，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、<code>Timer</code>回调内的。这些回调会被<code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>Pool</code>了。</p>
<h5 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h5><p>苹果注册了一个<code>Source1</code>(基于<code>mach port</code>的) 用来接收系统事件，其回调函数为<code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>当一个<strong>硬件事件(触摸/锁屏/摇晃等)</strong>发生后，首先由<code>IOKit.framework</code>生成一个<code>IOHIDEvent</code>事件并由<code>SpringBoard</code>接收。<strong><code>SpringBoard</code>只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种<code>Event</code></strong>，随后<strong>用<code>mach port</code>转发给需要的<code>App</code>进程</strong>。随后苹果注册的那个<code>Source1</code>就会触发回调，并调用<code>_UIApplicationHandleEventQueue()</code>进行<strong>应用内部的分发</strong>。</p>
<p><code>_UIApplicationHandleEventQueue()</code>会把<code>IOHIDEvent</code>处理并包装成<code>UIEvent</code>进行处理或分发，其中包括识别<code>UIGesture</code>/处理屏幕旋转/发送给<code>UIWindow</code>等。通常事件比如<code>UIButton</code>点击、<code>touchesBegin/Move/End/Cancel</code>事件都是在这个回调中完成的。</p>
<h5 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h5><p>当事件响应的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用<code>Cancel</code>将当前的<code>touchesBegin/Move/End</code>系列回调打断。随后系统将对应的<code>UIGestureRecognizer</code>标记为待处理。</p>
<p>苹果注册了一个<code>Observer</code>监测<code>BeforeWaiting</code>(<code>Loop</code>即将进入休眠)事件，这个<code>Observer</code>的回调函数是<code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的<code>GestureRecognizer</code>，并执行<code>GestureRecognizer</code>的回调。当有<code>UIGestureRecognizer</code>的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h5 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h5><p>当在操作<code>UI</code>时，比如改变了<code>Frame</code>、更新了<code>UIView/CALayer</code>的层次时，或者手动调用了<code>UIView/CALayer</code>的<code>setNeedsLayout/setNeedsDisplay</code>方法后，这个<code>UIView/CALayer</code>就被标记为待处理，并被提交到一个全局的容器中去。</p>
<p>苹果注册了一个<code>Observer</code>监听<code>BeforeWaiting</code>(即将进入休眠)和<code>Exit</code>(即将退出<code>Loop</code>)事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的<code>UIView/CAlayer</code>以执行实际的绘制和调整，并更新<code>UI</code>界面。</p>
<p><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>函数的内部调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>
<h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p><code>NSTimer</code>其实就是<code>CFRunLoopTimerRef</code>，他们之间是<code>toll-free bridged</code>的。一个<code>NSTimer</code>注册到<code>RunLoop</code>后，<code>RunLoop</code>会为其重复的时间点注册好事件。<code>RunLoop</code>为了节省资源，并不会在非常准确的时间点回调这个<code>Timer</code>。<code>Timer</code>有个属性叫做<code>Tolerance</code>(宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p><code>CADisplayLink</code>是一个和屏幕刷新率一致的定时器(但实际实现原理更复杂，和<code>NSTimer</code>并不一样，其内部实际是操作了一个<code>Sourc</code>)。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去(和<code>NSTimer</code>相似)，造成界面卡顿的感觉。在快速滑动<code>TableView</code>时，即使一帧的卡顿也会让用户有所察觉。</p>
<p><code>Facebook</code>开源的<code>AsyncDisplayLink</code>就是为了解决界面卡顿的问题，其内部也用到了<code>RunLoop</code>。</p>
<h5 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a><code>PerformSelecter</code></h5><p>当调用<code>NSObject</code>的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个<code>Timer</code>并添加到<strong>当前线程的<code>RunLoop</code>中</strong>。所以如果当前线程没有<code>RunLoop</code>，则这个方法会失效。</p>
<p>当调用<code>performSelector:onThread:</code>时，实际上其会创建一个<code>Timer</code>加到对应的线程去，同样的，如果对应线程没有<code>RunLoop</code>该方法也会失效。</p>
<h5 id="GCD和RunLoop的关系"><a href="#GCD和RunLoop的关系" class="headerlink" title="GCD和RunLoop的关系"></a><code>GCD</code>和<code>RunLoop</code>的关系</h5><p><code>GCD</code>提供的某些接口也用到了<code>RunLoop</code>， 例如<code>dispatch_async()</code>。</p>
<p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，<code>libDispatch</code>会向主线程的<code>RunLoop</code>发送消息，<code>RunLoop</code>会被唤醒，并从消息中取得这个<code>block</code>，并在回调<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code>里执行这个<code>block</code>。这个逻辑仅限于<code>dispatch</code>到主线程，<code>dispatch</code>到其他线程仍然是由<code>libDispatch</code>处理的。</p>
<h5 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h5><p><code>iOS</code>中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CFSocket</code>是最底层的接口，只负责<code>socket</code>通信</li>
<li><code>CFNetwork</code>是基于<code>CFSocket</code>等接口的上层封装<code>ASIHttpRequest</code>工作于这一层</li>
<li><code>NSURLConnection</code>是基于<code>CFNetwork</code>的更高层的封装，提供面向对象的接口，<code>AFNetworking</code>工作于这一层</li>
<li><code>NSURLSession</code>是<code>iOS7</code>中新增的接口，表面上是和<code>NSURLConnection</code>并列的，但底层仍然用到了<code>NSURLConnection</code>的部分功能(比如<code>com.apple.NSURLConnectionLoader</code>线程)，<code>AFNetworking2</code>和<code>Alamofire</code>工作于这一层</li>
</ul>
<p><code>NSURLConnection</code>的工作过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通常使用NSURLConnection时，你会传入一个Delegate，当调用了</span><br><span class="line">[connection start]后，这个Delegate就会不停收到事件回调。实际</span><br><span class="line">上，start这个函数的内部会获取CurrentRunLoop，然后在其中的</span><br><span class="line">DefaultMode添加了4个Source0(即需要手动触发的Source)。</span><br><span class="line">CFMultiplexerSource是负责各种Delegate回调的，</span><br><span class="line">CFHTTPCookieStorage是处理各种Cookie的。</span><br><span class="line"></span><br><span class="line">当开始网络传输时，我们可以看到NSURLConnection创建了两个新线程：</span><br><span class="line">com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。</span><br><span class="line">其中CFSocket线程是处理底层socket连接的。</span><br><span class="line">NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层</span><br><span class="line">socket的事件，并通过之前添加的Source0通知到上层的Delegate。</span><br><span class="line"></span><br><span class="line">NSURLConnectionLoader中的RunLoop通过一些基于mach port的Source接收来自底层CFSocket的通知。当收到通知后，其会在合适的时机向CFMultiplexerSource等Source0发送通知，同时唤醒Delegate线程的RunLoop来让其处理这些通知。CFMultiplexerSource会在Delegate线程的RunLoop对Delegate执行实际的回调。</span><br></pre></td></tr></table></figure>
<p>上述工作流程图如下：</p>
<p><img src="/2019/07/26/RunLoop/NSURLConnection工作流程图.png" alt="NSURLConnection工作流程图"></p>
<h3 id="RunLoop应用举例"><a href="#RunLoop应用举例" class="headerlink" title="RunLoop应用举例"></a><code>RunLoop</code>应用举例</h3><h5 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a><code>AFNetworking</code></h5><p><code>AFURLConnectionOperation</code>这个类是基于<code>NSURLConnection</code>构建的，其希望能在后台线程接收<code>Delegate</code>回调。为此<code>AFNetworking</code>单独创建了一个线程，并在这个线程中启动了一个<code>RunLoop</code>。<code>RunLoop</code>启动前内部必须要有至少一个<code>Timer/Observer/Source</code>，所以<code>AFNetworking</code>在<code>[runLoop run]</code>之前先创建了一个新的<code>NSMachPort</code>添加进去了。</p>
<p>当需要这个后台线程执行任务时，<code>AFNetworking</code>通过调用<code>[NSObject performSelector:onThread:..]</code>将这个任务扔到了后台线程的<code>RunLoop</code>中。</p>
<h5 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a><code>AsyncDisplayKit</code></h5><p><code>UI</code>线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为<code>3</code>类：<strong>排版，绘制，<code>UI</code>对象操作。</strong></p>
<ul>
<li><strong>排版</strong>：通常包括计算视图大小、计算文本高度、重新计算子视图的排版等操作</li>
<li><strong>绘制</strong>：一般有<strong>文本绘制</strong>(例如<code>CoreText</code>)、<strong>图片绘制</strong>(例如预先解压)、<strong>元素绘制</strong>(<code>Quartz</code>)等操作</li>
<li><strong><code>UI</code>对象操作</strong>：通常包括<code>UIView/CALayer</code>等<code>UI</code>对象的创建、设置属性和销毁</li>
</ul>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果(例如<code>TextView</code>创建时可能需要提前计算出文本的大小)。</p>
<p><code>AsyncDisplayKit</code>是<code>Facebook</code>推出的用于保持界面流畅性的框架，<code>ASDK</code>所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟(例如视图的创建、属性的调整)，是针对上述情况的第三类进行处理，其原理大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ASDK创建了一个名为ASDisplayNode的对象，并在内部封装了UIView/CALayer，</span><br><span class="line">它具有和UIView/CALayer相似的属性，例如frame、backgroundColor等。</span><br><span class="line">所有这些属性都可以在后台线程更改，开发者可以只通过Node来操作其内部</span><br><span class="line">的UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论</span><br><span class="line">怎么操作，这些属性总需要在某个时刻同步到主线程的UIView/CALayer去。</span><br><span class="line"></span><br><span class="line">ASDK仿照QuartzCore/UIKit框架的模式，实现了一套类似的界面更新的</span><br><span class="line">机制：即在主线程的RunLoop中添加一个Observer，监听了</span><br><span class="line">kCFRunLoopBeforeWaiting和kCFRunLoopExit事件，在收到回调时，</span><br><span class="line">遍历所有之前放入队列的待处理的任务，然后一一执行。</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/25/技术文章-iOS/" rel="prev" title="技术文章-iOS">
      <i class="fa fa-chevron-left"></i> 技术文章-iOS
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/07/30/消息推送/" rel="next" title="消息推送">
      消息推送 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop的概念"><span class="nav-number">1.</span> <span class="nav-text">RunLoop的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop与线程的关系"><span class="nav-number">2.</span> <span class="nav-text">RunLoop与线程的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop对外的接口"><span class="nav-number">3.</span> <span class="nav-text">RunLoop对外的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop的Mode"><span class="nav-number">4.</span> <span class="nav-text">RunLoop的Mode</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#操作相关的API"><span class="nav-number">4.0.1.</span> <span class="nav-text">操作相关的API</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop的内部逻辑"><span class="nav-number">5.</span> <span class="nav-text">RunLoop的内部逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop的底层实现"><span class="nav-number">6.</span> <span class="nav-text">RunLoop的底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#OSX-iOS系统架构"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">OSX/iOS系统架构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Darwin核心架构"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">Darwin核心架构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop的应用"><span class="nav-number">7.</span> <span class="nav-text">RunLoop的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AutoreleasePool"><span class="nav-number">7.0.1.</span> <span class="nav-text">AutoreleasePool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件响应"><span class="nav-number">7.0.2.</span> <span class="nav-text">事件响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#手势识别"><span class="nav-number">7.0.3.</span> <span class="nav-text">手势识别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#界面更新"><span class="nav-number">7.0.4.</span> <span class="nav-text">界面更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#定时器"><span class="nav-number">7.0.5.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PerformSelecter"><span class="nav-number">7.0.6.</span> <span class="nav-text">PerformSelecter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GCD和RunLoop的关系"><span class="nav-number">7.0.7.</span> <span class="nav-text">GCD和RunLoop的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关于网络请求"><span class="nav-number">7.0.8.</span> <span class="nav-text">关于网络请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop应用举例"><span class="nav-number">8.</span> <span class="nav-text">RunLoop应用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AFNetworking"><span class="nav-number">8.0.1.</span> <span class="nav-text">AFNetworking</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AsyncDisplayKit"><span class="nav-number">8.0.2.</span> <span class="nav-text">AsyncDisplayKit</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
